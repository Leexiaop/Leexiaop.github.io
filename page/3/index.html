<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="前端技术栈 前端技术 前端博客 JavaScript HTML5 CSS3 VUE React Angular node Deno typeSctipt webpack wechat flutter recoil" />
       
      <meta name="description" content="敲着代码，记着BUG，通过博客的方式，记录下工作中的点点滴滴。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Lee前端技术栈</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Lee前端技术栈" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Leexiaop"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Lee前端技术栈</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['读万卷书，行万里路，代码运行了那么久，却总觉得不是最优秀。。。', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-algorithm/31"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/31/"
    >leeCode算法--求俩个数组的交集</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/31/" class="article-date">
  <time datetime="2021-07-19T03:10:48.000Z" itemprop="datePublished">2021-07-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定两个数组，编写一个函数来计算它们的交集。</p>
<p>分析：这是一个较为基础且常见的题，方法很多，比如：双指针法，去重法，二分查找法等：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var intersection = function(nums1, nums2) &#123;</span><br><span class="line">    let arr = <span class="comment">[]</span></span><br><span class="line">    for (let i =0;i&lt;nums1.length;i++) &#123;</span><br><span class="line">        for (let j=0;j&lt;nums2.length;j++) &#123;</span><br><span class="line">            if (arr.indexOf(nums1<span class="comment">[i]</span>) === -1</span><br><span class="line">                &amp;&amp; arr.indexOf(nums2<span class="comment">[j]</span>) ===-1</span><br><span class="line">                    &amp;&amp; nums1<span class="comment">[i]</span> === nums2<span class="comment">[j]</span>) &#123;</span><br><span class="line">                arr.push(nums2<span class="comment">[j]</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">intersection(<span class="comment">[1,2,2,1]</span>, <span class="comment">[2,2]</span>)  //  <span class="comment">[2]</span></span><br><span class="line">intersection(<span class="comment">[4,9,5]</span>, <span class="comment">[9,4,9,8,4]</span>)  //  <span class="comment">[4,9]</span></span><br></pre></td></tr></table></figure>
<p>运行结果： 执行用时：596 ms, 在所有 JavaScript 提交中击败了5.22的用户<br>内存消耗：38 MB, 在所有 JavaScript 提交中击败了99.13%的用户<br>可以看到双指针法的时间复杂度较高，而空间复杂度低。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> intersection = function(nums1, nums2) &#123;</span><br><span class="line">    return <span class="selector-attr">[...new Set(nums1)]</span><span class="selector-class">.filter</span>(n =&gt; nums2<span class="selector-class">.includes</span>(n))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">intersection</span><span class="params">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">2</span>])</span></span>  <span class="comment">//  [2]</span></span><br><span class="line"><span class="function"><span class="title">intersection</span><span class="params">([<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>])</span></span>  <span class="comment">//  [4,9]</span></span><br></pre></td></tr></table></figure>
<p>先用new Set()对nums1去重，再过滤，这种方法本人认为局限性较大。</p>
<p>That’s all!</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/30"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/30/"
    >leeCode算法--存在重复元素(II)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/30/" class="article-date">
  <time datetime="2021-07-18T14:33:26.000Z" itemprop="datePublished">2021-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>分析：看题目，直接就想到了<code>哈希</code>方式。统计字符出现的次数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (obj[nums[i]] !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">            i - obj[nums[i]] &lt;= k) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">       obj[nums[i]] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line">containsNearbyDuplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], <span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line">containsNearbyDuplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/29"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/29/"
    >leeCode算法--存在重复元素(I)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/29/" class="article-date">
  <time datetime="2021-07-17T15:56:52.000Z" itemprop="datePublished">2021-07-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>分析：这个题应该是比较简单的，哈希方式，统计字符出现的次数这个思路即可。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> containsDuplicate = function(nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">length</span> &lt; <span class="number">2</span>) <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">    <span class="built_in">let</span> isTrue = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">length</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">map</span>.hasOwnProperty(nums[i])) &#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]] = <span class="number">1</span></span><br><span class="line">            isTrue = <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isTrue = <span class="literal">true</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> isTrue</span><br><span class="line">&#125;;</span><br><span class="line">containsDuplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]) // <span class="literal">true</span></span><br><span class="line">containsDuplicate([<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>]) // <span class="literal">true</span></span><br><span class="line">containsDuplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/28"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/28/"
    >leeCode算法--反转字符串</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/28/" class="article-date">
  <time datetime="2021-07-17T13:49:49.000Z" itemprop="datePublished">2021-07-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>分析：本地中没什么难度，只是要注意的是不要使用额外空间，空间复杂度是O(1).</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var reverseString = function(s) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">right</span> = s.length - <span class="number">1</span></span><br><span class="line">    while (<span class="built_in">left</span> &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = s[<span class="built_in">left</span>]</span><br><span class="line">        s[<span class="built_in">left</span>] = s[<span class="built_in">right</span>]</span><br><span class="line">        s[<span class="built_in">right</span>] = temp</span><br><span class="line">        <span class="built_in">left</span>++</span><br><span class="line">        <span class="built_in">right</span>--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;;</span><br><span class="line">reverseString([<span class="string">&quot;h&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>])</span><br><span class="line">//  [<span class="string">&quot;o&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;h&quot;</span>]</span><br><span class="line">reverseString([<span class="string">&quot;H&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;h&quot;</span>])</span><br><span class="line">//  [<span class="string">&quot;h&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;H&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/27"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/27/"
    >leeCode算法--找出只出现一次的数字</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/27/" class="article-date">
  <time datetime="2021-07-16T12:52:48.000Z" itemprop="datePublished">2021-07-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。算法应该具有线性复杂度，并且不使用额外的空间。</p>
<p>解析：在给定的数组中，很有规律，除了只出现一次的元素外，其他的每个元素均只出现俩次，这就让我们想到了<code>异或运算(^)</code>。即，任意数a和0的运算：a⊕a=0;a⊕0=a,所以代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let singleNumber = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums.length) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(let <span class="selector-tag">i</span> of nums) &#123;</span><br><span class="line">        m ^= <span class="selector-tag">i</span></span><br><span class="line">    &#125;</span><br><span class="line">    return m</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">singleNumber</span><span class="params">([<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>])</span></span>   <span class="comment">//  4</span></span><br><span class="line"><span class="function"><span class="title">singleNumber</span><span class="params">([<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>])</span></span>   <span class="comment">//  1</span></span><br></pre></td></tr></table></figure>
<p>所以本题的思路是非常难的，代码很简单，快补充一下<code>异或运算</code>啊。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/26"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/26/"
    >leeCode算法--买卖股票的最佳时机(II)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/26/" class="article-date">
  <time datetime="2021-07-15T08:16:34.000Z" itemprop="datePublished">2021-07-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>分析：这就是标准的T+1股票，今天买进，只要涨，明天就卖出。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxProfit = prices =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i+<span class="number">1</span>] &gt; prices[i]) &#123;</span><br><span class="line">                <span class="built_in">sum</span> += prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">&#125;</span><br><span class="line">maxProfit([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  //  <span class="number">4</span></span><br><span class="line">maxProfit([<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>])  //  <span class="number">7</span></span><br><span class="line">maxProfit([<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>])  //  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>没什么好说的。That’s all!</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-react/5"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/react/5/"
    >React--React中setState方法的理解？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/react/5/" class="article-date">
  <time datetime="2021-07-15T07:04:41.000Z" itemprop="datePublished">2021-07-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>我们知道在react中，setState是调用频率非常高的一个函数。</p>
<h3 id="setState在默认情况下是异步的"><a href="#setState在默认情况下是异步的" class="headerlink" title="setState在默认情况下是异步的"></a>setState在默认情况下是异步的</h3><p>我们知道setState的调用是非常频繁的，那么如果setStates是同步执行，那么就意味着只要调用setState就会修改state,而state的变化，就会直接启动diff算法，从而重新渲染页面，这在性能方面的消耗实在是太过夸张。但是如果是异步执行，那么在多次setState之后，将这些操作一起合并执行。降低性能消耗成为可能。</p>
<h3 id="同步情况下的setState"><a href="#同步情况下的setState" class="headerlink" title="同步情况下的setState"></a>同步情况下的setState</h3><p>在setTimeout和原生事件中，setState是同步执行的。</p>
<h3 id="调用setState会发生什么"><a href="#调用setState会发生什么" class="headerlink" title="调用setState会发生什么"></a>调用setState会发生什么</h3><p>调用setState之后首先会将传入setState的参数和原来的state进行合并，得到新的state，那么这样state就被更新了，因为state的更新就会引起页面的重新渲染，所以，会调用触发所谓的调和过程，react的就以相对高效的方式来自动计算出新旧dom的差异，根据差异最小化来重新构建页面。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-react/4"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/react/4/"
    >React--React中React Hooks的实现原理是什么？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/react/4/" class="article-date">
  <time datetime="2021-07-15T03:13:33.000Z" itemprop="datePublished">2021-07-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="曾经的react"><a href="#曾经的react" class="headerlink" title="曾经的react"></a>曾经的react</h3><p>react技术栈的迭代是非常快的，但是版本16也许是一次革命性的迭代。从版本16开始，react的底层由stack算法转变为fiber算法，大大提高了性能。而在16.8之后react又新增了hooks的概念。在老版本的react中，开发者所开发的大多都是class组件和少部分的函数组件，对于函数组件来说，它仅仅只是一个纯UI的展示组件，只能接受props，而不能有自己的state。而对于class组件来说，问题也是不少：组件状态复用艰难，让人无奈的this问题，高阶组件和函数组件的嵌套层次太深，复杂组件变得难以理解，以及难以记忆的生命周期等问题很让人头大。</p>
<h3 id="Hooks能做点什么"><a href="#Hooks能做点什么" class="headerlink" title="Hooks能做点什么"></a>Hooks能做点什么</h3><p>总的来说Hooks的出现就是为了解决这些问题而产生的：</p>
<ul>
<li>useState函数可以初始化状态，为函数组件赋予了状态；</li>
<li>useEffect函数代替了之前的生命周期函数，接受包含命令式，可能有副作用代码的函数；</li>
<li>useContext接受上下文对象，并返回上下文对象，让深嵌套的组件通信变的简单；</li>
<li>useReducer 是useState的代替方案，接受类型为state，action =&gt; newState的reducer，并返回与dispatch方法配对的当前状态；</li>
<li>useCallback返回一个记忆的memoried版本，该版本仅在其输入发生改变时才会更改，尤其是很好的解决了函数需要绑定this这一问题；</li>
<li>useMemo一个纯记忆函数</li>
<li>useRef返回一个可变的ref对象，其.current对象被定义为初始化传递的参数</li>
<li>…</li>
</ul>
<h3 id="Hooks的实现原理"><a href="#Hooks的实现原理" class="headerlink" title="Hooks的实现原理"></a>Hooks的实现原理</h3><p>React会维护俩个链表，一个是currentHook，另外一个是WorkInProgressHook,每一个节点类型都是Hooks，每当hooks函数被调用，react就会创建一个hooks对象，并挂在链表的尾部，函数组件之所以能做一些类组件不能做的事儿，就是因为hook对象，函数组件的状态，计算值，缓存等都是交给hook去完成的，这样组件通过Fiber.memoizedState属性指向hook链表的头部来关联hook对象和当前组件，这样就发挥了hooks的作用。每次调用hooks API的时候，就会首先调用createWorkInProgressHook函数。得到hooks的串联不是一个数组，而是一个链式结构，从根节点workInProgressHook向下通过next进行串联，这也是为什么Hooks不能嵌套使用，不能在条件判断中使用，不能在循环中使用，否则链式就会被破坏。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/25"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/25/"
    >leeCode算法--搜索插入位置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/25/" class="article-date">
  <time datetime="2021-07-15T02:28:19.000Z" itemprop="datePublished">2021-07-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。</p>
<p>解析：</p>
<ul>
<li>首先给定的是一个有序数组，那么我们直接循环就OK，时间复杂度应该是O(1)</li>
<li>题目要求返回的是索引，并不是将目标元素插入到数组的某个位置，这就简单了，并不会对数组做什么操作。那么就可以说是<code>只要发现元素大于等于(&gt;=)目标元素就找到了这个位置</code>,否则就是没有找到这个位置，那么目标值一定是最大值，返回最后一个的下标就OK！</li>
<li>注意处理边界值。<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let searchInsert = (nums, target) =&gt; &#123;</span><br><span class="line">    let <span class="keyword">index</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>;</span><br><span class="line">        i &lt; nums.<span class="built_in">length</span> - <span class="number">1</span>;</span><br><span class="line">        i++</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">index</span> = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">index</span> = nums.<span class="built_in">length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">index</span></span><br><span class="line">&#125;</span><br><span class="line">searchInsert([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span>)  <span class="comment">//  3</span></span><br><span class="line">searchInsert([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span>)  <span class="comment">//  1</span></span><br><span class="line">searchInsert([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span>)  <span class="comment">//  0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
题还是比较简单，但是别让自己的思维走进死胡同，其实对于Javascript来说，有个方法叫reduce，此法也许更简洁。That’s all!</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/24"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/24/"
    >leeCode算法--买卖股票的最佳时机(I)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/24/" class="article-date">
  <time datetime="2021-07-14T09:46:55.000Z" itemprop="datePublished">2021-07-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。<br>分析：看到这个题，第一反应应该就是选择排序的思想。是的没有错。采用prices[i]和后面的每一个元素做对比。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maxProfit = prices =&gt; &#123;</span><br><span class="line">    //  取第一个元素为最小值</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">sum</span> = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> po = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">            i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; <span class="built_in">sum</span>) &#123;</span><br><span class="line">            <span class="built_in">sum</span> = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">        po = prices[i] - <span class="built_in">sum</span> &gt; po ? </span><br><span class="line">            (prices[i] - <span class="built_in">sum</span>) : po</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> po</span><br><span class="line">&#125;</span><br><span class="line">maxProfit([<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>])    // <span class="number">5</span></span><br><span class="line">maxProfit([<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>])    // <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>空间复杂度为O(1),时间复杂度为O(1),但是请考虑下面的代码是不有问题。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">maxProfit</span> = <span class="attr">prices</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">pr</span> = <span class="number">0</span></span><br><span class="line">    for (<span class="keyword">let</span> <span class="attr">i</span> = <span class="number">0</span>;i &lt; prices.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        for (<span class="keyword">let</span> <span class="attr">j</span> = i+<span class="number">1</span>;j &lt; prices.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[j]&gt;prices[i]) &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="attr">sum</span> = prices[j] - prices[i]</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; pr) <span class="attr">pr</span> = sum</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请写下你的见解！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/23"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/23/"
    >leeCode算法--多数元素问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/23/" class="article-date">
  <time datetime="2021-07-14T06:00:59.000Z" itemprop="datePublished">2021-07-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>分析：看到这个题，其实我们就直接想到了，统计给定数组中元素出现次数的问题。所以照着这个方向做就OK！</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let majorityElement = (nums) =&gt; &#123;</span><br><span class="line">    let obj = &#123;&#125;</span><br><span class="line">    let arr = <span class="selector-attr">[]</span></span><br><span class="line">    nums<span class="selector-class">.forEach</span>(n =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj<span class="selector-class">.hasOwnProperty</span>(n)) &#123;</span><br><span class="line">            obj<span class="selector-attr">[n]</span> = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj<span class="selector-attr">[n]</span>++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> (let key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj<span class="selector-attr">[key]</span> &gt; (nums.length)/<span class="number">2</span>) &#123;</span><br><span class="line">            arr<span class="selector-class">.push</span>(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">majorityElement</span><span class="params">([<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span>    <span class="comment">//  3</span></span><br><span class="line"><span class="function"><span class="title">majorityElement</span><span class="params">([<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>])</span></span>    <span class="comment">//  2</span></span><br></pre></td></tr></table></figure>
<p>其实，思路就是哈希表+排序方式，That’s all!</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/22"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/22/"
    >leeCode算法--返回最后一个单词的长度</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/22/" class="article-date">
  <time datetime="2021-07-13T09:52:55.000Z" itemprop="datePublished">2021-07-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。<br><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<p>分析：此题中唯一需要注意的就是空字符串的问题，包括，一个空字符串，或者最后有一个空。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  先将字符串通过空转化成数组</span></span><br><span class="line">    <span class="keyword">let</span> arr = s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> len = <span class="number">0</span></span><br><span class="line">    <span class="comment">//  注意i&gt;=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="comment">//  判断后面第一个不是空</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i]) &#123;</span><br><span class="line">            len = arr[i].length</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len</span><br><span class="line">&#125;</span><br><span class="line">lengthOfLastWord(<span class="string">&quot;hello world &quot;</span>) <span class="comment">// 5</span></span><br><span class="line">lengthOfLastWord(<span class="string">&quot; &quot;</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>较为简单，That’s all!</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/21"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/21/"
    >leeCode算法--验证是不是回文字符串</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/21/" class="article-date">
  <time datetime="2021-07-13T09:28:30.000Z" itemprop="datePublished">2021-07-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。本题中将空字符串,标点符号定义为有效回文字符串。</p>
<p>分析：注意这里的坑。</p>
<ul>
<li>1.忽略大小写，那么就需要统一字符串中每一个字符，要不都答谢大写，要么都小写；</li>
<li>2.将空字符串作为有效字符串，那么意味着需要将空字符串,标点符号跳过。<br>看代码：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var isPalindrome = <span class="keyword">function</span>(s) &#123;</span><br><span class="line">    <span class="comment">//  将字符串统一转成小写</span></span><br><span class="line">    s = s.<span class="keyword">to</span><span class="constructor">LocaleLowerCase()</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> isTrue = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//  只考虑数字和字母，如果不是数字和字母，则跳过</span></span><br><span class="line">    <span class="keyword">let</span> reg = /^<span class="literal">[<span class="number">0</span>-<span class="number">9</span><span class="identifier">a</span>-<span class="identifier">zA</span>-Z]</span>+$/</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!reg.test(s<span class="literal">[<span class="identifier">left</span>]</span>)<span class="operator"> ||</span></span><br><span class="line"><span class="operator">            </span>!reg.test(s<span class="literal">[<span class="identifier">right</span>]</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!reg.test(s<span class="literal">[<span class="identifier">left</span>]</span>)) &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!reg.test(s<span class="literal">[<span class="identifier">right</span>]</span>)) &#123;</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isTrue = s<span class="literal">[<span class="identifier">left</span>]</span><span class="operator"> === </span>s<span class="literal">[<span class="identifier">right</span>]</span></span><br><span class="line">        <span class="keyword">if</span>(isTrue) &#123;</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isTrue = <span class="literal">false</span></span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isTrue</span><br><span class="line">&#125;;</span><br><span class="line">is<span class="constructor">Palindrome(&#x27;0P&#x27;)</span>  <span class="comment">// false</span></span><br><span class="line">is<span class="constructor">Palindrome(&#x27;A <span class="params">man</span>, <span class="params">a</span> <span class="params">plan</span>, <span class="params">a</span> <span class="params">canal</span>: Panama&#x27;)</span>  <span class="comment">// true</span></span><br><span class="line">is<span class="constructor">Palindrome(&#x27;<span class="params">race</span> <span class="params">a</span> <span class="params">car</span>&#x27;)</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
Yes, that’s all!</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/structures/5"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/structures/5/"
    >基础数据结构--手动实现字典及其相关方法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/structures/5/" class="article-date">
  <time datetime="2021-05-31T02:46:03.000Z" itemprop="datePublished">2021-05-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>字典的定义：字典是一种以键–值来存储数据的数据结构。但是他的基础是Array,而不是Object.但是字典也是无序的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  像字典中添加健--值</span></span><br><span class="line">    <span class="built_in">this</span>.add = add</span><br><span class="line">    <span class="comment">//  保存数据</span></span><br><span class="line">    <span class="built_in">this</span>.dataStore = <span class="keyword">new</span> <span class="built_in">Array</span></span><br><span class="line">    <span class="comment">//  查找键值</span></span><br><span class="line">    <span class="built_in">this</span>.find = find</span><br><span class="line">    <span class="comment">//  删除某一项</span></span><br><span class="line">    <span class="built_in">this</span>.remove = remove</span><br><span class="line">    <span class="comment">//  统计字典中的属性个数</span></span><br><span class="line">    <span class="built_in">this</span>.count = <span class="built_in">this</span>.count</span><br><span class="line">    <span class="comment">//  清空字典</span></span><br><span class="line">    <span class="built_in">this</span>.clear = clear</span><br><span class="line">    <span class="comment">//  显示字典中所有的项</span></span><br><span class="line">    <span class="built_in">this</span>.showAll = showAll</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.dataStore[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.dataStore[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.dataStore[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.dataStore)) &#123;</span><br><span class="line">        ++n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.dataStore).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.dataStore[key]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAll</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.dataStore).sort()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.dataStore[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：字典的实现还是相对比较简单的。但是字典和对象一样，是无序的，需要自己排序。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-react/3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/react/3/"
    >React--React中Fiber算法和stack算法有和优化之处？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/react/3/" class="article-date">
  <time datetime="2021-05-28T03:38:36.000Z" itemprop="datePublished">2021-05-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>说到React，版本16将是一个较大的分水岭，尤其是在算法优化方面有了很大的更新，之前是stack算法而之后改成了fiber算法。</p>
<h3 id="stack算法的问题"><a href="#stack算法的问题" class="headerlink" title="stack算法的问题"></a>stack算法的问题</h3><p>在react一切都是组建的思想下，多层组建嵌套将会是一个非常常见的操作，那么生命周期的执行将会非常的繁琐。即，</p>
<ul>
<li>挂在阶段：<br>constructor<br>componentWillMount<br>render<br>componentDidMount</li>
<li>更新阶段<br>shouldComponentUpdate<br>componentWillUpdate<br>render<br>componentDidUpdate<br><img src="/react/3/2.jpg" alt="生命周期"><br>从顶层组件一直往下，知道最底层组建，然后再往上，组件的更新阶段也是同理。stack算法底层使用递归，而递归的方式并不会被轻易打断。那么如果组件的嵌套较深，那么递归的运算就会一直在运行，这样，react的渲染一直会占用着浏览器的主线程，这将会花费很长的时间。那么页面中的其他操作就会无法进行，出现页面卡死的现象。<h3 id="fiber算法原理"><a href="#fiber算法原理" class="headerlink" title="fiber算法原理"></a>fiber算法原理</h3>为了解决stack算法的问题，新版本的react采用了fiber算法，大致是这样做的，就是react将任务分成若干个片段，给每个任务分配一定的时间去执行这个任务，当时间耗尽后，就会检查任务列表中有没有新的或者是优先级更高的任务，如果有执行此任务，如果没有，就继续执行原来的任务。这种方式就是一步渲染的方式。加入fiber的react组件更新分为俩个阶段，以render为界，之前为phase1,之后为phase2。</li>
<li>phase1阶段<br>phase1阶段的生命周期是可中断的。每隔一段时间，就会跳出现有的渲染进程去确定是不是有新的，更重要的任务需要执行，主要是通过requestIdleCallback来构建新的tree，标出重要任务，放入到任务队列中。</li>
<li>phase2阶段<br>phase2阶段的生命周期是不可被中断的。这个阶段就是在render之后执行的，主要就是将phase1阶段的变更一次性的全部更新到DOM上。所以phase1阶段一定是一个完成的任务，否则就会重新再次执行phase1的阶段，这也就导致了某些生命周期可能会执行多次的原因。所以最好保证phase1阶段都做同一件事儿，要不然就会出问题，因此最好都是纯函数。</li>
</ul>
<h3 id="fiber数据结构"><a href="#fiber数据结构" class="headerlink" title="fiber数据结构"></a>fiber数据结构</h3><p>fiber数据结构本质上是一个链表，他有child和sibling属性，指向第一个子节点和相邻兄弟节点，从而构成fiber树，return属性指向其父节点。更新队列updateQueue是一个链表，有first和last属性指向第一个和最后一个update对象，每个fiber结构都有updateQueue属性，指向其更新的队列。每一个fiber都有一个alternate属性开始的时候指向一个自己的clone体，更新的时候会先更新这个alternate,然后通过alternate取代当前的fiber.<br><img src="/react/3/4.jpg" alt="生命周期"></p>
<h3 id="关键API–requestIdleCallback"><a href="#关键API–requestIdleCallback" class="headerlink" title="关键API–requestIdleCallback"></a>关键API–requestIdleCallback</h3><p>window.requestIdleCallback()方法将浏览器空闲时间段内的调用的函数排队。这使得主事件循环上执行后台和低优先级的工作。而不会影响延迟关键事件，如动画和输入响应。函数一般会按照先进先出的顺序执行。而如果回调函数指定执行超时，则有可能为了超时执行函数而打乱执行顺序，那么就可以在空闲回调函数中调用requestIdleCallback(),以便下一次通过时间循环之前调度另外一个回调。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>fiber算法和stack算法，做的优化主要是把任务才拆分成若干个小任务，可以随时控制任务开启和执行，采用异步的方式去执行任务。这样不会丢贞，而stack算法采用递归算法，无法中断，一条道走到黑，因此在动画等要求高的情况下，会出现卡顿现象。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> Lee
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Lee前端技术栈"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>