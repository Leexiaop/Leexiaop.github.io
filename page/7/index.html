<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="前端技术栈 前端技术 前端博客 JavaScript HTML5 CSS3 VUE React Angular node Deno typeSctipt webpack wechat flutter recoil" />
       
      <meta name="description" content="敲着代码，记着BUG，通过博客的方式，记录下工作中的点点滴滴。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Lee前端技术栈</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Lee前端技术栈" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Leexiaop"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Lee前端技术栈</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['读万卷书，行万里路，代码运行了那么久，却总觉得不是最优秀。。。', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-coding/2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/coding/2/"
    >手动实现Promise.all()方法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/coding/2/" class="article-date">
  <time datetime="2021-02-25T02:50:08.000Z" itemprop="datePublished">2021-02-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">coding</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>手动实现Promise.all()函数是面试中常做的现场coding考察，那么如何实现呢？我们先来看看Promise.all()的用法。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise<span class="selector-class">.all</span>(<span class="selector-attr">[p1, p2, p3]</span>)<span class="selector-class">.then</span>(result =&gt; &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise.all()方法接受一个数组为参数，数组中是promise，如果数组中的promise都是resolve状态，那么Promise.all()正常返回resolve,返回的数据为一个数组，就是参数中每个promise的结果组成的数组。如果promise.all()中任何一个是reject，那么promise.all()直接reject。<br>所以Promise.all()的特点可以总结为：</p>
<ul>
<li><p>1、接收一个 Promise 实例的数组或具有 Iterator 接口的对象，</p>
</li>
<li><p>2、如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</p>
</li>
<li><p>3、如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</p>
</li>
<li><p>4、只要有一个失败，状态就变为 rejected，返回值将直接传递给回调all() 的返回值也是新的 Promise 对象</p>
</li>
</ul>
<p>来看具体代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  假设我们已经实现了_Promise</span></span><br><span class="line">_Promise.prototype.all = <span class="function">(<span class="params">promiseList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promiseList)) &#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;参数错误！&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> valueList = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseList.length)</span><br><span class="line">        promiseList.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            _Promise.resolve(promise).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                valueList[index] = result  <span class="comment">//  将每次返回的结果搜集起来</span></span><br><span class="line">                <span class="keyword">if</span> (count === promiseList.length) &#123;</span><br><span class="line">                    <span class="comment">//  表示所有的promise都有结果，最终将所有的结果都resolve出去</span></span><br><span class="line">                    resolve(valueList)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> reject(err))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看，其实很简单。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/coding/" rel="tag">coding</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/api/recoil-state/selector"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/api/recoil-state/selector/"
    >Recoil API手册--Selector(options)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/api/recoil-state/selector/" class="article-date">
  <time datetime="2021-02-24T10:41:01.000Z" itemprop="datePublished">2021-02-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Selectors represent a function, or <strong>derived state</strong> in Recoil. You can think of them as similar to an “idempotent” or “pure function” without side-effects that always returns the same value for a given set of dependency values. If only a get function is provided, the selector is read-only and returns a <code>RecoilValueReadOnly</code> object. If a <code>set</code> is also provided, it returns a writeable <code>RecoilState</code> object.</p>
<p>Recoil manages atom and selector state changes to know when to notify components subscribing to that selector to re-render. If an object value of a selector is mutated directly it may bypass this and avoid properly notifying subscribing components. To help detect bugs, Recoil will freeze selector value objects in development mode.</p>
<hr>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function selector<span class="params">&lt;T&gt;</span>(&#123;</span><br><span class="line"><span class="symbol">    key:</span> string,</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    get:</span> (&#123;</span><br><span class="line"><span class="symbol">        get:</span> GetRecoilValue</span><br><span class="line">    &#125;) =&gt; T | Promise<span class="params">&lt;T&gt;</span> | RecoilValue<span class="params">&lt;T&gt;</span>,</span><br><span class="line"></span><br><span class="line">    set?: (</span><br><span class="line">        &#123;</span><br><span class="line"><span class="symbol">            get:</span> GetRecoilValue,</span><br><span class="line"><span class="symbol">            set:</span> SetRecoilState,</span><br><span class="line"><span class="symbol">            reset:</span> ResetRecoilState,</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="symbol">        newValue:</span> T | DefaultValue,</span><br><span class="line">    ) =&gt; void,</span><br><span class="line"></span><br><span class="line">    dangerouslyAllowMutability?: boolean,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">ValueOrUpdater</span>&lt;<span class="type">T</span>&gt; = <span class="type">T</span> | <span class="type">DefaultValue</span> | ((prevValue: <span class="type">T</span>) =&gt; <span class="type">T</span> | <span class="type">DefaultValue</span>);</span><br><span class="line"><span class="keyword">type</span> <span class="type">GetRecoilValue</span> = &lt;<span class="type">T</span>&gt;(<span class="type">RecoilValue</span>&lt;<span class="type">T</span>&gt;) =&gt; <span class="type">T</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="type">SetRecoilState</span> = &lt;<span class="type">T</span>&gt;(<span class="type">RecoilState</span>&lt;<span class="type">T</span>&gt;, <span class="type">ValueOrUpdater</span>&lt;<span class="type">T</span>&gt;) =&gt; void;</span><br><span class="line"><span class="keyword">type</span> <span class="type">ResetRecoilState</span> = &lt;<span class="type">T</span>&gt;(<span class="type">RecoilState</span>&lt;<span class="type">T</span>&gt;) =&gt; void;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>key</code> - A unique string used to identify the atom internally. This string should be unique with respect to other atoms and selectors in the entire application. It needs to be stable across executions if used for persistence.</p>
</li>
<li><p><code>get</code> - A function that evaluates the value for the derived state. It may return either a value directly or an asynchronous Promise or another atom or selector representing the same type. It is passed an object as the first parameter containing the following properties:</p>
<ul>
<li>get - a function used to retrieve values from other atoms/selectors. All atoms/selectors passed to this function will be implicitly added to a list of <strong>dependencies</strong> for the selector. If any of the selector’s dependencies change, the selector will re-evaluate.</li>
</ul>
</li>
<li><p><code>set?</code> - If this property is set, the selector will return <strong>writeable</strong> state. A function that is passed an object of callbacks as the first parameter and the new incoming value. The incoming value may be a value of type T or maybe an object of type <code>DefaultValue</code> if the user reset the selector. The callbacks include:</p>
<ul>
<li><code>get</code> - a function used to retrieve values from other atoms/selectors. This function will not subscribe the selector to the given atoms/selectors.</li>
<li><code>set</code> - a function used to set the values of upstream Recoil state. The first parameter is the Recoil state and the second parameter is the new value. The new value may be an updater function or a DefaultValue object to propagate reset actions.</li>
</ul>
</li>
<li><p><code>dangerouslyAllowMutability</code> - In some cases it may be desireable allow mutating of objects stored in selectors that don’t represent state changes. Use this option to override freezing objects in development mode.</p>
</li>
</ul>
<hr>
<p>A selector with a simple static dependency:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySelector = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MySelector&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; <span class="keyword">get</span>(myAtom) * <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Dynamic-Dependencies"><a href="#Dynamic-Dependencies" class="headerlink" title="Dynamic Dependencies"></a>Dynamic Dependencies</h3><p>A read-only selector has a <code>get</code> method which evaluates the value of the selector based on dependencies. If any of those dependencies are updated, then the selector will re-evaluate. The dependencies are dynamically determined based on the atoms or selectors you actually use when evaluating the selector. Depending on the values of the previous dependencies, you may dynamically use different additional dependencies. Recoil will automatically update the current data-flow graph so that the selector is only subscribed to updates from the current set of dependencies.</p>
<p>In this example <code>mySelector</code> will depend on the <code>toggleState</code> atom as well as either <code>selectorA</code> or <code>selectorB</code> depending on the state of <code>toggleState</code>.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toggleState = atom(&#123;<span class="built_in">key</span>: <span class="string">&#x27;Toggle&#x27;</span>, <span class="keyword">default</span>: <span class="keyword">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mySelector = selector(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;MySelector&#x27;</span>,</span><br><span class="line">    <span class="built_in">get</span>: (&#123;<span class="built_in">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> toggle = <span class="built_in">get</span>(toggleState);</span><br><span class="line">        <span class="keyword">if</span> (toggle) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">get</span>(selectorA);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">get</span>(selectorB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Writeable-Selectors"><a href="#Writeable-Selectors" class="headerlink" title="Writeable Selectors"></a>Writeable Selectors</h3><p>A bi-directional selector receives the incoming value as a parameter and can use that to propagate the changes back upstream along the data-flow graph. Because the user may either set the selector with a new value or reset the selector, the incoming value is either of the same type that the selector represents or a <code>DefaultValue</code> object which represents a reset action.</p>
<p>This simple selector essentially wraps an atom to add an additional field. It just passes through set and reset operations to the upstream atom.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxySelector = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;ProxySelector&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; (&#123;...<span class="keyword">get</span>(myAtom), extraField: <span class="string">&#x27;hi&#x27;</span>&#125;),</span><br><span class="line">    <span class="keyword">set</span>: (&#123;<span class="keyword">set</span>&#125;, newValue) =&gt; <span class="keyword">set</span>(myAtom, newValue),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This selector transforms the data, so needs to check if the incoming value is a <code>DefaultValue</code>.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transformSelector = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;TransformSelector&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; <span class="keyword">get</span>(myAtom) * <span class="number">100</span>,</span><br><span class="line">    <span class="keyword">set</span>: (&#123;<span class="keyword">set</span>&#125;, newValue) =&gt;</span><br><span class="line">        <span class="keyword">set</span>(myAtom, newValue instanceof DefaultValue ? newValue : newValue / <span class="number">100</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Asynchronous-Selectors"><a href="#Asynchronous-Selectors" class="headerlink" title="Asynchronous Selectors"></a>Asynchronous Selectors</h3><p>Selectors may also have asynchronous evaluation functions and return a <code>Promise</code> to the output value. Please see <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/guides/asynchronous-data-queries">this guide</a> for more information.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myQuery = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MyQuery&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: <span class="keyword">async</span> (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> myAsyncQuery(<span class="keyword">get</span>(queryParamState));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Example-Synchronous"><a href="#Example-Synchronous" class="headerlink" title="Example (Synchronous)"></a>Example (Synchronous)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom, selector, useRecoilState, DefaultValue&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tempFahrenheit = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;tempFahrenheit&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">32</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tempCelsius = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;tempCelsius&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> ((get(tempFahrenheit) - <span class="number">32</span>) * <span class="number">5</span>) / <span class="number">9</span>,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">&#123;set&#125;, newValue</span>) =&gt;</span></span><br><span class="line">        set(</span><br><span class="line">            tempFahrenheit,</span><br><span class="line">            newValue <span class="keyword">instanceof</span> DefaultValue ? newValue : (newValue * <span class="number">9</span>) / <span class="number">5</span> + <span class="number">32</span></span><br><span class="line">        ),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TempCelsius</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [tempF, setTempF] = useRecoilState(tempFahrenheit);</span><br><span class="line">    <span class="keyword">const</span> [tempC, setTempC] = useRecoilState(tempCelsius);</span><br><span class="line">    <span class="keyword">const</span> resetTemp = useResetRecoilState(tempCelsius);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> addTenCelsius = <span class="function">() =&gt;</span> setTempC(tempC + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> addTenFahrenheit = <span class="function">() =&gt;</span> setTempF(tempF + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> reset = <span class="function">() =&gt;</span> resetTemp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            Temp (Celsius): &#123;tempC&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            Temp (Fahrenheit): &#123;tempF&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addTenCelsius&#125;</span>&gt;</span>Add 10 Celsius<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addTenFahrenheit&#125;</span>&gt;</span>Add 10 Fahrenheit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;reset&#125;</span>&gt;</span>&gt;Reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example-Asynchronous"><a href="#Example-Asynchronous" class="headerlink" title="Example (Asynchronous)"></a>Example (Asynchronous)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;selector, useRecoilValue&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;MyDBQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(getMyRequestUrl());</span><br><span class="line">        <span class="keyword">return</span> response.json();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QueryResults</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queryResults = useRecoilValue(myQuery);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;queryResults.foo&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ResultsSection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">QueryResults</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Please see <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/guides/asynchronous-data-queries">this guide</a> for more complex examples.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-css/1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/css/1/"
    >CSS--盒子模型</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/css/1/" class="article-date">
  <time datetime="2021-02-24T10:34:22.000Z" itemprop="datePublished">2021-02-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>编写中，敬请期待。。。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-javascript/1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/javascript/1/"
    >JavaScript--如何理解cookie, session, token？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/javascript/1/" class="article-date">
  <time datetime="2021-02-24T10:25:55.000Z" itemprop="datePublished">2021-02-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>编写中，敬请期待。。。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/" rel="tag">网络与安全</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-wechat/2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/wechat/2/"
    >微信系列--Android机微信小程序手写输入不能获取完整字符</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/wechat/2/" class="article-date">
  <time datetime="2021-02-24T06:25:23.000Z" itemprop="datePublished">2021-02-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/wechat/">wechat</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>问题描述：<br>微信小程序表单输入使用手写输入法，当输入完成后，点击空白处键盘收起，这时，绑定的input事件或者是change事件并不能获取到完整的输入内容。原因在于，<code>当输入的文字有下划线的时候，手机不认为输入完成</code>。</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">van-field</span> <span class="attr">label</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span> <span class="attr">bind:change</span>=<span class="string">&quot;getUsername&quot;</span> <span class="attr">border</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">false</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">value</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">form.userName</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">isReadonly</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">van-field</span>&gt;</span></span></span><br><span class="line"><span class="xml">getUsername (value) &#123;</span></span><br><span class="line"><span class="xml">    this.setData(&#123;&#x27;form.userName&#x27;: value.detail&#125;)</span></span><br><span class="line"><span class="xml">&#125;,</span></span><br></pre></td></tr></table></figure>
<p>解决兼容性问题的方法是添加blur事件。</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">van-field</span> <span class="attr">label</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span> <span class="attr">bind:blur</span>=<span class="string">&quot;getUsernames&quot;</span> <span class="attr">bind:change</span>=<span class="string">&quot;getUsername&quot;</span> <span class="attr">border</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">false</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">value</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">form.userName</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">isReadonly</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">van-field</span>&gt;</span></span></span><br><span class="line"><span class="xml">getUsername (value) &#123;</span></span><br><span class="line"><span class="xml">    this.setData(&#123;&#x27;form.userName&#x27;: value.detail&#125;)</span></span><br><span class="line"><span class="xml">&#125;,</span></span><br><span class="line"><span class="xml">getUsernames (value) &#123;</span></span><br><span class="line"><span class="xml">    this.setData(&#123;&#x27;form.userName&#x27;: value.detail.value&#125;)</span></span><br><span class="line"><span class="xml">&#125;,</span></span><br></pre></td></tr></table></figure>
<p>这样可以保证在失去焦点的时候，能获取到全部的输入值。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wechat/" rel="tag">wechat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/" rel="tag">实战案例</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-wechat/1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/wechat/1/"
    >微信系列--微信小程序授权登陆流程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/wechat/1/" class="article-date">
  <time datetime="2021-02-22T10:31:23.000Z" itemprop="datePublished">2021-02-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/wechat/">wechat</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>小程序开发了这么久。无论是工作还是面试，总会遇到一些问题，需要去总结。登陆问题一直以来都是面试考察的重点，所以我来总结一下小程序登陆的流程。<br>首先，我们需要搞明白，登陆是为了什么？<br>这么说其实有点蠢，但是我们又不得不这么说，因为很多人不知道登陆是干什么,其实从页面效果来看呢，就是要拿到用户信息展示在页面上，从技术角度来说呢，就是要拿到登陆的凭证–token。仅此而已，OK，知道了这俩点呢。我们就可以开干了。</p>
<h3 id="手动授权登陆"><a href="#手动授权登陆" class="headerlink" title="手动授权登陆"></a>手动授权登陆</h3><p>在手动授权之前，我们可以先公共微信提供的API来检查用户是不是已经授权过：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.getSetting</span>()</span><br></pre></td></tr></table></figure>
<p>如果没有授权，那么在新版本的小程序登陆中，微信做了限制，要求用户必须手动，所以我们需要在页面中写点代码：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button <span class="attribute">class</span>=<span class="string">&#x27;bottom&#x27;</span> <span class="attribute">type</span>=<span class="string">&#x27;primary&#x27;</span> <span class="attribute">open-type</span>=<span class="string">&quot;getUserInfo&quot;</span> <span class="attribute">lang</span>=<span class="string">&quot;zh_CN&quot;</span> <span class="attribute">bindgetuserinfo</span>=<span class="string">&quot;bindGetUserInfo&quot;</span>&gt;授权登录&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里要求必须设置open-type=”getUserInfo”<br>这样点击按钮：<br><img src="/wechat/1/1.png" alt="登陆按钮"><br>就可以调起授权弹窗了。<br><img src="/wechat/1/2.png" alt="手动授权弹窗"><br>点允许，那么授权成功，这时会拿到用户的一些信息，<br><img src="/wechat/1/3.png" alt="用户信息"><br>这样我们再调用：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.login</span>()</span><br></pre></td></tr></table></figure>
<p>用来获取微信的临时凭证，将获取到的信息和appid(小程序管理后台获取)一并发给我们自己的服务端，我们的服务端会拿着这些东西去微信服务器换取openid和session_key,这样我们自己的服务端就可以生成自己自定义的登陆态（token）,r然后返回给前端，前端存储在localStorage.就可以发起业务请求了。<br><img src="/wechat/1/login.png" alt="alt 属性文本"></p>
</li>
<li><p>某些业务场景可能会需要手机号，因为获取手机号。所以需要调用，这里也必须要用户自己触发，且必须设置open-type=”getPhoneNumber”：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;button <span class="keyword">open</span>-type=<span class="string">&quot;getPhoneNumber&quot;</span> bindgetphonenumber=<span class="string">&quot;getPhoneNumber&quot;</span>&gt;获取手机号&lt;/button&gt;</span><br><span class="line">getPhoneNumber(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (e.detail.errMsg !== <span class="string">&#x27;getPhoneNumber:ok&#x27;</span>) &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">            title: <span class="string">&#x27;获取手机号失败&#x27;</span>,</span><br><span class="line">            icon: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>微信授权登陆，大致就是这样！！！！！！！！！！！！！</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/wechat/" rel="tag">wechat</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/api/recoil-state/atom"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/api/recoil-state/atom/"
    >Recoil API手册--atom(options)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/api/recoil-state/atom/" class="article-date">
  <time datetime="2021-02-22T01:03:09.000Z" itemprop="datePublished">2021-02-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>An atom represents state in Recoil. The <code>atom()</code> function returns a writeable <code>RecoilState</code> object.<br>atom代表了Recoil中的状态，<code>atom()</code>返回了一个可读写的Recoil状态对象。</p>
<hr>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> atom<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">   <span class="built_in"> key</span>:<span class="built_in"> string</span>,</span></span><br><span class="line"><span class="xquery">    default: T | Promise<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span> | RecoilValue</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>,</span></span></span><br><span class="line"><span class="xml"><span class="xquery">    effects_UNSTABLE?: $ReadOnlyArray&lt;AtomEffect</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>&gt;,</span></span></span><br><span class="line"><span class="xml"><span class="xquery">    dangerouslyAllowMutability?: boolean,</span></span></span><br><span class="line"><span class="xml"><span class="xquery">&#125;</span></span><span class="xml">): RecoilState</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>key</code> - A unique string used to identify the atom internally. This string should be unique with respect to other atoms and selectors in the entire application.<br><code>key</code>字段是一个用来定义内部atom的唯一的字符串，这个是字符串必须是唯一的，用来区分应用程序中所有的atoms和selector.</li>
<li><code>default</code> - The initial value of the atom or a Promise or another atom or selector representing a value of the same type.<br><code>default</code>字段用来初始化一个atom或者Promise或者另一个atom或者是selector具有相同类型的初始值。</li>
<li><code>effects_UNSTABLE</code> - An optional array of Atom Effects for the atom.<br><code>effects_UNSTABLE</code>字段一个可选的atom副作用数组。</li>
<li><code>dangerouslyAllowMutability</code> - In some cases it may be desireable allow mutating of objects stored in atoms that don’t represent state changes. Use this option to override freezing objects in development mode.<br><code>dangerouslyAllowMutability</code>在某些情况下，他是用来描述允许atoms存储的对象发生转化，但是并不代表状态会发生变化。可以用这个选项在开发环境来冻结对象。</li>
</ul>
<hr>
<p>Recoil manages atom state changes to know when to notify components subscribing to that atom to re-render, so you should use the hooks listed below to change atom state. If an object stored in an atom was mutated directly it may bypass this and cause state changes without properly notifying subscribing components. To help detect bugs Recoil will freeze objects stored in atoms in development mode.</p>
<p>Recoil管理atom状态是通过通知组建订阅atom状态实现重新渲染，所以，应该使用下面的hooks函数来使得atom状态发生变化。如果一个存储在atom中的对象被直接改变，那就会引起组建没有被通知订阅而atom状态发生变化。为了解决这个bug，Recoil会在开发环境冻结存储在atom中的对象。</p>
<p>Most often, you’ll use the following hooks to interact with atoms:<br>通常情况下，需要使用下列的hooks函数来使得atoms发生变化。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilState">useRecoilState()</a>: Use this hook when you intend on both reading and writing to the atom. This hook subscribes the component to the atom.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilState">useRecoilState()</a>:当你要读写atom的时候使用这个钩子函数，这个钩子函数会订阅组建的atom.</li>
<li><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilValue">useRecoilValue()</a>: Use this hook when you intend on only reading the atom. This hook subscribes the component to the atom.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilValue">useRecoilValue()</a>:当只是读取atom的时候。使用这个钩子函数，这个钩子函数会订阅组建的atom.</li>
<li><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useSetRecoilState">useSetRecoilState()</a>: Use this hook when you intend on only writing to the atom.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useSetRecoilState">useSetRecoilState()</a>:当只是操作atom的时候。使用这个钩子函数。</li>
<li><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useResetRecoilState">useResetRecoilState()</a>: Use this hook to reset an atom to its default value.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useResetRecoilState">useResetRecoilState()</a>:当重置atom的默认值的时候，使用这个钩子函数。<br>For rare cases where you need to read an atom’s value without subscribing to the component, see <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a>.</li>
</ul>
<p>对于极少数需要读取atom的值，而不需要订阅组建，可以参考<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a>。</p>
<p>You can initialize an atom either with a static value or with a <code>Promise</code> or a <code>RecoilValue</code> representing a value of the same type. Because the Promise may be pending or the default selector may be asynchronous it means that the atom value may also be pending or throw an error when reading. Note that you cannot currently assign a <code>Promise</code> when setting an atom. Please use <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/selector">selectors</a> for async functions.</p>
<p>可以用通过一个具有共同类型的静态值或者是一个<code>Promise</code>或者是一个<code>RecoilValue</code>来初始化atom.因为Promise也许是进行中，或者默认的selector会是异步的，这就会使得atom的状态也是处于进行中或者是抛出一个错误。所以，当是这atom的时候，并不能将当前标注为<code>Promise</code>,请使用selector异步函数。</p>
<p>Atoms cannot be used to store <code>Promise&#39;s</code> or <code>RecoilValue&#39;s</code> directly, but they may be wrapped in an object. Note that <code>Promise&#39;s</code> may be mutable. Atoms can be set to a <code>function</code>, as long as it is pure, but to do so you may need to use the updater form of setters. (e.g. <code>set(myAtom, () =&gt; myFunc);</code>).</p>
<p>Atoms不能被直接才存储为<code>Promise</code>或者是<code>RecoilValue&#39;s</code>, 但是他们可以被包裹为一个对象。注意<code>Promise</code>可能被改变。Atoms可以被设置为是个函数，只要纯净，就可以使用setters的更新方式。(e.g. <code>set(myAtom, () =&gt; myFunc);</code>).</p>
<p>案例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom, useRecoilState&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;myCounter&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useRecoilState(counter);</span><br><span class="line">    <span class="keyword">const</span> incrementByOne = <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            Count: &#123;count&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;incrementByOne&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/1/"
    >LeetCode算法--求俩数之和</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/1/" class="article-date">
  <time datetime="2021-01-19T03:21:19.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个数组nums和一个目标值target,从数组中找到俩个元素的和等于目标值target，并返回这俩个元素的位置。<br>思路一：暴力算法，将数组中的俩个元素相加，如果等于目标值target，那么返回其位置。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let <span class="function"><span class="keyword">fun</span> = <span class="params">(nums, target)</span></span> =&gt; &#123;</span><br><span class="line">    let result = []</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (let j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                result.push(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>1,这里需要注意的是循环的边界值，i &lt; nums.length - 1, j &lt; nums.length<br>2,因为做了俩层循环，所以时间复杂度是O(n<sup>2</sup>),声明了三个变量，空间复杂度是O(n)</p>
<p>思路二：由于上面的暴力算法时间复杂度比较高，所以我们可以再时间复杂度上做一点优化，我们可不可以将时间复杂度降低到O(N)呢？当然是可以的，对于每一个 nums[ i ]，我们首先查询哈希表中是否存在 target - nums[ i ]，然后将 nums[ i ] 插入到哈希表中，即可保证不会让 nums[ i ] 和自己匹配。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> fun = (nums, target) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> result = []</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">map</span> = <span class="built_in">new</span> Map()</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">map</span>.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">length</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">let</span> item = target - nums[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.has(item) &amp;&amp; <span class="built_in">map</span>.<span class="built_in">get</span>(item) !== i) &#123;</span><br><span class="line">            result.<span class="built_in">push</span>(i);</span><br><span class="line">            result.<span class="built_in">push</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(item))</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>我们首先创建了一个map结构，用来保存数组中的元素和位置，作为哈希表。然后按照思路二来实现。遍历一次，也降低了时间复杂度。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/api/recoilroot"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/api/recoilroot/"
    >Recoil API手册--&lt;RecoilRoot /&gt;</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/api/recoilroot/" class="article-date">
  <time datetime="2021-01-11T02:25:18.000Z" itemprop="datePublished">2021-01-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="lt-RecoilRoot-…props-gt"><a href="#lt-RecoilRoot-…props-gt" class="headerlink" title="&lt;RecoilRoot …props /&gt;"></a>&lt;RecoilRoot …props /&gt;</h4><p>Provides the context in which atoms have values. Must be an ancestor of any component that uses any Recoil hooks. Multiple roots may co-exist; atoms will have distinct values within each root. If they are nested, the innermost root will completely mask any outer roots.<br>为atoms提供上下文。必须是所有是使用Recoil hooks组建的根组建，多个根组建也许可以共存，atoms需要对不同的根组建进行区别。如果它们是嵌套的，最里面的根将完全掩盖任何外部根。<br>Props:<br>    <code>initializeState?: (MutableSnapshot =&gt; void)</code><br>    An optional function that takes a <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/Snapshot#transforming-snapshots">MutableSnapshot to</a> <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/Snapshot#state-initialization">initialize</a> the <RecoilRoot> atom state. This sets up the state for the initial render and is not intended for subsequent state changes or async initialization. Use hooks such as <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useSetRecoilState">useSetRecoilState()</a> or <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a> for async state changes.<br>    通过一个可选函数来初始化根RecoilRoot组建的atom状态。这将设置初始呈现的状态，而不是用于后续状态更改或异步初始化。利用hooks函数如useSetRecoilState()或者useRecoilCallback()实现异步更新状态。</RecoilRoot></p>
<p><code>&lt;RecoilRoot&gt;&#39;s</code> represent independent providers/stores of atom state. Note that caches, such as selector caches, may be shared across roots. Selector evaluations must be idempotent except for caching or logging, so this should not be a problem, but may be observable or may cause redundant queries to be cached across roots.<br><RecoilRoot>组建是atom状态的独立的Provider/store.请注意，缓存（如选择器缓存）可以跨根共享。选择器求值必须是幂等的（除了缓存或日志记录），所以这应该不是问题，但可能是可观察的，或者可能导致在根之间缓存冗余查询。</RecoilRoot></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;RecoilRoot&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ComponentThatUsesRecoil</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/guides/dev-tools"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/guides/dev-tools/"
    >Recoil指南--Dev Tools 开发工具</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/guides/dev-tools/" class="article-date">
  <time datetime="2020-11-28T03:07:13.000Z" itemprop="datePublished">2020-11-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Dev-Tools-开发工具"><a href="#Dev-Tools-开发工具" class="headerlink" title="Dev Tools 开发工具"></a>Dev Tools 开发工具</h4><p>Recoil has functionality to allow you to observe and update state changes.<br>Recoil可以允许您监听并且更新状态变化。</p>
<hr>
<h4 id="IMPORTANT-NOTE-重点关注"><a href="#IMPORTANT-NOTE-重点关注" class="headerlink" title="IMPORTANT NOTE 重点关注"></a>IMPORTANT NOTE 重点关注</h4><p>This API is currently under development and will change. Please stay tuned…<br>这个API当前还在开发中，并且会有变化，请稍等…</p>
<hr>
<h4 id="Observing-All-State-Changes-监听所有的状态变化"><a href="#Observing-All-State-Changes-监听所有的状态变化" class="headerlink" title="Observing All State Changes 监听所有的状态变化"></a>Observing All State Changes 监听所有的状态变化</h4><p>You can use a hook such as <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilSnapshot">useRecoilSnapshot()</a> or <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilTransactionObserver">useRecoilTransactionObserver_UNSTABLE()</a> to subscribe to state changes and obtain a <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a> of the new state.<br>可以使用诸如<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilSnapshot">useRecoilSnapshot()</a>或者<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilTransactionObserver">useRecoilTransactionObserver_UNSTABLE()</a>的钩子函数来订阅状态的变化，或者是添加一个<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a>的新状态。</p>
<p>Once you have a <code>Snapshot</code>, you can use methods such as <code>getLoadable()</code>, <code>getPromise()</code>, and <code>getInfo()</code> to inspect the state and use <code>getNodes()</code> to iterate over the set of known atoms.<br>一旦使用Snapshot,你就可以用类似于<code>getLoadable()</code>, <code>getPromise()</code>, 和 <code>getInfo()</code>方法去检查state,用<code>getNodes()</code>方法来迭代atoms.</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> DebugObserver(): React.Node &#123;</span><br><span class="line">    const<span class="built_in"> snapshot</span> = useRecoilSnapshot();</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        console.debug(<span class="string">&#x27;The following atoms were modified:&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (const <span class="type">node</span> <span class="keyword">of</span><span class="built_in"> snapshot</span>.getNodes(&#123;modified:<span class="built_in"> true</span>&#125;)) &#123;</span><br><span class="line">        console.debug(<span class="type">node</span><span class="built_in">.key</span>,<span class="built_in"> snapshot</span>.getLoadable(<span class="type">node</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="built_in">[snapshot</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">DebugObserver</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            ...</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Observing-State-Changes-On-Demand-按需监听state的变化"><a href="#Observing-State-Changes-On-Demand-按需监听state的变化" class="headerlink" title="Observing State Changes On-Demand 按需监听state的变化"></a>Observing State Changes On-Demand 按需监听state的变化</h4><p>Or, you can use the <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a> hook to obtain a <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a> on-demand.<br>可以使用使用<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a>hook函数来获取按需<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DebugButton</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> onClick = useRecoilCallback(<span class="function">(<span class="params">&#123;snapshot&#125;</span>) =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.debug(<span class="string">&#x27;Atom values:&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> snapshot.getNodes()) &#123;</span><br><span class="line">            <span class="keyword">const</span> value = <span class="keyword">await</span> snapshot.getPromise(node);</span><br><span class="line">            <span class="built_in">console</span>.debug(node.key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>Dump State<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Time-Travel"><a href="#Time-Travel" class="headerlink" title="Time Travel"></a>Time Travel</h4><p>The <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useGotoRecoilSnapshot">useGotoRecoilSnapshot()</a> hook can be used to update the entire Recoil state to match the provided <code>Snapshot</code>. This example maintains a history of state changes with the ability to go back and restore previous global state.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useGotoRecoilSnapshot">useGotoRecoilSnapshot()</a> 钩子函数可以用来更新全部的Recoil状态来匹配所提供的<code>Snapshot</code>,此示例维护了状态更改的历史，并能够返回和恢复以前的全局状态。<br><code>Snapshot&#39;s</code> also provide a <code>getID()</code> method. That can be used, for example, to help determine if you are reverting to a previous known state to avoid updating your snapshot history.<br>Snapshot同样提供了<code>getID()</code>的方法。例如，可以使用它来帮助确定您是否正在恢复到以前的已知状态，以避免更新快照历史记录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeTravelObserver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [snapshots, setSnapshots] = useState([]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> snapshot = useRecoilSnapshot();</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (snapshots.every(<span class="function"><span class="params">s</span> =&gt;</span> s.getID() !== snapshot.getID())) &#123;</span><br><span class="line">            setSnapshots([...snapshots, snapshot]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [snapshot]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gotoSnapshot = useGotoRecoilSnapshot();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;snapshots.map((snapshot, i) =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                Snapshot &#123;i&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> gotoSnapshot(snapshot)&#125;&gt;</span></span><br><span class="line"><span class="xml">                    Restore</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/guides/testing"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/guides/testing/"
    >Recoil指南--Testing 测试</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/guides/testing/" class="article-date">
  <time datetime="2020-11-26T08:07:13.000Z" itemprop="datePublished">2020-11-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Testing-Recoil-Selectors-outside-of-React-React之外测试Recoil的Selectors"><a href="#Testing-Recoil-Selectors-outside-of-React-React之外测试Recoil的Selectors" class="headerlink" title="Testing Recoil Selectors outside of React React之外测试Recoil的Selectors"></a>Testing Recoil Selectors outside of React React之外测试Recoil的Selectors</h4><p>It can be useful to manipulate and evaluate Recoil selectors outside of a React context for testing. This can be done by working with a Recoil <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a>. You can build a fresh snapshot using <code>snapshot_UNSTABLE()</code> and then use that <code>Snapshot</code> to evaluate selectors for testing.<br>脱离React来测试Recoil的Selectors是非常有用的。这可以通过Recolid的Snapshot来实现。可以通过<code>snapshot_UNSTABLE()</code>函数来创建一个全新的snapshot，然后用<code>Snapshot</code>来实现selector的测试。</p>
<h4 id="Example-Jest-unit-testing-selectors-Selectors的单元测试"><a href="#Example-Jest-unit-testing-selectors-Selectors的单元测试" class="headerlink" title="Example: Jest unit testing selectors Selectors的单元测试"></a>Example: Jest unit testing selectors Selectors的单元测试</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberState = atom(&#123;key: <span class="string">&#x27;Number&#x27;</span>, <span class="keyword">default</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multipliedState = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MultipliedNumber&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; <span class="keyword">get</span>(numberState) * <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;Test multipliedState&#x27;</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> initialSnapshot = snapshot_UNSTABLE();</span><br><span class="line">    expect(mySnapshot.getLoadable(multipliedState).valueOrThrow()).toBe(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> testSnapshot = snapshot_UNSTABLE((&#123;<span class="keyword">set</span>&#125;) =&gt; <span class="keyword">set</span>(numberState, <span class="number">1</span>));</span><br><span class="line">    expect(mySnapshot.getLoadable(multipliedState).valueOrThrow()).toBe(<span class="number">100</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-coding/1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/coding/1/"
    >手动实现Javascript中new操作符</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/coding/1/" class="article-date">
  <time datetime="2020-11-10T08:31:19.000Z" itemprop="datePublished">2020-11-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">coding</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>想要实现new操作符，首先要知道new操作符都干了什么事儿？</p>
<ul>
<li>创建了一个空，将this指向这个对象</li>
<li>将创建的空对象的<code>__proto__</code>属性继承自构造函数的<code>prototype</code>属性，也就是说是继承构造函数的原型对象上的方法和属性</li>
<li>调用构造函数，将构造函数中的this替换为空对象的this，继承构造函数中的属性</li>
<li>返回函数内部的这个新对象</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function _new (<span class="function"><span class="keyword">fun</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> function () &#123;</span><br><span class="line">        let obj = &#123;&#125;</span><br><span class="line">        obj.__proto__ = <span class="keyword">fun</span>.prototype</span><br><span class="line">        <span class="keyword">fun</span>.call(obj, ...arguments)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person <span class="built_in">(name</span>, age) &#123;</span><br><span class="line">    this<span class="built_in">.name</span> =<span class="built_in"> name</span></span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = _new(Person)(<span class="string">&#x27;小明&#x27;</span>, <span class="number">3</span>) //=&gt; <span class="built_in">&#123;name</span>: <span class="string">&#x27;小明&#x27;</span>, age: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/coding/" rel="tag">coding</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/guides/atom-effects"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/guides/atom-effects/"
    >Recoil指南--Atom Effects Atom副作用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/guides/atom-effects/" class="article-date">
  <time datetime="2020-11-09T10:07:03.000Z" itemprop="datePublished">2020-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="Atom-Effects-Atom副作用"><a href="#Atom-Effects-Atom副作用" class="headerlink" title="Atom Effects Atom副作用"></a>Atom Effects Atom副作用</h3><p>Atom Effects are a new experimental API for managing side-effects and initializing Recoil atoms. They have a variety of useful applications such as state persistence, state synchronization, managing history, logging, &amp;c. They are defined as part of the atom definition, so each atom can specify and compose their own policies. This API is still evolving, and thus marked as <code>_UNSTABLE</code>.<br>Atom Effects是为了管理副作用和初始化Recoil Atom的实验性的API。它会有多种应用，例如：状态持久化，同步状态，历史管理，日志等。这些都被定义为Atom最初定义的一部分。所以每个部分都可以有指定或者组合自己的策略。这些API还在开发中，所以暂时就把它称作<code>_UNSTABLE</code>版本吧。</p>
<hr>
<h3 id="IMPORTANT-NOTE-重要提示"><a href="#IMPORTANT-NOTE-重要提示" class="headerlink" title="IMPORTANT NOTE 重要提示"></a>IMPORTANT NOTE 重要提示</h3><p>This API is currently under development and will change. Please stay tuned…<br>这些API还在开发中。并且会有变化，所以再等等。。。。</p>
<hr>
<p>An atom effect is a function with the following definition.<br>Atom副作用是下面定义的函数：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type AtomEffect&lt;T&gt; = (&#123;</span><br><span class="line">    <span class="attr">node</span>: RecoilState&lt;T&gt;, <span class="comment">// A reference to the atom itself</span></span><br><span class="line">    trigger: <span class="string">&#x27;get&#x27;</span> | <span class="string">&#x27;set&#x27;</span>, <span class="comment">// The action which triggered initialization of the atom</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callbacks to set or reset the value of the atom.</span></span><br><span class="line">    <span class="comment">// This can be called from the atom effect function directly to initialize the</span></span><br><span class="line">    <span class="comment">// initial value of the atom, or asynchronously called later to change it.</span></span><br><span class="line">    setSelf: (</span><br><span class="line">        | T</span><br><span class="line">        | <span class="built_in">DefaultValue</span></span><br><span class="line">        | Promise&lt;T | <span class="built_in">DefaultValue</span>&gt; <span class="comment">// Only allowed for initialization at this time</span></span><br><span class="line">        | <span class="function">(<span class="params">(T | <span class="built_in">DefaultValue</span></span>) =&gt;</span> T | <span class="built_in">DefaultValue</span>),</span><br><span class="line">    ) =&gt; <span class="keyword">void</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">resetSelf</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subscribe to changes in the atom value.</span></span><br><span class="line">    <span class="comment">// The callback is not called due to changes from this effect&#x27;s own setSelf().</span></span><br><span class="line">    onSet: (</span><br><span class="line">        <span class="function">(<span class="params">newValue: T | <span class="built_in">DefaultValue</span>, oldValue: T | <span class="built_in">DefaultValue</span></span>) =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">    ) =&gt; <span class="keyword">void</span>,</span><br><span class="line"></span><br><span class="line">&#125;) =&gt; <span class="keyword">void</span> | <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>; <span class="comment">// Optionally return a cleanup handler</span></span><br></pre></td></tr></table></figure>
<p>Atom effects are attached to <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/atom">atoms</a> via the <code>effects_UNSTABLE</code> option. Each atom can reference an array of these atom effect functions which are called in priority order when the atom is initialized. Atoms are initialized when they are used for the first time within a <code>&lt;RecoilRoot&gt;</code>, but may be re-initialized again if they were unused and cleaned up. The atom effect function may return an optional cleanup handler to manage cleanup side-effects.<br>Atom 副作用是通过Atom的<code>effects_UNSTABLE</code>来添加的。在Atom初始化的时候。每一个Atom都可以引用一个按照优先级调用的atom副作用函数的数组。当第一次应用于<code>&lt;RecoilRoot&gt;</code>时，Atom被初始化。但是也许他们没有被调用或者没有被清除，就会被再次初始化。Atom副作用函数会返回一个可选的处理副作用的函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myState = atom(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MyKey&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">null</span>,</span><br><span class="line">    effects_UNSTABLE: [</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            ...effect <span class="number">1.</span>..</span><br><span class="line">            <span class="keyword">return</span> () =&gt; ...cleanup effect <span class="number">1.</span>..;</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123; ...effect <span class="number">2.</span>.. &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/utils/atomFamily">Atom families</a> also support parameterized or non-parameterized effects:<br>Atom也支持参数化或者无参化：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const myStateFamily = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;MyKey&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: <span class="function"><span class="params">param</span> =&gt;</span> [</span><br><span class="line">        <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ...effect <span class="number">1</span> using param...</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> ...cleanup effect <span class="number">1.</span>..;</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123; ...effect <span class="number">2</span> using param... &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Compared-to-React-Effects-与React副作用相比"><a href="#Compared-to-React-Effects-与React副作用相比" class="headerlink" title="Compared to React Effects 与React副作用相比"></a>Compared to React Effects 与React副作用相比</h4><p>Atom effects could mostly be implemented via React <code>useEffect()</code>. However, the set of atoms are created outside of a React context, and it can be difficult to manage effects from within React components, particularly for dynamically created atoms. They also cannot be used to initialize the initial atom value or be used with server-side rendering. Using atom effects also co-locates the effects with the atom definitions.<br>Atom副作用主要是通过React的<code>useEffect</code>钩子函数来生效。然后atoms是在React上下文之外被创建的。并且在React组建内部管理副作用是非常困难的。特别是动态生成的atoms.这些atoms也常常并不能被用来初始化初始的atom值，或者是用来做服务端渲染。通常atom副作是和定义atom在同一处。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myState = atom(&#123;<span class="attr">key</span>: <span class="string">&#x27;Key&#x27;</span>, <span class="attr">default</span>: <span class="literal">null</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyStateEffect</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [value, setValue] = useRecoilState(myState);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Called when the atom value changes</span></span><br><span class="line">        store.set(value);</span><br><span class="line">        store.onChange(setValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; store.onChange(<span class="literal">null</span>); &#125;; <span class="comment">// Cleanup effect</span></span><br><span class="line">    &#125;, [value]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">MyStateEffect</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            ...</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Compared-to-Snapshots"><a href="#Compared-to-Snapshots" class="headerlink" title="Compared to Snapshots"></a>Compared to Snapshots</h4><p>The <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot#hooks">Snapshot hooks</a> API can also monitor atom state changes and the initializeState prop in <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/RecoilRoot"><RecoilRoot></RecoilRoot></a> can initialize values for initial render. However, these APIs monitor all state changes and can be awkward to manage dynamic atoms, particularly atom families. With atom effects, the side-effect can be defined per-atom alongside the atom definition and multiple policies can be easily composed.<br>Snapshot hooks钩子API可以监听Atom状态的变化并且为初次渲染初始化RecoilRoot组件的初始值。然后，这些API监听所有的状态变化，并且很难管理动态的Atom.尤其是atom系列。有了atom副作用。一些副作用，就可以通过atom提前定义，并且和多种方案组合在一起。</p>
<h4 id="Logging-Example"><a href="#Logging-Example" class="headerlink" title="Logging Example"></a>Logging Example</h4><p>A simple example of using atom effects are for logging a specific atom’s state changes.<br>一个简单的使用atom副作用来记录特定atom状态的变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        <span class="function">(<span class="params">&#123;onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        onSet(<span class="function"><span class="params">newID</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.debug(<span class="string">&quot;Current user ID:&quot;</span>, newID);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="History-Example"><a href="#History-Example" class="headerlink" title="History Example"></a>History Example</h4><p>A more complex example of logging might maintain a history of changes. This example provides an effect which maintains a history queue of state changes with callback handlers that undo that particular change:<br>一个更复杂的例子是用来维护变化的历史记录。此示例提供了一个效果，它使用撤消特定更改的回调处理程序维护状态更改的历史队列：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> history: <span class="built_in">Array</span>&lt;&#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">undo</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">&#125;&gt; = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> historyEffect = <span class="function"><span class="params">name</span> =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    onSet(<span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">        history.push(&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">`<span class="subst">$&#123;name&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.serialize(oldValue)&#125;</span> -&gt; <span class="subst">$&#123;<span class="built_in">JSON</span>.serialize(newValue)&#125;</span>`</span>,</span><br><span class="line">            <span class="attr">undo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                setSelf(oldValue);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfoState = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: <span class="function"><span class="params">userID</span> =&gt;</span> [</span><br><span class="line">        historyEffect(<span class="string">`<span class="subst">$&#123;userID&#125;</span> user info`</span>),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="State-Synchronization-Example-状态同步案例"><a href="#State-Synchronization-Example-状态同步案例" class="headerlink" title="State Synchronization Example 状态同步案例"></a>State Synchronization Example 状态同步案例</h4><p>It can be useful to use atoms as a local cached value of some other state such as a remote database, local storage, &amp;c. You could set the <code>default</code> value of an atom using the <code>default</code> property with a selector to get the store’s value. However, that is only a one-time lookup; if the store’s value changes the atom value will not change. With effects, we can subscribe to the store and update the atom’s value whenever the store changes. Calling <code>setSelf()</code> from the effect will initialize the atom to that value and will be used for the initial render. If the atom is reset, it will revert to the default value, not the initialized value.<br>将atom作为诸如，远程数据库，本地存储等的本地缓存状态是非常有用的。可以通过selector设置默认属性给atom设置默认的值来获取存储的值。然后，这只是一次性的。如果存储中的值发生了变化，而atom的值是不会有变化的。通过副作用，无论何时，我们都可以订阅存储中的值，并且更新atom的值。从副作用中调用<code>setSelf()</code>函数来初始化atom并且初次渲染。如果atom被重置。他将会再次被设置为默认值，而不是初始值。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> syncStorageEffect = <span class="keyword">user</span>ID =&gt; (&#123;<span class="built_in">set</span>Self, trigger&#125;) =&gt; &#123;</span><br><span class="line">    // Initialize atom value <span class="keyword">to</span> the remote storage <span class="keyword">state</span></span><br><span class="line">    if (trigger === &#x27;get&#x27;) &#123; // Avoid expensive initialization</span><br><span class="line">        <span class="built_in">set</span>Self(myRemoteStorage.get(<span class="keyword">user</span>ID)); // C<span class="literal">all</span> synchronously <span class="keyword">to</span> initialize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Subscribe <span class="keyword">to</span> remote storage changes and update the atom value</span><br><span class="line">    myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, <span class="keyword">user</span>Info =&gt; &#123;</span><br><span class="line">        <span class="built_in">set</span>Self(<span class="keyword">user</span>Info); // C<span class="literal">all</span> asynchronously <span class="keyword">to</span> change value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Cleanup remote storage subscription</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, null);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">user</span>InfoState = atomFamily(&#123;</span><br><span class="line">    key: &#x27;UserInfo&#x27;,</span><br><span class="line">    <span class="keyword">default</span>: null,</span><br><span class="line">    effects_UNSTABLE: <span class="keyword">user</span>ID =&gt; [</span><br><span class="line">        historyEffect(`$&#123;<span class="keyword">user</span>ID&#125; <span class="keyword">user</span> info`),</span><br><span class="line">        syncStorageEffect(<span class="keyword">user</span>ID),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Write-Through-Cache-Example"><a href="#Write-Through-Cache-Example" class="headerlink" title="Write-Through Cache Example"></a>Write-Through Cache Example</h4><p>We can also bi-directionally sync atom values with remote storage so changes on the server update the atom value and changes in the local atom are written back to the server. The effect will not call the <code>onSet()</code> handler when changed via that effect’s <code>setSelf()</code> to help avoid feedback loops.<br>我们也可以通过在服务器上的远程存储来更新atom的值也可以重写本地atom的值到服务端的方式来实现双向同步atom的值。当通过副作用的<code>setSelf()</code>来循环调用的时候，副作用不会调用<code>onSet()</code> </p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> syncStorageEffect = <span class="keyword">user</span>ID =&gt; (&#123;<span class="built_in">set</span>Self, <span class="keyword">on</span>Set, trigger&#125;) =&gt; &#123;</span><br><span class="line">    // Initialize atom value <span class="keyword">to</span> the remote storage <span class="keyword">state</span></span><br><span class="line">    if (trigger === &#x27;get&#x27;) &#123; // Avoid expensive initialization</span><br><span class="line">        <span class="built_in">set</span>Self(myRemoteStorage.get(<span class="keyword">user</span>ID)); // C<span class="literal">all</span> synchronously <span class="keyword">to</span> initialize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Subscribe <span class="keyword">to</span> remote storage changes and update the atom value</span><br><span class="line">    myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, <span class="keyword">user</span>Info =&gt; &#123;</span><br><span class="line">        <span class="built_in">set</span>Self(<span class="keyword">user</span>Info); // C<span class="literal">all</span> asynchronously <span class="keyword">to</span> change value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Subscribe <span class="keyword">to</span> local changes and update the server value</span><br><span class="line">    <span class="keyword">on</span>Set(<span class="keyword">user</span>Info =&gt; &#123;</span><br><span class="line">        myRemoteStorage.<span class="built_in">set</span>(<span class="keyword">user</span>ID, <span class="keyword">user</span>Info);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Cleanup remote storage subscription</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, null);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Local-Storage-Persistence-本地存储持久化"><a href="#Local-Storage-Persistence-本地存储持久化" class="headerlink" title="Local Storage Persistence 本地存储持久化"></a>Local Storage Persistence 本地存储持久化</h4><p>Atom effects can be used to persist atom state with <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">browser local storage</a>. Note that the following examples are simplified for illustrative purposes and do not cover all cases.<br>Atom副作用可以通过浏览器本地存储做atom状态的持久化。注意下面的例子，非常简明的说明了这点，但并不能涵盖所有。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> localStorageEffect = <span class="function"><span class="params">key</span> =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> savedValue = <span class="built_in">localStorage</span>.getItem(key)</span><br><span class="line">    <span class="keyword">if</span> (savedValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        setSelf(<span class="built_in">JSON</span>.parse(savedValue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onSet(<span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> DefaultValue) &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        localStorageEffect(<span class="string">&#x27;current_user&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Backward-Compatibility"><a href="#Backward-Compatibility" class="headerlink" title="Backward Compatibility"></a>Backward Compatibility</h4><p>What if you change the format for an atom? Loading a page with the new format with a localStorage based on the old format could case a problem. You could build effects to handle restoring and validating the value in a type safe way:<br>要是你改变了atom的格式怎么办？用新的格式加在基于旧的格式的页面将会有问题。你可以创建新的副作用来重新存储并且验证值是安全的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersistenceOptions&lt;T&gt;: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">restorer</span>: <span class="function">(<span class="params">mixed, DefaultValue</span>) =&gt;</span> T | DefaultValue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localStorageEffect = &lt;T&gt;<span class="function">(<span class="params">options: PersistenceOptions&lt;T&gt;</span>) =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> savedValue = <span class="built_in">localStorage</span>.getItem(options.key)</span><br><span class="line">    <span class="keyword">if</span> (savedValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        setSelf(options.restorer(<span class="built_in">JSON</span>.parse(savedValue), <span class="keyword">new</span> DefaultValue()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onSet(<span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> DefaultValue) &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(options.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(options.key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserIDState = atom&lt;<span class="built_in">number</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        localStorageEffect(&#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;current_user&#x27;</span>,</span><br><span class="line">        <span class="attr">restorer</span>: <span class="function">(<span class="params">value, defaultValue</span>) =&gt;</span></span><br><span class="line">            <span class="comment">// values are currently persisted as numbers</span></span><br><span class="line">            <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">            ? value</span><br><span class="line">            <span class="comment">// if value was previously persisted as a string, parse it to a number</span></span><br><span class="line">            : <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">            ? <span class="built_in">parseInt</span>(value, <span class="number">10</span>)</span><br><span class="line">            <span class="comment">// if type of value is not recognized, then use the atom&#x27;s default value.</span></span><br><span class="line">            : defaultValue</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>What if the key used to persist the value changes? Or what used to be persisted using one key now uses several? Or vice versa? That can also be handled in a type-safe way:<br>要是持久化数据的key变化了怎么办？或者是之前用一个，现在用了多个key怎么办？反之亦然。这也依然可以通过安全的方式来处理：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersistenceOptions&lt;T&gt;: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">restorer</span>: <span class="function">(<span class="params">mixed, DefaultValue, <span class="built_in">Map</span>&lt;<span class="built_in">string</span>, mixed&gt;</span>) =&gt;</span> T | DefaultValue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localStorageEffect = &lt;T&gt;<span class="function">(<span class="params">options: PersistenceOptions&lt;T&gt;</span>) =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> savedValues = parseValuesFromStorage(<span class="built_in">localStorage</span>);</span><br><span class="line">    <span class="keyword">const</span> savedValue = savedValues.get(options.key);</span><br><span class="line">    setSelf(</span><br><span class="line">        options.restorer(savedValue ?? <span class="keyword">new</span> DefaultValue(), <span class="keyword">new</span> DefaultValue(), savedValues),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    onSet(<span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> DefaultValue) &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(options.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(options.key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserIDState = atom&lt;<span class="built_in">number</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        localStorageEffect(&#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;current_user&#x27;</span>,</span><br><span class="line">        <span class="attr">restorer</span>: <span class="function">(<span class="params">value, defaultValue, values</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> oldValue = values.get(<span class="string">&#x27;old_key&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> oldValue === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defaultValue;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Browser-URL-History-Persistence-浏览器URL历史数据持久化"><a href="#Browser-URL-History-Persistence-浏览器URL历史数据持久化" class="headerlink" title="Browser URL History Persistence 浏览器URL历史数据持久化"></a>Browser URL History Persistence 浏览器URL历史数据持久化</h4><p>Atom state can also be persisted and synced with the browser URL history. This can be useful to have state changes update the current URL so it can be saved or shared with others to restore that state. It can also be integrated with the browser history to leverage the browser forward/back buttons. Examples or a library to provide this type of persistence are coming soon…<br>浏览器同样可以用来做浏览器URL历史的数据持久化和数据的同步。这在处理更新当前URL状态是非常有用的，这对于保存或者和与别的Atom共享重新存储状态是非常有用的。它还可以与浏览器历史记录集成，以利用浏览器前进/后退按钮。提供这个功能的案例或者是库正在开发中…</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/guides/data-query"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/guides/data-query/"
    >Recoil指南--Asynchronous Data Queries 异步数据请求</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/guides/data-query/" class="article-date">
  <time datetime="2020-11-09T03:07:13.000Z" itemprop="datePublished">2020-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Recoil provides a way to map state and derived state to React components via a data-flow graph. What’s really powerful is that the functions in the graph can also be asynchronous. This makes it easy to use asynchronous functions in synchronous React component render functions. Recoil allows you to seamlessly mix synchronous and asynchronous functions in your data-flow graph of selectors. Simply return a Promise to a value instead of the value itself from a selector <code>get</code> callback, the interface remains exactly the same. Because these are just selectors, other selectors can also depend on them to further transform the data.<br>Recoil通过数据流图为react提供了俩中state.更为强大的是，函数式的数据流可以是异步的。这使得在同步的react组件中使用异步函数渲染变的非常容易。在Recoil的selector数据流中可以允同步和异步方法混合使用，翻译一个Promise来获取值，而不是Selector的<code>get</code>回调中。接口也是同样的类似，因为这些仅仅是Selector,其他的Selector可以依赖于这些Selector做更多的数据转化。<br>Selectors can be used as one way to incorporate asynchronous data into the Recoil data-flow graph. Please keep in mind that selectors represent “idempotent” functions: For a given set of inputs they should always produce the same results (at least for the lifetime of the application). This is important as selector evaluations may be cached, restarted, or executed multiple times. Because of this, selectors are generally a good way to model read-only DB queries. For mutable data you can use a <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/asynchronous-data-queries#query-refresh">Query Refresh</a> or to synchronize mutable state, persist state, or for other side-effects consider the experimental <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/atom-effects">Atom Effects API</a>.<br>Selector可以被视作为是注册异步数据的一种方式。切记，selector代表了’幂等’函数：对于给定的一组输入，它们应该总是产生相同的结果（至少在应用程序的生命周期内），这一点非常的重要，因为selector的运算可能被缓存，重新计算，或者被执行多次。尽管如此，Selector也是一个读取数据查询非常好的方式。对于那些可变的数据，可以<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/asynchronous-data-queries#query-refresh">刷新请求</a>或者同步可变状态，持久状态或者可以考虑其他的副作用的<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/atom-effects">Atom Api</a>.</p>
<h3 id="Synchronous-Example-同步案例"><a href="#Synchronous-Example-同步案例" class="headerlink" title="Synchronous Example 同步案例"></a>Synchronous Example 同步案例</h3><p>For example, here is a simple synchronous <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/atom">atom</a> and <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/selector">selector</a> to get a user name:<br>例如，下面是一个简单的异步获取用户名的<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/atom">Atom</a>和<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/selector">Selector</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserNameState = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tableOfUsers[get(currentUserIDState)].name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserNameState);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Asynchronous-Example-异步案例"><a href="#Asynchronous-Example-异步案例" class="headerlink" title="Asynchronous Example 异步案例"></a>Asynchronous Example 异步案例</h3><p>If the user names were stored in some database we need to query, all we need to do is return a <code>Promise</code> or use an <code>async</code> function. If any dependencies change, the selector will be re-evaluated and execute a new query. The results are cached, so the query will only execute once per unique input.<br>如果我们需要的用户名是被存储到某个数据库，我们需要做的就是就是通过<code>async</code>方法返回一个<code>Promise</code>.如果一些依赖项发生变化，Selector也会重新计算，或者是重新发起请求。结果会被缓存，所以请求只会被执行一次。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserNameQuery = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: <span class="keyword">async</span> (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;</span><br><span class="line">            userID: <span class="keyword">get</span>(currentUserIDState),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">CurrentUserInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserNameQuery);</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;userName&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The interface of the selector is the same, so the component using this selector doesn’t need to care if it was backed with synchronous atom state, derived selector state, or asynchronous queries!<br>Selector的接口也是一样的，因此组件中用到Selector并不需要关心是否支持同步的Atom 状态，派生Selector状态，或者是异步请求。<br>But, since React render functions are synchronous, what will it render before the promise resolves? Recoil is designed to work with <a target="_blank" rel="noopener" href="https://reactjs.org/docs/concurrent-mode-suspense.html">React Suspense</a> to handle pending data. Wrapping your component with a Suspense boundary will catch any descendants that are still pending and render a fallback UI:<br>但是，由于react的渲染是同步的，那么在promise reslove之前什么会被渲染？Recoil设计使用<a target="_blank" rel="noopener" href="https://reactjs.org/docs/concurrent-mode-suspense.html">react Suspense</a>来处理进行中的数据。将组件以及其后代组件暂时都挂起，返回等待中的UI界面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Error-Handling-错误处理"><a href="#Error-Handling-错误处理" class="headerlink" title="Error Handling 错误处理"></a>Error Handling 错误处理</h3><p>But what if the request has an error? Recoil selectors can also throw errors which will then be thrown if a component tries to use that value. This can be caught with a React <a target="_blank" rel="noopener" href="https://reactjs.org/docs/error-boundaries.html"><ErrorBoundary></ErrorBoundary></a>. For example:<br>一旦请求出现错误怎么办？Recoil Selector可以扔出一个React组件可以捕获的错误。这个错误可以被React的<a target="_blank" rel="noopener" href="https://reactjs.org/docs/error-boundaries.html"><ErrorBoundary></ErrorBoundary></a>组件捕获。案例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserNameQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">async</span> (&#123;get&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;</span><br><span class="line">            <span class="attr">userID</span>: get(currentUserIDState),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserNameQuery);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Queries-with-Parameters-带参请求"><a href="#Queries-with-Parameters-带参请求" class="headerlink" title="Queries with Parameters 带参请求"></a>Queries with Parameters 带参请求</h3><p>Sometimes you want to be able to query based on parameters that aren’t just based on derived state. For example, you may want to query based on the component props. You can do that using the <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/selectorFamily">selectorFamily</a> helper:<br>有时候你可能想要发起一个携带参数带请求的不仅仅依赖于派生状态。例如，你的请求是基于组件的props,那么你可以使用<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/selectorFamily">selectorFamily</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userNameQuery = selectorFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserName&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="params">userID</span> =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;userID&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(userNameQuery(userID));</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;1&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;2&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;3&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-Flow-Graph-数据流"><a href="#Data-Flow-Graph-数据流" class="headerlink" title="Data-Flow Graph 数据流"></a>Data-Flow Graph 数据流</h3><p>Remember, by modeling queries as selectors, we can build a data-flow graph mixing state, derived state, and queries! This graph will automatically update and re-render React components as state is updated.<br>切记，我们可以通过模块查询来创建混合状态，派生状态，以及请求的Selector。这样数据状态一旦更新React的组件会自动更新并重新渲染。<br>The following example will render the current user’s name and a list of their friends. If a friend’s name is clicked on, they will become the current user and the name and list will be automatically updated.<br>下面的例子将会渲染当前的用户名，以及朋友列表，如果某一个朋友的名字被点击。他将会变成当前的用户，并且姓名和裂变会自动更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfoQuery = selectorFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="params">userID</span> =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserInfoQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> get(userInfoQuery(get(currentUserIDState))),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> friendsInfoQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;FriendsInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;friendList&#125; = get(currentUserInfoQuery);</span><br><span class="line">        <span class="keyword">return</span> friendList.map(<span class="function"><span class="params">friendID</span> =&gt;</span> get(userInfoQuery(friendID)));</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUser = useRecoilValue(currentUserInfoQuery);</span><br><span class="line">    <span class="keyword">const</span> friends = useRecoilValue(friendsInfoQuery);</span><br><span class="line">    <span class="keyword">const</span> setCurrentUserID = useSetRecoilState(currentUserIDState);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;currentUser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;friends.map(friend =&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;friend.id&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCurrentUserID(friend.id)&#125;&gt;</span></span><br><span class="line"><span class="xml">                    &#123;friend.name&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                )&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Concurrent-Requests-当前请求"><a href="#Concurrent-Requests-当前请求" class="headerlink" title="Concurrent Requests 当前请求"></a>Concurrent Requests 当前请求</h3><p>If you notice in the above example, the <code>friendsInfoQuery</code> uses a query to get the info for each friend. But, by doing this in a loop they are essentially serialized. If the lookup is fast, maybe that’s ok. If it’s expensive, you can use a concurrency helper such as <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/waitForAll">waitForAll</a> to run them in parallel. This helper accepts both arrays and named objects of dependencies.<br>如果你注意到上面到例子。<code>friendsInfoQuery</code>发起请求来获取每一个朋友的信息。但是通过这样的循环是为了本质上的有序列化。如果查询速度够快，这没什么，要不然就，可以使用例如<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/waitForAll">waitForAll</a>的并发请求来处理。他既可以接受数组，也可以接受对象作为参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> friendsInfoQuery = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;FriendsInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;friendList&#125; = <span class="keyword">get</span>(currentUserInfoQuery);</span><br><span class="line">        <span class="keyword">const</span> friends = <span class="keyword">get</span>(waitForAll(</span><br><span class="line">            friendList.map(friendID =&gt; userInfoQuery(friendID))</span><br><span class="line">        ));</span><br><span class="line">        <span class="keyword">return</span> friends;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>You can use <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/waitForNone">waitForNone</a> to handle incremental updates to the UI with partial data.<br>同样也可以使用<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/waitForNone">waitForNone</a>部分数据来处理UI层面的更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> friendsInfoQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;FriendsInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;friendList&#125; = get(currentUserInfoQuery);</span><br><span class="line">        <span class="keyword">const</span> friendLoadables = get(waitForNone(</span><br><span class="line">                friendList.map(<span class="function"><span class="params">friendID</span> =&gt;</span> userInfoQuery(friendID))</span><br><span class="line">            ));</span><br><span class="line">        <span class="keyword">return</span> friendLoadables</span><br><span class="line">        .filter(<span class="function">(<span class="params">&#123;state&#125;</span>) =&gt;</span> state === <span class="string">&#x27;hasValue&#x27;</span>)</span><br><span class="line">        .map(<span class="function">(<span class="params">&#123;contents&#125;</span>) =&gt;</span> contents);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Pre-Fetching-预请求"><a href="#Pre-Fetching-预请求" class="headerlink" title="Pre-Fetching 预请求"></a>Pre-Fetching 预请求</h3><p>For performance reasons you may wish to kick off fetching before rendering. That way the query can be going while we start rendering. The <a target="_blank" rel="noopener" href="https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early">React docs</a> give some examples. This pattern works with Recoil as well.<br>由于一些其他的原因，你可能希望能在渲染之前开启请求。这当然也是没有问题的。在开始渲染的时候，是可以发起请求的。React文档给了我们例子，这当然也适用于Recoil.<br>Let’s change the above example to initiate a fetch for the next user info as soon as the user clicks the button to change users:<br>我们来修改一下上面的例子，在用户一点击按钮改变用户的时候为下一个用户初始化一个请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUser = useRecoilValue(currentUserInfoQuery);</span><br><span class="line">    <span class="keyword">const</span> friends = useRecoilValue(friendsInfoQuery);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changeUser = useRecoilCallback(<span class="function">(<span class="params">&#123;snapshot, set&#125;</span>) =&gt;</span> <span class="function"><span class="params">userID</span> =&gt;</span> &#123;</span><br><span class="line">        snapshot.getLoadable(userInfoQuery(userID)); <span class="comment">// pre-fetch user info</span></span><br><span class="line">        set(currentUserIDState, userID); <span class="comment">// change current user to start new render</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;currentUser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;friends.map(friend =&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;friend.id&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> changeUser(friend.id)&#125;&gt;</span></span><br><span class="line"><span class="xml">                    &#123;friend.name&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                )&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Async-Queries-Without-React-Suspense-没有React-Suspense的异步请求"><a href="#Async-Queries-Without-React-Suspense-没有React-Suspense的异步请求" class="headerlink" title="Async Queries Without React Suspense 没有React Suspense的异步请求"></a>Async Queries Without React Suspense 没有React Suspense的异步请求</h3><p>It is not necessary to use React Suspense for handling pending asynchronous selectors. You can also use the <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useRecoilValueLoadable">useRecoilValueLoadable()</a> hook to determine the status during rendering:<br>使用React Subspense来处理进行中的异步Selector，并不是必须的。在渲染期间，也可以使用<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useRecoilValueLoadable">useRecoilValueLoadable()</a>钩子函数来处理状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;userID&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userNameLoadable = useRecoilValueLoadable(userNameQuery(userID));</span><br><span class="line">    <span class="keyword">switch</span> (userNameLoadable.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;hasValue&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userNameLoadable.contents&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;loading&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;hasError&#x27;</span>:</span><br><span class="line">            <span class="keyword">throw</span> userNameLoadable.contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Query-Refresh请求刷新"><a href="#Query-Refresh请求刷新" class="headerlink" title="Query Refresh请求刷新"></a>Query Refresh请求刷新</h3><p>When using selectors to model data queries, it’s important to remember that selector evaluation should always provide a consistent value for a given state. Selectors represent state derived from other atom and selector states. Thus, selector evaluation functions should be idempotent for a given input, as it may be cached or executed multiple times. Practically, that means a single selector should not be used for a query where you expect the results to vary during the application’s lifetime.<br>当使用Selector来发起数据请求的时候，切记，selector运算总是会提供和给定的状态一致的值。Selector代表状态派生到其他的Atom或者是selector状态。因此，对于给定的输入，Selector函数应该是幂等的。因为他可能会被缓存，或者是执行多次。实际上，这意味着一个Selector在整个应用的生命周期中不应该被应用于你希望得到的结果总是变化的请求。</p>
<p>There are a few patterns you can use for working with mutable data:<br>下面是一些应用于修改数据的模式：</p>
<h5 id="Use-a-Request-ID-用ID请求"><a href="#Use-a-Request-ID-用ID请求" class="headerlink" title="Use a Request ID 用ID请求"></a>Use a Request ID 用ID请求</h5><p>Selector evaluation should provide a consistent value for a given state based on input (dependent state or family parameters). So, you could add a request ID as either a family parameter or a dependency to your query. For example:<br>Selector运算需要为state提供基于输入（独立的状态或者是一组参数）一致的值，所以，需要为请求添加一个请求的ID，要不是参数，要不是依赖，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfoQueryRequestIDState = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfoQueryRequestID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfoQuery = selectorFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="params">userID</span> =&gt;</span> <span class="keyword">async</span> (&#123;get&#125;) =&gt; &#123;</span><br><span class="line">        get(userInfoQueryRequestIDState(userID)); <span class="comment">// Add request ID as a dependency</span></span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRefreshUserInfo</span>(<span class="params">userID</span>) </span>&#123;</span><br><span class="line">    setUserInfoQueryRequestID = useSetRecoilState(userInfoQueryRequestIDState(userID));</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setUserInfoQueryRequestID(<span class="function"><span class="params">requestID</span> =&gt;</span> requestID++);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUserID = useRecoilValue(currentUserIDState);</span><br><span class="line">    <span class="keyword">const</span> currentUserInfo = userRecoilValue(userInfoQuery(currentUserID));</span><br><span class="line">    <span class="keyword">const</span> refreshUserInfo = useRefreshUserInfo(currentUserID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;currentUser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;refreshUserInfo&#125;</span>&gt;</span>Refresh<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Use-an-Atom-Atom使用"><a href="#Use-an-Atom-Atom使用" class="headerlink" title="Use an Atom Atom使用"></a>Use an Atom Atom使用</h5><p>Another option is to use an atom, instead of a selector, to model the query results. You can imperatively update the atom state with the new query results based on your refresh policy.<br>另外一个方法就是使用Atom,而不是Selector来处理请求结果。可以根据刷新策略使用新的查询结果强制更新atom状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfoState = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="function"><span class="params">userID</span> =&gt;</span> fetch(userInfoURL(userID)),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React component to refresh query</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RefreshUserInfo</span>(<span class="params">&#123;userID&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> refreshUserInfo = useRecoilCallback(<span class="function">(<span class="params">&#123;set&#125;</span>) =&gt;</span> <span class="keyword">async</span> id =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> userInfo = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        set(userInfoState(userID), userInfo);</span><br><span class="line">    &#125;, [userID]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refresh user info every second</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> intervalID = <span class="built_in">setInterval</span>(refreshUserInfo, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(intervalID);</span><br><span class="line">    &#125;, [refreshUserInfo]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One downside to this approach is that atoms do not currently support accepting a Promise as the new value in order to automatically take advantage of React Suspense while the query refresh is pending, if that is your desired behavior. However, you could store an object which manually encodes the loading status as well as the results if desired.<br>这种方法的一个缺点是atoms当前不支持接受Promise作为新值，以便在查询刷新挂起时自动利用React-Suspense（如果这是您想要的行为）。但是，如果需要，您可以存储一个手动编码加载状态和结果的对象。</p>
<p>Also consider <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/atom-effects">atom effects</a> for query synchronization of atoms.<br>同样需求考虑<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/atom-effects">Atom作用</a>对atom同步请求的影响。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/tutorial/selectors"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/tutorial/selectors/"
    >Recoil基础--Selector纯函数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/tutorial/selectors/" class="article-date">
  <time datetime="2020-11-04T05:51:18.000Z" itemprop="datePublished">2020-11-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Selectors-纯函数"><a href="#Selectors-纯函数" class="headerlink" title="Selectors 纯函数"></a>Selectors 纯函数</h1><p>A <strong>selector</strong> represents a piece of <strong>derived state</strong>. You can think of derived state as the output of passing state to a pure function that modifies the given state in some way.<br><strong>selecttor</strong>就是一种派生状态。你可以认为<strong>派生状态</strong>是一种高阶函数的返回值。<br>Derived state is a powerful concept because it lets us build dynamic data that depends on other data. In the context of our todo list application, the following are considered derived state:<br>派生状态是一个非常有意义的概念，因为他们能让我们创建依赖于其他数据的动态数据。在我们todo list的例子中，下面的数据被视作为派生状态：</p>
<ul>
<li><strong>Filtered todo list</strong>: derived from the complete todo list by creating a new list that has certain items filtered out based on some criteria (such as filtering out items that are already completed).<br>过滤todo List：</li>
<li><strong>Todo list statistics</strong>: derived from the complete todo list by calculating useful attributes of the list, such as the total number of items in the list, the number of completed items, and the percentage of items that are completed.<br>To implement a filtered todo list, we need to choose a set of filter criteria whose value can be saved in an atom. The filter options we’ll use are: “Show All”, “Show Completed”, and “Show Uncompleted”. The default value will be “Show All”:<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoListFilterState = atom(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;todoListFilterState&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">&#x27;Show All&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
Using <code>todoListFilterState</code> and <code>todoListState</code>, we can build a <code>filteredTodoListState</code> selector which derives a filtered list:<br>我们可以使用<code>todoListFilterState</code>和<code>todoListState</code>来创建一个<code>filteredTodoListState</code>Slector来获取过滤的列表：<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filteredTodoListState = selector(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;filteredTodoListState&#x27;</span>,</span><br><span class="line">    <span class="built_in">get</span>: (&#123;<span class="built_in">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">filter</span> = <span class="built_in">get</span>(todoListFilterState);</span><br><span class="line">        <span class="keyword">const</span> list = <span class="built_in">get</span>(todoListState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">filter</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Show Completed&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> list.<span class="built_in">filter</span>((item) =&gt; item.isComplete);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Show Uncompleted&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> list.<span class="built_in">filter</span>((item) =&gt; !item.isComplete);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
The <code>filteredTodoListState</code> internally keeps track of two dependencies: <code>todoListFilterState</code> and <code>todoListState</code> so that it re-runs if either of those change.<br><code>filteredTodoListState</code>与<code>todoListFilterState</code>和<code>todoListState</code>有密切关系，只要有其中一个发生变化，就会导致re-runs.<blockquote>
<p>From a component’s point of view, selectors can be read using the same hooks that are used to read atoms. However it’s important to note that certain hooks only work with writable state (i.e useRecoilState()). All atoms are writable state, but only some selectors are considered writable state (selectors that have both a get and set property). See the Core Concepts page for more information on this topic.</p>
</blockquote>
</li>
</ul>
<p>Displaying our filtered todoList is as simple as changing one line in the <code>TodoList</code> component:<br>展示过滤的todoList列表非常的简单，只需要在<code>TodoList</code>组件中修改一行代码就好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// changed from todoListState to filteredTodoListState</span></span><br><span class="line">    <span class="keyword">const</span> todoList = useRecoilValue(filteredTodoListState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TodoListStats</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TodoListFilters</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TodoItemCreator</span> /&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        &#123;todoList.map((todoItem) =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">TodoItem</span> <span class="attr">item</span>=<span class="string">&#123;todoItem&#125;</span> <span class="attr">key</span>=<span class="string">&#123;todoItem.id&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note the UI is showing every todo because <code>todoListFilterState</code> was given a default value of “Show All”. In order to change the filter, we need to implement the <code>TodoListFilters</code> component:<br>注意，从UI层面来看，展示了所有的item,因为<code>todoListFilterState</code>被赋予了展示所有的默认值。为了过滤，我们需要一个<code>TodoListFilters</code>组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoListFilters</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [filter, setFilter] = useRecoilState(todoListFilterState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> updateFilter = <span class="function">(<span class="params">&#123;target: &#123;value&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        setFilter(value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        Filter:</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">&#123;filter&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;updateFilter&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Show All&quot;</span>&gt;</span>All<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Show Completed&quot;</span>&gt;</span>Completed<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Show Uncompleted&quot;</span>&gt;</span>Uncompleted<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With a few lines of code we’ve managed to implement filtering! We’ll use the same concepts to implement the <code>TodoListStats</code> component.<br>写了这么几行代码，我们已经可以让过滤生效了。我们可以用同样的概念使<code>TodoListStats</code>组件生效。<br>We want to display the following stats:<br>我们希望展示以下的统计：</p>
<ul>
<li>Total number of todo items items的总数</li>
<li>Total number of completed items 完成状态的item总数</li>
<li>Total number of uncompleted items 没有完成状态的item的总数</li>
<li>Percentage of items completed 完成状态的item的占比<br>While we could create a selector for each of the stats, an easier approach would be to create one selector that returns an object containing the data we need. We’ll call this selector <code>todoListStatsState</code>:<br>这时我们可以为每一个统计创建一个Selector.一种最简单的方式就是创建一个selectorr然后返回一个包含我们需要的数据的对象。我们将把这个Selector叫做<code>todoListStatsState</code>:<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoListStatsState = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;todoListStatsState&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> todoList = <span class="keyword">get</span>(todoListState);</span><br><span class="line">        <span class="keyword">const</span> totalNum = todoList.length;</span><br><span class="line">        <span class="keyword">const</span> totalCompletedNum = todoList.filter((item) =&gt; item.isComplete).length;</span><br><span class="line">        <span class="keyword">const</span> totalUncompletedNum = totalNum - totalCompletedNum;</span><br><span class="line">        <span class="keyword">const</span> percentCompleted = totalNum === <span class="number">0</span> ? <span class="number">0</span> : totalCompletedNum / totalNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            totalNum,</span><br><span class="line">            totalCompletedNum,</span><br><span class="line">            totalUncompletedNum,</span><br><span class="line">            percentCompleted,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
To read the value of <code>todoListStatsState</code>, we use <code>useRecoilValue()</code> once again:<br>再用<code>useRecoilValue()</code>函数来读取<code>todoListStatsState</code>的值：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoListStats</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        totalNum,</span><br><span class="line">        totalCompletedNum,</span><br><span class="line">        totalUncompletedNum,</span><br><span class="line">        percentCompleted,</span><br><span class="line">    &#125; = useRecoilValue(todoListStatsState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> formattedPercentCompleted = <span class="built_in">Math</span>.round(percentCompleted * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Total items: &#123;totalNum&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Items completed: &#123;totalCompletedNum&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Items not completed: &#123;totalUncompletedNum&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Percent completed: &#123;formattedPercentCompleted&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
To summarize, we’ve created a todo list app that meets all of our requirements:<br>总结，我们已经创建了满足我们以下需求的todo list应用：</li>
<li>Add todo items 增加item</li>
<li>Edit todo items 编辑item</li>
<li>Delete todo items 删除item</li>
<li>Filter todo items 过滤item</li>
<li>Display useful stats 展示统计</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2022
        <i class="ri-heart-fill heart_icon"></i> Lee
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Lee前端技术栈"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>