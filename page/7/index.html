<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="前端技术栈 前端技术 前端博客 JavaScript HTML5 CSS3 VUE React Angular node Deno typeSctipt webpack wechat flutter recoil" />
       
      <meta name="description" content="敲着代码，记着BUG，通过博客的方式，记录下工作中的点点滴滴。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Lee前端技术栈</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Lee前端技术栈" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Lee前端技术栈</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['读万卷书，行万里路，代码运行了那么久，却总觉得不是最优秀。。。', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/vultr.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-recoil/api/recoil-state/atom"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/api/recoil-state/atom/"
    >Recoil API手册--atom(options)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/api/recoil-state/atom/" class="article-date">
  <time datetime="2021-02-22T01:03:09.000Z" itemprop="datePublished">2021-02-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>An atom represents state in Recoil. The <code>atom()</code> function returns a writeable <code>RecoilState</code> object.<br>atom代表了Recoil中的状态，<code>atom()</code>返回了一个可读写的Recoil状态对象。</p>
<hr>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> atom<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">   <span class="built_in"> key</span>:<span class="built_in"> string</span>,</span></span><br><span class="line"><span class="xquery">    default: T | Promise<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span> | RecoilValue</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>,</span></span></span><br><span class="line"><span class="xml"><span class="xquery">    effects_UNSTABLE?: $ReadOnlyArray&lt;AtomEffect</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>&gt;,</span></span></span><br><span class="line"><span class="xml"><span class="xquery">    dangerouslyAllowMutability?: boolean,</span></span></span><br><span class="line"><span class="xml"><span class="xquery">&#125;</span></span><span class="xml">): RecoilState</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>key</code> - A unique string used to identify the atom internally. This string should be unique with respect to other atoms and selectors in the entire application.<br><code>key</code>字段是一个用来定义内部atom的唯一的字符串，这个是字符串必须是唯一的，用来区分应用程序中所有的atoms和selector.</li>
<li><code>default</code> - The initial value of the atom or a Promise or another atom or selector representing a value of the same type.<br><code>default</code>字段用来初始化一个atom或者Promise或者另一个atom或者是selector具有相同类型的初始值。</li>
<li><code>effects_UNSTABLE</code> - An optional array of Atom Effects for the atom.<br><code>effects_UNSTABLE</code>字段一个可选的atom副作用数组。</li>
<li><code>dangerouslyAllowMutability</code> - In some cases it may be desireable allow mutating of objects stored in atoms that don’t represent state changes. Use this option to override freezing objects in development mode.<br><code>dangerouslyAllowMutability</code>在某些情况下，他是用来描述允许atoms存储的对象发生转化，但是并不代表状态会发生变化。可以用这个选项在开发环境来冻结对象。</li>
</ul>
<hr>
<p>Recoil manages atom state changes to know when to notify components subscribing to that atom to re-render, so you should use the hooks listed below to change atom state. If an object stored in an atom was mutated directly it may bypass this and cause state changes without properly notifying subscribing components. To help detect bugs Recoil will freeze objects stored in atoms in development mode.</p>
<p>Recoil管理atom状态是通过通知组建订阅atom状态实现重新渲染，所以，应该使用下面的hooks函数来使得atom状态发生变化。如果一个存储在atom中的对象被直接改变，那就会引起组建没有被通知订阅而atom状态发生变化。为了解决这个bug，Recoil会在开发环境冻结存储在atom中的对象。</p>
<p>Most often, you’ll use the following hooks to interact with atoms:<br>通常情况下，需要使用下列的hooks函数来使得atoms发生变化。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilState">useRecoilState()</a>: Use this hook when you intend on both reading and writing to the atom. This hook subscribes the component to the atom.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilState">useRecoilState()</a>:当你要读写atom的时候使用这个钩子函数，这个钩子函数会订阅组建的atom.</li>
<li><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilValue">useRecoilValue()</a>: Use this hook when you intend on only reading the atom. This hook subscribes the component to the atom.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilValue">useRecoilValue()</a>:当只是读取atom的时候。使用这个钩子函数，这个钩子函数会订阅组建的atom.</li>
<li><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useSetRecoilState">useSetRecoilState()</a>: Use this hook when you intend on only writing to the atom.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useSetRecoilState">useSetRecoilState()</a>:当只是操作atom的时候。使用这个钩子函数。</li>
<li><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useResetRecoilState">useResetRecoilState()</a>: Use this hook to reset an atom to its default value.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useResetRecoilState">useResetRecoilState()</a>:当重置atom的默认值的时候，使用这个钩子函数。<br>For rare cases where you need to read an atom’s value without subscribing to the component, see <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a>.</li>
</ul>
<p>对于极少数需要读取atom的值，而不需要订阅组建，可以参考<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a>。</p>
<p>You can initialize an atom either with a static value or with a <code>Promise</code> or a <code>RecoilValue</code> representing a value of the same type. Because the Promise may be pending or the default selector may be asynchronous it means that the atom value may also be pending or throw an error when reading. Note that you cannot currently assign a <code>Promise</code> when setting an atom. Please use <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/selector">selectors</a> for async functions.</p>
<p>可以用通过一个具有共同类型的静态值或者是一个<code>Promise</code>或者是一个<code>RecoilValue</code>来初始化atom.因为Promise也许是进行中，或者默认的selector会是异步的，这就会使得atom的状态也是处于进行中或者是抛出一个错误。所以，当是这atom的时候，并不能将当前标注为<code>Promise</code>,请使用selector异步函数。</p>
<p>Atoms cannot be used to store <code>Promise&#39;s</code> or <code>RecoilValue&#39;s</code> directly, but they may be wrapped in an object. Note that <code>Promise&#39;s</code> may be mutable. Atoms can be set to a <code>function</code>, as long as it is pure, but to do so you may need to use the updater form of setters. (e.g. <code>set(myAtom, () =&gt; myFunc);</code>).</p>
<p>Atoms不能被直接才存储为<code>Promise</code>或者是<code>RecoilValue&#39;s</code>, 但是他们可以被包裹为一个对象。注意<code>Promise</code>可能被改变。Atoms可以被设置为是个函数，只要纯净，就可以使用setters的更新方式。(e.g. <code>set(myAtom, () =&gt; myFunc);</code>).</p>
<p>案例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom, useRecoilState&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;myCounter&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useRecoilState(counter);</span><br><span class="line">    <span class="keyword">const</span> incrementByOne = <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            Count: &#123;count&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;incrementByOne&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-algorithm/1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/algorithm/1/"
    >LeetCode算法--求俩数之和</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/algorithm/1/" class="article-date">
  <time datetime="2021-01-19T03:21:19.000Z" itemprop="datePublished">2021-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/algorithm/">algorithm</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>题目：给定一个数组nums和一个目标值target,从数组中找到俩个元素的和等于目标值target，并返回这俩个元素的位置。<br>思路一：暴力算法，将数组中的俩个元素相加，如果等于目标值target，那么返回其位置。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let <span class="function"><span class="keyword">fun</span> = <span class="params">(nums, target)</span></span> =&gt; &#123;</span><br><span class="line">    let result = []</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (let j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                result.push(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>1,这里需要注意的是循环的边界值，i &lt; nums.length - 1, j &lt; nums.length<br>2,因为做了俩层循环，所以时间复杂度是O(n<sup>2</sup>),声明了三个变量，空间复杂度是O(n)</p>
<p>思路二：由于上面的暴力算法时间复杂度比较高，所以我们可以再时间复杂度上做一点优化，我们可不可以将时间复杂度降低到O(N)呢？当然是可以的，对于每一个 nums[ i ]，我们首先查询哈希表中是否存在 target - nums[ i ]，然后将 nums[ i ] 插入到哈希表中，即可保证不会让 nums[ i ] 和自己匹配。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> fun = (nums, target) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> result = []</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">map</span> = <span class="built_in">new</span> Map()</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">map</span>.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">length</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">let</span> item = target - nums[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.has(item) &amp;&amp; <span class="built_in">map</span>.<span class="built_in">get</span>(item) !== i) &#123;</span><br><span class="line">            result.<span class="built_in">push</span>(i);</span><br><span class="line">            result.<span class="built_in">push</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(item))</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>我们首先创建了一个map结构，用来保存数组中的元素和位置，作为哈希表。然后按照思路二来实现。遍历一次，也降低了时间复杂度。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/api/recoilroot"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/api/recoilroot/"
    >Recoil API手册--&lt;RecoilRoot /&gt;</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/api/recoilroot/" class="article-date">
  <time datetime="2021-01-11T02:25:18.000Z" itemprop="datePublished">2021-01-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="lt-RecoilRoot-…props-gt"><a href="#lt-RecoilRoot-…props-gt" class="headerlink" title="&lt;RecoilRoot …props /&gt;"></a>&lt;RecoilRoot …props /&gt;</h4><p>Provides the context in which atoms have values. Must be an ancestor of any component that uses any Recoil hooks. Multiple roots may co-exist; atoms will have distinct values within each root. If they are nested, the innermost root will completely mask any outer roots.<br>为atoms提供上下文。必须是所有是使用Recoil hooks组建的根组建，多个根组建也许可以共存，atoms需要对不同的根组建进行区别。如果它们是嵌套的，最里面的根将完全掩盖任何外部根。<br>Props:<br>    <code>initializeState?: (MutableSnapshot =&gt; void)</code><br>    An optional function that takes a <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/Snapshot#transforming-snapshots">MutableSnapshot to</a> <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/Snapshot#state-initialization">initialize</a> the <RecoilRoot> atom state. This sets up the state for the initial render and is not intended for subsequent state changes or async initialization. Use hooks such as <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useSetRecoilState">useSetRecoilState()</a> or <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a> for async state changes.<br>    通过一个可选函数来初始化根RecoilRoot组建的atom状态。这将设置初始呈现的状态，而不是用于后续状态更改或异步初始化。利用hooks函数如useSetRecoilState()或者useRecoilCallback()实现异步更新状态。</RecoilRoot></p>
<p><code>&lt;RecoilRoot&gt;&#39;s</code> represent independent providers/stores of atom state. Note that caches, such as selector caches, may be shared across roots. Selector evaluations must be idempotent except for caching or logging, so this should not be a problem, but may be observable or may cause redundant queries to be cached across roots.<br><RecoilRoot>组建是atom状态的独立的Provider/store.请注意，缓存（如选择器缓存）可以跨根共享。选择器求值必须是幂等的（除了缓存或日志记录），所以这应该不是问题，但可能是可观察的，或者可能导致在根之间缓存冗余查询。</RecoilRoot></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;RecoilRoot&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ComponentThatUsesRecoil</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/guides/dev-tools"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/guides/dev-tools/"
    >Recoil指南--Dev Tools 开发工具</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/guides/dev-tools/" class="article-date">
  <time datetime="2020-11-28T03:07:13.000Z" itemprop="datePublished">2020-11-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Dev-Tools-开发工具"><a href="#Dev-Tools-开发工具" class="headerlink" title="Dev Tools 开发工具"></a>Dev Tools 开发工具</h4><p>Recoil has functionality to allow you to observe and update state changes.<br>Recoil可以允许您监听并且更新状态变化。</p>
<hr>
<h4 id="IMPORTANT-NOTE-重点关注"><a href="#IMPORTANT-NOTE-重点关注" class="headerlink" title="IMPORTANT NOTE 重点关注"></a>IMPORTANT NOTE 重点关注</h4><p>This API is currently under development and will change. Please stay tuned…<br>这个API当前还在开发中，并且会有变化，请稍等…</p>
<hr>
<h4 id="Observing-All-State-Changes-监听所有的状态变化"><a href="#Observing-All-State-Changes-监听所有的状态变化" class="headerlink" title="Observing All State Changes 监听所有的状态变化"></a>Observing All State Changes 监听所有的状态变化</h4><p>You can use a hook such as <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilSnapshot">useRecoilSnapshot()</a> or <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilTransactionObserver">useRecoilTransactionObserver_UNSTABLE()</a> to subscribe to state changes and obtain a <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a> of the new state.<br>可以使用诸如<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilSnapshot">useRecoilSnapshot()</a>或者<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilTransactionObserver">useRecoilTransactionObserver_UNSTABLE()</a>的钩子函数来订阅状态的变化，或者是添加一个<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a>的新状态。</p>
<p>Once you have a <code>Snapshot</code>, you can use methods such as <code>getLoadable()</code>, <code>getPromise()</code>, and <code>getInfo()</code> to inspect the state and use <code>getNodes()</code> to iterate over the set of known atoms.<br>一旦使用Snapshot,你就可以用类似于<code>getLoadable()</code>, <code>getPromise()</code>, 和 <code>getInfo()</code>方法去检查state,用<code>getNodes()</code>方法来迭代atoms.</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> DebugObserver(): React.Node &#123;</span><br><span class="line">    const<span class="built_in"> snapshot</span> = useRecoilSnapshot();</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        console.debug(<span class="string">&#x27;The following atoms were modified:&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (const <span class="type">node</span> <span class="keyword">of</span><span class="built_in"> snapshot</span>.getNodes(&#123;modified:<span class="built_in"> true</span>&#125;)) &#123;</span><br><span class="line">        console.debug(<span class="type">node</span><span class="built_in">.key</span>,<span class="built_in"> snapshot</span>.getLoadable(<span class="type">node</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="built_in">[snapshot</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">DebugObserver</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            ...</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Observing-State-Changes-On-Demand-按需监听state的变化"><a href="#Observing-State-Changes-On-Demand-按需监听state的变化" class="headerlink" title="Observing State Changes On-Demand 按需监听state的变化"></a>Observing State Changes On-Demand 按需监听state的变化</h4><p>Or, you can use the <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a> hook to obtain a <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a> on-demand.<br>可以使用使用<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a>hook函数来获取按需<a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DebugButton</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> onClick = useRecoilCallback(<span class="function">(<span class="params">&#123;snapshot&#125;</span>) =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.debug(<span class="string">&#x27;Atom values:&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> snapshot.getNodes()) &#123;</span><br><span class="line">            <span class="keyword">const</span> value = <span class="keyword">await</span> snapshot.getPromise(node);</span><br><span class="line">            <span class="built_in">console</span>.debug(node.key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>Dump State<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Time-Travel"><a href="#Time-Travel" class="headerlink" title="Time Travel"></a>Time Travel</h4><p>The <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useGotoRecoilSnapshot">useGotoRecoilSnapshot()</a> hook can be used to update the entire Recoil state to match the provided <code>Snapshot</code>. This example maintains a history of state changes with the ability to go back and restore previous global state.<br><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/useGotoRecoilSnapshot">useGotoRecoilSnapshot()</a> 钩子函数可以用来更新全部的Recoil状态来匹配所提供的<code>Snapshot</code>,此示例维护了状态更改的历史，并能够返回和恢复以前的全局状态。<br><code>Snapshot&#39;s</code> also provide a <code>getID()</code> method. That can be used, for example, to help determine if you are reverting to a previous known state to avoid updating your snapshot history.<br>Snapshot同样提供了<code>getID()</code>的方法。例如，可以使用它来帮助确定您是否正在恢复到以前的已知状态，以避免更新快照历史记录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeTravelObserver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [snapshots, setSnapshots] = useState([]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> snapshot = useRecoilSnapshot();</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (snapshots.every(<span class="function"><span class="params">s</span> =&gt;</span> s.getID() !== snapshot.getID())) &#123;</span><br><span class="line">            setSnapshots([...snapshots, snapshot]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [snapshot]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gotoSnapshot = useGotoRecoilSnapshot();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;snapshots.map((snapshot, i) =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                Snapshot &#123;i&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> gotoSnapshot(snapshot)&#125;&gt;</span></span><br><span class="line"><span class="xml">                    Restore</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/guides/testing"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/guides/testing/"
    >Recoil指南--Testing 测试</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/guides/testing/" class="article-date">
  <time datetime="2020-11-26T08:07:13.000Z" itemprop="datePublished">2020-11-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Testing-Recoil-Selectors-outside-of-React-React之外测试Recoil的Selectors"><a href="#Testing-Recoil-Selectors-outside-of-React-React之外测试Recoil的Selectors" class="headerlink" title="Testing Recoil Selectors outside of React React之外测试Recoil的Selectors"></a>Testing Recoil Selectors outside of React React之外测试Recoil的Selectors</h4><p>It can be useful to manipulate and evaluate Recoil selectors outside of a React context for testing. This can be done by working with a Recoil <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a>. You can build a fresh snapshot using <code>snapshot_UNSTABLE()</code> and then use that <code>Snapshot</code> to evaluate selectors for testing.<br>脱离React来测试Recoil的Selectors是非常有用的。这可以通过Recolid的Snapshot来实现。可以通过<code>snapshot_UNSTABLE()</code>函数来创建一个全新的snapshot，然后用<code>Snapshot</code>来实现selector的测试。</p>
<h4 id="Example-Jest-unit-testing-selectors-Selectors的单元测试"><a href="#Example-Jest-unit-testing-selectors-Selectors的单元测试" class="headerlink" title="Example: Jest unit testing selectors Selectors的单元测试"></a>Example: Jest unit testing selectors Selectors的单元测试</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberState = atom(&#123;key: <span class="string">&#x27;Number&#x27;</span>, <span class="keyword">default</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multipliedState = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MultipliedNumber&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; <span class="keyword">get</span>(numberState) * <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;Test multipliedState&#x27;</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> initialSnapshot = snapshot_UNSTABLE();</span><br><span class="line">    expect(mySnapshot.getLoadable(multipliedState).valueOrThrow()).toBe(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> testSnapshot = snapshot_UNSTABLE((&#123;<span class="keyword">set</span>&#125;) =&gt; <span class="keyword">set</span>(numberState, <span class="number">1</span>));</span><br><span class="line">    expect(mySnapshot.getLoadable(multipliedState).valueOrThrow()).toBe(<span class="number">100</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-coding/1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/coding/1/"
    >手动实现Javascript中new操作符</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/coding/1/" class="article-date">
  <time datetime="2020-11-10T08:31:19.000Z" itemprop="datePublished">2020-11-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">coding</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>想要实现new操作符，首先要知道new操作符都干了什么事儿？</p>
<ul>
<li>创建了一个空，将this指向这个对象</li>
<li>将创建的空对象的<code>__proto__</code>属性继承自构造函数的<code>prototype</code>属性，也就是说是继承构造函数的原型对象上的方法和属性</li>
<li>调用构造函数，将构造函数中的this替换为空对象的this，继承构造函数中的属性</li>
<li>返回函数内部的这个新对象</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function _new (<span class="function"><span class="keyword">fun</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> function () &#123;</span><br><span class="line">        let obj = &#123;&#125;</span><br><span class="line">        obj.__proto__ = <span class="keyword">fun</span>.prototype</span><br><span class="line">        <span class="keyword">fun</span>.call(obj, ...arguments)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person <span class="built_in">(name</span>, age) &#123;</span><br><span class="line">    this<span class="built_in">.name</span> =<span class="built_in"> name</span></span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = _new(Person)(<span class="string">&#x27;小明&#x27;</span>, <span class="number">3</span>) //=&gt; <span class="built_in">&#123;name</span>: <span class="string">&#x27;小明&#x27;</span>, age: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/coding/" rel="tag">coding</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/guides/atom-effects"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/guides/atom-effects/"
    >Recoil指南--Atom Effects Atom副作用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/guides/atom-effects/" class="article-date">
  <time datetime="2020-11-09T10:07:03.000Z" itemprop="datePublished">2020-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="Atom-Effects-Atom副作用"><a href="#Atom-Effects-Atom副作用" class="headerlink" title="Atom Effects Atom副作用"></a>Atom Effects Atom副作用</h3><p>Atom Effects are a new experimental API for managing side-effects and initializing Recoil atoms. They have a variety of useful applications such as state persistence, state synchronization, managing history, logging, &amp;c. They are defined as part of the atom definition, so each atom can specify and compose their own policies. This API is still evolving, and thus marked as <code>_UNSTABLE</code>.<br>Atom Effects是为了管理副作用和初始化Recoil Atom的实验性的API。它会有多种应用，例如：状态持久化，同步状态，历史管理，日志等。这些都被定义为Atom最初定义的一部分。所以每个部分都可以有指定或者组合自己的策略。这些API还在开发中，所以暂时就把它称作<code>_UNSTABLE</code>版本吧。</p>
<hr>
<h3 id="IMPORTANT-NOTE-重要提示"><a href="#IMPORTANT-NOTE-重要提示" class="headerlink" title="IMPORTANT NOTE 重要提示"></a>IMPORTANT NOTE 重要提示</h3><p>This API is currently under development and will change. Please stay tuned…<br>这些API还在开发中。并且会有变化，所以再等等。。。。</p>
<hr>
<p>An atom effect is a function with the following definition.<br>Atom副作用是下面定义的函数：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type AtomEffect&lt;T&gt; = (&#123;</span><br><span class="line">    <span class="attr">node</span>: RecoilState&lt;T&gt;, <span class="comment">// A reference to the atom itself</span></span><br><span class="line">    trigger: <span class="string">&#x27;get&#x27;</span> | <span class="string">&#x27;set&#x27;</span>, <span class="comment">// The action which triggered initialization of the atom</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callbacks to set or reset the value of the atom.</span></span><br><span class="line">    <span class="comment">// This can be called from the atom effect function directly to initialize the</span></span><br><span class="line">    <span class="comment">// initial value of the atom, or asynchronously called later to change it.</span></span><br><span class="line">    setSelf: (</span><br><span class="line">        | T</span><br><span class="line">        | <span class="built_in">DefaultValue</span></span><br><span class="line">        | Promise&lt;T | <span class="built_in">DefaultValue</span>&gt; <span class="comment">// Only allowed for initialization at this time</span></span><br><span class="line">        | <span class="function">(<span class="params">(T | <span class="built_in">DefaultValue</span></span>) =&gt;</span> T | <span class="built_in">DefaultValue</span>),</span><br><span class="line">    ) =&gt; <span class="keyword">void</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">resetSelf</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subscribe to changes in the atom value.</span></span><br><span class="line">    <span class="comment">// The callback is not called due to changes from this effect&#x27;s own setSelf().</span></span><br><span class="line">    onSet: (</span><br><span class="line">        <span class="function">(<span class="params">newValue: T | <span class="built_in">DefaultValue</span>, oldValue: T | <span class="built_in">DefaultValue</span></span>) =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">    ) =&gt; <span class="keyword">void</span>,</span><br><span class="line"></span><br><span class="line">&#125;) =&gt; <span class="keyword">void</span> | <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>; <span class="comment">// Optionally return a cleanup handler</span></span><br></pre></td></tr></table></figure>
<p>Atom effects are attached to <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/atom">atoms</a> via the <code>effects_UNSTABLE</code> option. Each atom can reference an array of these atom effect functions which are called in priority order when the atom is initialized. Atoms are initialized when they are used for the first time within a <code>&lt;RecoilRoot&gt;</code>, but may be re-initialized again if they were unused and cleaned up. The atom effect function may return an optional cleanup handler to manage cleanup side-effects.<br>Atom 副作用是通过Atom的<code>effects_UNSTABLE</code>来添加的。在Atom初始化的时候。每一个Atom都可以引用一个按照优先级调用的atom副作用函数的数组。当第一次应用于<code>&lt;RecoilRoot&gt;</code>时，Atom被初始化。但是也许他们没有被调用或者没有被清除，就会被再次初始化。Atom副作用函数会返回一个可选的处理副作用的函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myState = atom(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MyKey&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">null</span>,</span><br><span class="line">    effects_UNSTABLE: [</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            ...effect <span class="number">1.</span>..</span><br><span class="line">            <span class="keyword">return</span> () =&gt; ...cleanup effect <span class="number">1.</span>..;</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123; ...effect <span class="number">2.</span>.. &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/utils/atomFamily">Atom families</a> also support parameterized or non-parameterized effects:<br>Atom也支持参数化或者无参化：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const myStateFamily = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;MyKey&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: <span class="function"><span class="params">param</span> =&gt;</span> [</span><br><span class="line">        <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ...effect <span class="number">1</span> using param...</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> ...cleanup effect <span class="number">1.</span>..;</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123; ...effect <span class="number">2</span> using param... &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Compared-to-React-Effects-与React副作用相比"><a href="#Compared-to-React-Effects-与React副作用相比" class="headerlink" title="Compared to React Effects 与React副作用相比"></a>Compared to React Effects 与React副作用相比</h4><p>Atom effects could mostly be implemented via React <code>useEffect()</code>. However, the set of atoms are created outside of a React context, and it can be difficult to manage effects from within React components, particularly for dynamically created atoms. They also cannot be used to initialize the initial atom value or be used with server-side rendering. Using atom effects also co-locates the effects with the atom definitions.<br>Atom副作用主要是通过React的<code>useEffect</code>钩子函数来生效。然后atoms是在React上下文之外被创建的。并且在React组建内部管理副作用是非常困难的。特别是动态生成的atoms.这些atoms也常常并不能被用来初始化初始的atom值，或者是用来做服务端渲染。通常atom副作是和定义atom在同一处。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myState = atom(&#123;<span class="attr">key</span>: <span class="string">&#x27;Key&#x27;</span>, <span class="attr">default</span>: <span class="literal">null</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyStateEffect</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [value, setValue] = useRecoilState(myState);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Called when the atom value changes</span></span><br><span class="line">        store.set(value);</span><br><span class="line">        store.onChange(setValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; store.onChange(<span class="literal">null</span>); &#125;; <span class="comment">// Cleanup effect</span></span><br><span class="line">    &#125;, [value]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">MyStateEffect</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            ...</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Compared-to-Snapshots"><a href="#Compared-to-Snapshots" class="headerlink" title="Compared to Snapshots"></a>Compared to Snapshots</h4><p>The <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot#hooks">Snapshot hooks</a> API can also monitor atom state changes and the initializeState prop in <a target="_blank" rel="noopener" href="https://www.recoiljs.cn/docs/api-reference/core/RecoilRoot"><RecoilRoot></RecoilRoot></a> can initialize values for initial render. However, these APIs monitor all state changes and can be awkward to manage dynamic atoms, particularly atom families. With atom effects, the side-effect can be defined per-atom alongside the atom definition and multiple policies can be easily composed.<br>Snapshot hooks钩子API可以监听Atom状态的变化并且为初次渲染初始化RecoilRoot组件的初始值。然后，这些API监听所有的状态变化，并且很难管理动态的Atom.尤其是atom系列。有了atom副作用。一些副作用，就可以通过atom提前定义，并且和多种方案组合在一起。</p>
<h4 id="Logging-Example"><a href="#Logging-Example" class="headerlink" title="Logging Example"></a>Logging Example</h4><p>A simple example of using atom effects are for logging a specific atom’s state changes.<br>一个简单的使用atom副作用来记录特定atom状态的变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        <span class="function">(<span class="params">&#123;onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        onSet(<span class="function"><span class="params">newID</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.debug(<span class="string">&quot;Current user ID:&quot;</span>, newID);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="History-Example"><a href="#History-Example" class="headerlink" title="History Example"></a>History Example</h4><p>A more complex example of logging might maintain a history of changes. This example provides an effect which maintains a history queue of state changes with callback handlers that undo that particular change:<br>一个更复杂的例子是用来维护变化的历史记录。此示例提供了一个效果，它使用撤消特定更改的回调处理程序维护状态更改的历史队列：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> history: <span class="built_in">Array</span>&lt;&#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">undo</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">&#125;&gt; = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> historyEffect = <span class="function"><span class="params">name</span> =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    onSet(<span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">        history.push(&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">`<span class="subst">$&#123;name&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.serialize(oldValue)&#125;</span> -&gt; <span class="subst">$&#123;<span class="built_in">JSON</span>.serialize(newValue)&#125;</span>`</span>,</span><br><span class="line">            <span class="attr">undo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                setSelf(oldValue);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfoState = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: <span class="function"><span class="params">userID</span> =&gt;</span> [</span><br><span class="line">        historyEffect(<span class="string">`<span class="subst">$&#123;userID&#125;</span> user info`</span>),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="State-Synchronization-Example-状态同步案例"><a href="#State-Synchronization-Example-状态同步案例" class="headerlink" title="State Synchronization Example 状态同步案例"></a>State Synchronization Example 状态同步案例</h4><p>It can be useful to use atoms as a local cached value of some other state such as a remote database, local storage, &amp;c. You could set the <code>default</code> value of an atom using the <code>default</code> property with a selector to get the store’s value. However, that is only a one-time lookup; if the store’s value changes the atom value will not change. With effects, we can subscribe to the store and update the atom’s value whenever the store changes. Calling <code>setSelf()</code> from the effect will initialize the atom to that value and will be used for the initial render. If the atom is reset, it will revert to the default value, not the initialized value.<br>将atom作为诸如，远程数据库，本地存储等的本地缓存状态是非常有用的。可以通过selector设置默认属性给atom设置默认的值来获取存储的值。然后，这只是一次性的。如果存储中的值发生了变化，而atom的值是不会有变化的。通过副作用，无论何时，我们都可以订阅存储中的值，并且更新atom的值。从副作用中调用<code>setSelf()</code>函数来初始化atom并且初次渲染。如果atom被重置。他将会再次被设置为默认值，而不是初始值。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> syncStorageEffect = <span class="keyword">user</span>ID =&gt; (&#123;<span class="built_in">set</span>Self, trigger&#125;) =&gt; &#123;</span><br><span class="line">    // Initialize atom value <span class="keyword">to</span> the remote storage <span class="keyword">state</span></span><br><span class="line">    if (trigger === &#x27;get&#x27;) &#123; // Avoid expensive initialization</span><br><span class="line">        <span class="built_in">set</span>Self(myRemoteStorage.get(<span class="keyword">user</span>ID)); // C<span class="literal">all</span> synchronously <span class="keyword">to</span> initialize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Subscribe <span class="keyword">to</span> remote storage changes and update the atom value</span><br><span class="line">    myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, <span class="keyword">user</span>Info =&gt; &#123;</span><br><span class="line">        <span class="built_in">set</span>Self(<span class="keyword">user</span>Info); // C<span class="literal">all</span> asynchronously <span class="keyword">to</span> change value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Cleanup remote storage subscription</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, null);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">user</span>InfoState = atomFamily(&#123;</span><br><span class="line">    key: &#x27;UserInfo&#x27;,</span><br><span class="line">    <span class="keyword">default</span>: null,</span><br><span class="line">    effects_UNSTABLE: <span class="keyword">user</span>ID =&gt; [</span><br><span class="line">        historyEffect(`$&#123;<span class="keyword">user</span>ID&#125; <span class="keyword">user</span> info`),</span><br><span class="line">        syncStorageEffect(<span class="keyword">user</span>ID),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Write-Through-Cache-Example"><a href="#Write-Through-Cache-Example" class="headerlink" title="Write-Through Cache Example"></a>Write-Through Cache Example</h4><p>We can also bi-directionally sync atom values with remote storage so changes on the server update the atom value and changes in the local atom are written back to the server. The effect will not call the <code>onSet()</code> handler when changed via that effect’s <code>setSelf()</code> to help avoid feedback loops.<br>我们也可以通过在服务器上的远程存储来更新atom的值也可以重写本地atom的值到服务端的方式来实现双向同步atom的值。当通过副作用的<code>setSelf()</code>来循环调用的时候，副作用不会调用<code>onSet()</code> </p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> syncStorageEffect = <span class="keyword">user</span>ID =&gt; (&#123;<span class="built_in">set</span>Self, <span class="keyword">on</span>Set, trigger&#125;) =&gt; &#123;</span><br><span class="line">    // Initialize atom value <span class="keyword">to</span> the remote storage <span class="keyword">state</span></span><br><span class="line">    if (trigger === &#x27;get&#x27;) &#123; // Avoid expensive initialization</span><br><span class="line">        <span class="built_in">set</span>Self(myRemoteStorage.get(<span class="keyword">user</span>ID)); // C<span class="literal">all</span> synchronously <span class="keyword">to</span> initialize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Subscribe <span class="keyword">to</span> remote storage changes and update the atom value</span><br><span class="line">    myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, <span class="keyword">user</span>Info =&gt; &#123;</span><br><span class="line">        <span class="built_in">set</span>Self(<span class="keyword">user</span>Info); // C<span class="literal">all</span> asynchronously <span class="keyword">to</span> change value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Subscribe <span class="keyword">to</span> local changes and update the server value</span><br><span class="line">    <span class="keyword">on</span>Set(<span class="keyword">user</span>Info =&gt; &#123;</span><br><span class="line">        myRemoteStorage.<span class="built_in">set</span>(<span class="keyword">user</span>ID, <span class="keyword">user</span>Info);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Cleanup remote storage subscription</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, null);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Local-Storage-Persistence-本地存储持久化"><a href="#Local-Storage-Persistence-本地存储持久化" class="headerlink" title="Local Storage Persistence 本地存储持久化"></a>Local Storage Persistence 本地存储持久化</h4><p>Atom effects can be used to persist atom state with <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">browser local storage</a>. Note that the following examples are simplified for illustrative purposes and do not cover all cases.<br>Atom副作用可以通过浏览器本地存储做atom状态的持久化。注意下面的例子，非常简明的说明了这点，但并不能涵盖所有。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> localStorageEffect = <span class="function"><span class="params">key</span> =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> savedValue = <span class="built_in">localStorage</span>.getItem(key)</span><br><span class="line">    <span class="keyword">if</span> (savedValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        setSelf(<span class="built_in">JSON</span>.parse(savedValue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onSet(<span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> DefaultValue) &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        localStorageEffect(<span class="string">&#x27;current_user&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Backward-Compatibility"><a href="#Backward-Compatibility" class="headerlink" title="Backward Compatibility"></a>Backward Compatibility</h4><p>What if you change the format for an atom? Loading a page with the new format with a localStorage based on the old format could case a problem. You could build effects to handle restoring and validating the value in a type safe way:<br>要是你改变了atom的格式怎么办？用新的格式加在基于旧的格式的页面将会有问题。你可以创建新的副作用来重新存储并且验证值是安全的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersistenceOptions&lt;T&gt;: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">restorer</span>: <span class="function">(<span class="params">mixed, DefaultValue</span>) =&gt;</span> T | DefaultValue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localStorageEffect = &lt;T&gt;<span class="function">(<span class="params">options: PersistenceOptions&lt;T&gt;</span>) =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> savedValue = <span class="built_in">localStorage</span>.getItem(options.key)</span><br><span class="line">    <span class="keyword">if</span> (savedValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        setSelf(options.restorer(<span class="built_in">JSON</span>.parse(savedValue), <span class="keyword">new</span> DefaultValue()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onSet(<span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> DefaultValue) &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(options.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(options.key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserIDState = atom&lt;<span class="built_in">number</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        localStorageEffect(&#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;current_user&#x27;</span>,</span><br><span class="line">        <span class="attr">restorer</span>: <span class="function">(<span class="params">value, defaultValue</span>) =&gt;</span></span><br><span class="line">            <span class="comment">// values are currently persisted as numbers</span></span><br><span class="line">            <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">            ? value</span><br><span class="line">            <span class="comment">// if value was previously persisted as a string, parse it to a number</span></span><br><span class="line">            : <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">            ? <span class="built_in">parseInt</span>(value, <span class="number">10</span>)</span><br><span class="line">            <span class="comment">// if type of value is not recognized, then use the atom&#x27;s default value.</span></span><br><span class="line">            : defaultValue</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>What if the key used to persist the value changes? Or what used to be persisted using one key now uses several? Or vice versa? That can also be handled in a type-safe way:<br>要是持久化数据的key变化了怎么办？或者是之前用一个，现在用了多个key怎么办？反之亦然。这也依然可以通过安全的方式来处理：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersistenceOptions&lt;T&gt;: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">restorer</span>: <span class="function">(<span class="params">mixed, DefaultValue, <span class="built_in">Map</span>&lt;<span class="built_in">string</span>, mixed&gt;</span>) =&gt;</span> T | DefaultValue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localStorageEffect = &lt;T&gt;<span class="function">(<span class="params">options: PersistenceOptions&lt;T&gt;</span>) =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> savedValues = parseValuesFromStorage(<span class="built_in">localStorage</span>);</span><br><span class="line">    <span class="keyword">const</span> savedValue = savedValues.get(options.key);</span><br><span class="line">    setSelf(</span><br><span class="line">        options.restorer(savedValue ?? <span class="keyword">new</span> DefaultValue(), <span class="keyword">new</span> DefaultValue(), savedValues),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    onSet(<span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> DefaultValue) &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(options.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(options.key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserIDState = atom&lt;<span class="built_in">number</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        localStorageEffect(&#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;current_user&#x27;</span>,</span><br><span class="line">        <span class="attr">restorer</span>: <span class="function">(<span class="params">value, defaultValue, values</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> oldValue = values.get(<span class="string">&#x27;old_key&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> oldValue === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defaultValue;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Browser-URL-History-Persistence-浏览器URL历史数据持久化"><a href="#Browser-URL-History-Persistence-浏览器URL历史数据持久化" class="headerlink" title="Browser URL History Persistence 浏览器URL历史数据持久化"></a>Browser URL History Persistence 浏览器URL历史数据持久化</h4><p>Atom state can also be persisted and synced with the browser URL history. This can be useful to have state changes update the current URL so it can be saved or shared with others to restore that state. It can also be integrated with the browser history to leverage the browser forward/back buttons. Examples or a library to provide this type of persistence are coming soon…<br>浏览器同样可以用来做浏览器URL历史的数据持久化和数据的同步。这在处理更新当前URL状态是非常有用的，这对于保存或者和与别的Atom共享重新存储状态是非常有用的。它还可以与浏览器历史记录集成，以利用浏览器前进/后退按钮。提供这个功能的案例或者是库正在开发中…</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/guides/data-query"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/guides/data-query/"
    >Recoil指南--Asynchronous Data Queries 异步数据请求</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/guides/data-query/" class="article-date">
  <time datetime="2020-11-09T03:07:13.000Z" itemprop="datePublished">2020-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Recoil provides a way to map state and derived state to React components via a data-flow graph. What’s really powerful is that the functions in the graph can also be asynchronous. This makes it easy to use asynchronous functions in synchronous React component render functions. Recoil allows you to seamlessly mix synchronous and asynchronous functions in your data-flow graph of selectors. Simply return a Promise to a value instead of the value itself from a selector <code>get</code> callback, the interface remains exactly the same. Because these are just selectors, other selectors can also depend on them to further transform the data.<br>Recoil通过数据流图为react提供了俩中state.更为强大的是，函数式的数据流可以是异步的。这使得在同步的react组件中使用异步函数渲染变的非常容易。在Recoil的selector数据流中可以允同步和异步方法混合使用，翻译一个Promise来获取值，而不是Selector的<code>get</code>回调中。接口也是同样的类似，因为这些仅仅是Selector,其他的Selector可以依赖于这些Selector做更多的数据转化。<br>Selectors can be used as one way to incorporate asynchronous data into the Recoil data-flow graph. Please keep in mind that selectors represent “idempotent” functions: For a given set of inputs they should always produce the same results (at least for the lifetime of the application). This is important as selector evaluations may be cached, restarted, or executed multiple times. Because of this, selectors are generally a good way to model read-only DB queries. For mutable data you can use a <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/asynchronous-data-queries#query-refresh">Query Refresh</a> or to synchronize mutable state, persist state, or for other side-effects consider the experimental <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/atom-effects">Atom Effects API</a>.<br>Selector可以被视作为是注册异步数据的一种方式。切记，selector代表了’幂等’函数：对于给定的一组输入，它们应该总是产生相同的结果（至少在应用程序的生命周期内），这一点非常的重要，因为selector的运算可能被缓存，重新计算，或者被执行多次。尽管如此，Selector也是一个读取数据查询非常好的方式。对于那些可变的数据，可以<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/asynchronous-data-queries#query-refresh">刷新请求</a>或者同步可变状态，持久状态或者可以考虑其他的副作用的<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/atom-effects">Atom Api</a>.</p>
<h3 id="Synchronous-Example-同步案例"><a href="#Synchronous-Example-同步案例" class="headerlink" title="Synchronous Example 同步案例"></a>Synchronous Example 同步案例</h3><p>For example, here is a simple synchronous <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/atom">atom</a> and <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/selector">selector</a> to get a user name:<br>例如，下面是一个简单的异步获取用户名的<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/atom">Atom</a>和<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/selector">Selector</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserNameState = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tableOfUsers[get(currentUserIDState)].name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserNameState);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Asynchronous-Example-异步案例"><a href="#Asynchronous-Example-异步案例" class="headerlink" title="Asynchronous Example 异步案例"></a>Asynchronous Example 异步案例</h3><p>If the user names were stored in some database we need to query, all we need to do is return a <code>Promise</code> or use an <code>async</code> function. If any dependencies change, the selector will be re-evaluated and execute a new query. The results are cached, so the query will only execute once per unique input.<br>如果我们需要的用户名是被存储到某个数据库，我们需要做的就是就是通过<code>async</code>方法返回一个<code>Promise</code>.如果一些依赖项发生变化，Selector也会重新计算，或者是重新发起请求。结果会被缓存，所以请求只会被执行一次。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserNameQuery = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: <span class="keyword">async</span> (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;</span><br><span class="line">            userID: <span class="keyword">get</span>(currentUserIDState),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">CurrentUserInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserNameQuery);</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;userName&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The interface of the selector is the same, so the component using this selector doesn’t need to care if it was backed with synchronous atom state, derived selector state, or asynchronous queries!<br>Selector的接口也是一样的，因此组件中用到Selector并不需要关心是否支持同步的Atom 状态，派生Selector状态，或者是异步请求。<br>But, since React render functions are synchronous, what will it render before the promise resolves? Recoil is designed to work with <a target="_blank" rel="noopener" href="https://reactjs.org/docs/concurrent-mode-suspense.html">React Suspense</a> to handle pending data. Wrapping your component with a Suspense boundary will catch any descendants that are still pending and render a fallback UI:<br>但是，由于react的渲染是同步的，那么在promise reslove之前什么会被渲染？Recoil设计使用<a target="_blank" rel="noopener" href="https://reactjs.org/docs/concurrent-mode-suspense.html">react Suspense</a>来处理进行中的数据。将组件以及其后代组件暂时都挂起，返回等待中的UI界面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Error-Handling-错误处理"><a href="#Error-Handling-错误处理" class="headerlink" title="Error Handling 错误处理"></a>Error Handling 错误处理</h3><p>But what if the request has an error? Recoil selectors can also throw errors which will then be thrown if a component tries to use that value. This can be caught with a React <a target="_blank" rel="noopener" href="https://reactjs.org/docs/error-boundaries.html"><ErrorBoundary></ErrorBoundary></a>. For example:<br>一旦请求出现错误怎么办？Recoil Selector可以扔出一个React组件可以捕获的错误。这个错误可以被React的<a target="_blank" rel="noopener" href="https://reactjs.org/docs/error-boundaries.html"><ErrorBoundary></ErrorBoundary></a>组件捕获。案例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserNameQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">async</span> (&#123;get&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;</span><br><span class="line">            <span class="attr">userID</span>: get(currentUserIDState),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserNameQuery);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Queries-with-Parameters-带参请求"><a href="#Queries-with-Parameters-带参请求" class="headerlink" title="Queries with Parameters 带参请求"></a>Queries with Parameters 带参请求</h3><p>Sometimes you want to be able to query based on parameters that aren’t just based on derived state. For example, you may want to query based on the component props. You can do that using the <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/selectorFamily">selectorFamily</a> helper:<br>有时候你可能想要发起一个携带参数带请求的不仅仅依赖于派生状态。例如，你的请求是基于组件的props,那么你可以使用<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/selectorFamily">selectorFamily</a>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userNameQuery = selectorFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserName&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="params">userID</span> =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;userID&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(userNameQuery(userID));</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;1&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;2&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;3&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-Flow-Graph-数据流"><a href="#Data-Flow-Graph-数据流" class="headerlink" title="Data-Flow Graph 数据流"></a>Data-Flow Graph 数据流</h3><p>Remember, by modeling queries as selectors, we can build a data-flow graph mixing state, derived state, and queries! This graph will automatically update and re-render React components as state is updated.<br>切记，我们可以通过模块查询来创建混合状态，派生状态，以及请求的Selector。这样数据状态一旦更新React的组件会自动更新并重新渲染。<br>The following example will render the current user’s name and a list of their friends. If a friend’s name is clicked on, they will become the current user and the name and list will be automatically updated.<br>下面的例子将会渲染当前的用户名，以及朋友列表，如果某一个朋友的名字被点击。他将会变成当前的用户，并且姓名和裂变会自动更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfoQuery = selectorFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="params">userID</span> =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserInfoQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> get(userInfoQuery(get(currentUserIDState))),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> friendsInfoQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;FriendsInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;friendList&#125; = get(currentUserInfoQuery);</span><br><span class="line">        <span class="keyword">return</span> friendList.map(<span class="function"><span class="params">friendID</span> =&gt;</span> get(userInfoQuery(friendID)));</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUser = useRecoilValue(currentUserInfoQuery);</span><br><span class="line">    <span class="keyword">const</span> friends = useRecoilValue(friendsInfoQuery);</span><br><span class="line">    <span class="keyword">const</span> setCurrentUserID = useSetRecoilState(currentUserIDState);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;currentUser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;friends.map(friend =&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;friend.id&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCurrentUserID(friend.id)&#125;&gt;</span></span><br><span class="line"><span class="xml">                    &#123;friend.name&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                )&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Concurrent-Requests-当前请求"><a href="#Concurrent-Requests-当前请求" class="headerlink" title="Concurrent Requests 当前请求"></a>Concurrent Requests 当前请求</h3><p>If you notice in the above example, the <code>friendsInfoQuery</code> uses a query to get the info for each friend. But, by doing this in a loop they are essentially serialized. If the lookup is fast, maybe that’s ok. If it’s expensive, you can use a concurrency helper such as <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/waitForAll">waitForAll</a> to run them in parallel. This helper accepts both arrays and named objects of dependencies.<br>如果你注意到上面到例子。<code>friendsInfoQuery</code>发起请求来获取每一个朋友的信息。但是通过这样的循环是为了本质上的有序列化。如果查询速度够快，这没什么，要不然就，可以使用例如<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/waitForAll">waitForAll</a>的并发请求来处理。他既可以接受数组，也可以接受对象作为参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> friendsInfoQuery = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;FriendsInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;friendList&#125; = <span class="keyword">get</span>(currentUserInfoQuery);</span><br><span class="line">        <span class="keyword">const</span> friends = <span class="keyword">get</span>(waitForAll(</span><br><span class="line">            friendList.map(friendID =&gt; userInfoQuery(friendID))</span><br><span class="line">        ));</span><br><span class="line">        <span class="keyword">return</span> friends;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>You can use <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/waitForNone">waitForNone</a> to handle incremental updates to the UI with partial data.<br>同样也可以使用<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/utils/waitForNone">waitForNone</a>部分数据来处理UI层面的更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> friendsInfoQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;FriendsInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;friendList&#125; = get(currentUserInfoQuery);</span><br><span class="line">        <span class="keyword">const</span> friendLoadables = get(waitForNone(</span><br><span class="line">                friendList.map(<span class="function"><span class="params">friendID</span> =&gt;</span> userInfoQuery(friendID))</span><br><span class="line">            ));</span><br><span class="line">        <span class="keyword">return</span> friendLoadables</span><br><span class="line">        .filter(<span class="function">(<span class="params">&#123;state&#125;</span>) =&gt;</span> state === <span class="string">&#x27;hasValue&#x27;</span>)</span><br><span class="line">        .map(<span class="function">(<span class="params">&#123;contents&#125;</span>) =&gt;</span> contents);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Pre-Fetching-预请求"><a href="#Pre-Fetching-预请求" class="headerlink" title="Pre-Fetching 预请求"></a>Pre-Fetching 预请求</h3><p>For performance reasons you may wish to kick off fetching before rendering. That way the query can be going while we start rendering. The <a target="_blank" rel="noopener" href="https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early">React docs</a> give some examples. This pattern works with Recoil as well.<br>由于一些其他的原因，你可能希望能在渲染之前开启请求。这当然也是没有问题的。在开始渲染的时候，是可以发起请求的。React文档给了我们例子，这当然也适用于Recoil.<br>Let’s change the above example to initiate a fetch for the next user info as soon as the user clicks the button to change users:<br>我们来修改一下上面的例子，在用户一点击按钮改变用户的时候为下一个用户初始化一个请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUser = useRecoilValue(currentUserInfoQuery);</span><br><span class="line">    <span class="keyword">const</span> friends = useRecoilValue(friendsInfoQuery);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changeUser = useRecoilCallback(<span class="function">(<span class="params">&#123;snapshot, set&#125;</span>) =&gt;</span> <span class="function"><span class="params">userID</span> =&gt;</span> &#123;</span><br><span class="line">        snapshot.getLoadable(userInfoQuery(userID)); <span class="comment">// pre-fetch user info</span></span><br><span class="line">        set(currentUserIDState, userID); <span class="comment">// change current user to start new render</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;currentUser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;friends.map(friend =&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;friend.id&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> changeUser(friend.id)&#125;&gt;</span></span><br><span class="line"><span class="xml">                    &#123;friend.name&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                )&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Async-Queries-Without-React-Suspense-没有React-Suspense的异步请求"><a href="#Async-Queries-Without-React-Suspense-没有React-Suspense的异步请求" class="headerlink" title="Async Queries Without React Suspense 没有React Suspense的异步请求"></a>Async Queries Without React Suspense 没有React Suspense的异步请求</h3><p>It is not necessary to use React Suspense for handling pending asynchronous selectors. You can also use the <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useRecoilValueLoadable">useRecoilValueLoadable()</a> hook to determine the status during rendering:<br>使用React Subspense来处理进行中的异步Selector，并不是必须的。在渲染期间，也可以使用<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useRecoilValueLoadable">useRecoilValueLoadable()</a>钩子函数来处理状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;userID&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userNameLoadable = useRecoilValueLoadable(userNameQuery(userID));</span><br><span class="line">    <span class="keyword">switch</span> (userNameLoadable.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;hasValue&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userNameLoadable.contents&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;loading&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;hasError&#x27;</span>:</span><br><span class="line">            <span class="keyword">throw</span> userNameLoadable.contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Query-Refresh请求刷新"><a href="#Query-Refresh请求刷新" class="headerlink" title="Query Refresh请求刷新"></a>Query Refresh请求刷新</h3><p>When using selectors to model data queries, it’s important to remember that selector evaluation should always provide a consistent value for a given state. Selectors represent state derived from other atom and selector states. Thus, selector evaluation functions should be idempotent for a given input, as it may be cached or executed multiple times. Practically, that means a single selector should not be used for a query where you expect the results to vary during the application’s lifetime.<br>当使用Selector来发起数据请求的时候，切记，selector运算总是会提供和给定的状态一致的值。Selector代表状态派生到其他的Atom或者是selector状态。因此，对于给定的输入，Selector函数应该是幂等的。因为他可能会被缓存，或者是执行多次。实际上，这意味着一个Selector在整个应用的生命周期中不应该被应用于你希望得到的结果总是变化的请求。</p>
<p>There are a few patterns you can use for working with mutable data:<br>下面是一些应用于修改数据的模式：</p>
<h5 id="Use-a-Request-ID-用ID请求"><a href="#Use-a-Request-ID-用ID请求" class="headerlink" title="Use a Request ID 用ID请求"></a>Use a Request ID 用ID请求</h5><p>Selector evaluation should provide a consistent value for a given state based on input (dependent state or family parameters). So, you could add a request ID as either a family parameter or a dependency to your query. For example:<br>Selector运算需要为state提供基于输入（独立的状态或者是一组参数）一致的值，所以，需要为请求添加一个请求的ID，要不是参数，要不是依赖，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfoQueryRequestIDState = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfoQueryRequestID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfoQuery = selectorFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="params">userID</span> =&gt;</span> <span class="keyword">async</span> (&#123;get&#125;) =&gt; &#123;</span><br><span class="line">        get(userInfoQueryRequestIDState(userID)); <span class="comment">// Add request ID as a dependency</span></span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRefreshUserInfo</span>(<span class="params">userID</span>) </span>&#123;</span><br><span class="line">    setUserInfoQueryRequestID = useSetRecoilState(userInfoQueryRequestIDState(userID));</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setUserInfoQueryRequestID(<span class="function"><span class="params">requestID</span> =&gt;</span> requestID++);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUserID = useRecoilValue(currentUserIDState);</span><br><span class="line">    <span class="keyword">const</span> currentUserInfo = userRecoilValue(userInfoQuery(currentUserID));</span><br><span class="line">    <span class="keyword">const</span> refreshUserInfo = useRefreshUserInfo(currentUserID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;currentUser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;refreshUserInfo&#125;</span>&gt;</span>Refresh<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Use-an-Atom-Atom使用"><a href="#Use-an-Atom-Atom使用" class="headerlink" title="Use an Atom Atom使用"></a>Use an Atom Atom使用</h5><p>Another option is to use an atom, instead of a selector, to model the query results. You can imperatively update the atom state with the new query results based on your refresh policy.<br>另外一个方法就是使用Atom,而不是Selector来处理请求结果。可以根据刷新策略使用新的查询结果强制更新atom状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfoState = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="function"><span class="params">userID</span> =&gt;</span> fetch(userInfoURL(userID)),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React component to refresh query</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RefreshUserInfo</span>(<span class="params">&#123;userID&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> refreshUserInfo = useRecoilCallback(<span class="function">(<span class="params">&#123;set&#125;</span>) =&gt;</span> <span class="keyword">async</span> id =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> userInfo = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        set(userInfoState(userID), userInfo);</span><br><span class="line">    &#125;, [userID]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refresh user info every second</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> intervalID = <span class="built_in">setInterval</span>(refreshUserInfo, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(intervalID);</span><br><span class="line">    &#125;, [refreshUserInfo]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One downside to this approach is that atoms do not currently support accepting a Promise as the new value in order to automatically take advantage of React Suspense while the query refresh is pending, if that is your desired behavior. However, you could store an object which manually encodes the loading status as well as the results if desired.<br>这种方法的一个缺点是atoms当前不支持接受Promise作为新值，以便在查询刷新挂起时自动利用React-Suspense（如果这是您想要的行为）。但是，如果需要，您可以存储一个手动编码加载状态和结果的对象。</p>
<p>Also consider <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/atom-effects">atom effects</a> for query synchronization of atoms.<br>同样需求考虑<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/guides/atom-effects">Atom作用</a>对atom同步请求的影响。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/tutorial/selectors"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/tutorial/selectors/"
    >Recoil基础--Selector纯函数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/tutorial/selectors/" class="article-date">
  <time datetime="2020-11-04T05:51:18.000Z" itemprop="datePublished">2020-11-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Selectors-纯函数"><a href="#Selectors-纯函数" class="headerlink" title="Selectors 纯函数"></a>Selectors 纯函数</h1><p>A <strong>selector</strong> represents a piece of <strong>derived state</strong>. You can think of derived state as the output of passing state to a pure function that modifies the given state in some way.<br><strong>selecttor</strong>就是一种派生状态。你可以认为<strong>派生状态</strong>是一种高阶函数的返回值。<br>Derived state is a powerful concept because it lets us build dynamic data that depends on other data. In the context of our todo list application, the following are considered derived state:<br>派生状态是一个非常有意义的概念，因为他们能让我们创建依赖于其他数据的动态数据。在我们todo list的例子中，下面的数据被视作为派生状态：</p>
<ul>
<li><strong>Filtered todo list</strong>: derived from the complete todo list by creating a new list that has certain items filtered out based on some criteria (such as filtering out items that are already completed).<br>过滤todo List：</li>
<li><strong>Todo list statistics</strong>: derived from the complete todo list by calculating useful attributes of the list, such as the total number of items in the list, the number of completed items, and the percentage of items that are completed.<br>To implement a filtered todo list, we need to choose a set of filter criteria whose value can be saved in an atom. The filter options we’ll use are: “Show All”, “Show Completed”, and “Show Uncompleted”. The default value will be “Show All”:<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoListFilterState = atom(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;todoListFilterState&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">&#x27;Show All&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
Using <code>todoListFilterState</code> and <code>todoListState</code>, we can build a <code>filteredTodoListState</code> selector which derives a filtered list:<br>我们可以使用<code>todoListFilterState</code>和<code>todoListState</code>来创建一个<code>filteredTodoListState</code>Slector来获取过滤的列表：<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filteredTodoListState = selector(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;filteredTodoListState&#x27;</span>,</span><br><span class="line">    <span class="built_in">get</span>: (&#123;<span class="built_in">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">filter</span> = <span class="built_in">get</span>(todoListFilterState);</span><br><span class="line">        <span class="keyword">const</span> list = <span class="built_in">get</span>(todoListState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">filter</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Show Completed&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> list.<span class="built_in">filter</span>((item) =&gt; item.isComplete);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Show Uncompleted&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> list.<span class="built_in">filter</span>((item) =&gt; !item.isComplete);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
The <code>filteredTodoListState</code> internally keeps track of two dependencies: <code>todoListFilterState</code> and <code>todoListState</code> so that it re-runs if either of those change.<br><code>filteredTodoListState</code>与<code>todoListFilterState</code>和<code>todoListState</code>有密切关系，只要有其中一个发生变化，就会导致re-runs.<blockquote>
<p>From a component’s point of view, selectors can be read using the same hooks that are used to read atoms. However it’s important to note that certain hooks only work with writable state (i.e useRecoilState()). All atoms are writable state, but only some selectors are considered writable state (selectors that have both a get and set property). See the Core Concepts page for more information on this topic.</p>
</blockquote>
</li>
</ul>
<p>Displaying our filtered todoList is as simple as changing one line in the <code>TodoList</code> component:<br>展示过滤的todoList列表非常的简单，只需要在<code>TodoList</code>组件中修改一行代码就好。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// changed from todoListState to filteredTodoListState</span></span><br><span class="line">    <span class="keyword">const</span> todoList = useRecoilValue(filteredTodoListState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TodoListStats</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TodoListFilters</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TodoItemCreator</span> /&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        &#123;todoList.map((todoItem) =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">TodoItem</span> <span class="attr">item</span>=<span class="string">&#123;todoItem&#125;</span> <span class="attr">key</span>=<span class="string">&#123;todoItem.id&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note the UI is showing every todo because <code>todoListFilterState</code> was given a default value of “Show All”. In order to change the filter, we need to implement the <code>TodoListFilters</code> component:<br>注意，从UI层面来看，展示了所有的item,因为<code>todoListFilterState</code>被赋予了展示所有的默认值。为了过滤，我们需要一个<code>TodoListFilters</code>组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoListFilters</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [filter, setFilter] = useRecoilState(todoListFilterState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> updateFilter = <span class="function">(<span class="params">&#123;target: &#123;value&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        setFilter(value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        Filter:</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">&#123;filter&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;updateFilter&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Show All&quot;</span>&gt;</span>All<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Show Completed&quot;</span>&gt;</span>Completed<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Show Uncompleted&quot;</span>&gt;</span>Uncompleted<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With a few lines of code we’ve managed to implement filtering! We’ll use the same concepts to implement the <code>TodoListStats</code> component.<br>写了这么几行代码，我们已经可以让过滤生效了。我们可以用同样的概念使<code>TodoListStats</code>组件生效。<br>We want to display the following stats:<br>我们希望展示以下的统计：</p>
<ul>
<li>Total number of todo items items的总数</li>
<li>Total number of completed items 完成状态的item总数</li>
<li>Total number of uncompleted items 没有完成状态的item的总数</li>
<li>Percentage of items completed 完成状态的item的占比<br>While we could create a selector for each of the stats, an easier approach would be to create one selector that returns an object containing the data we need. We’ll call this selector <code>todoListStatsState</code>:<br>这时我们可以为每一个统计创建一个Selector.一种最简单的方式就是创建一个selectorr然后返回一个包含我们需要的数据的对象。我们将把这个Selector叫做<code>todoListStatsState</code>:<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoListStatsState = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;todoListStatsState&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> todoList = <span class="keyword">get</span>(todoListState);</span><br><span class="line">        <span class="keyword">const</span> totalNum = todoList.length;</span><br><span class="line">        <span class="keyword">const</span> totalCompletedNum = todoList.filter((item) =&gt; item.isComplete).length;</span><br><span class="line">        <span class="keyword">const</span> totalUncompletedNum = totalNum - totalCompletedNum;</span><br><span class="line">        <span class="keyword">const</span> percentCompleted = totalNum === <span class="number">0</span> ? <span class="number">0</span> : totalCompletedNum / totalNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            totalNum,</span><br><span class="line">            totalCompletedNum,</span><br><span class="line">            totalUncompletedNum,</span><br><span class="line">            percentCompleted,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
To read the value of <code>todoListStatsState</code>, we use <code>useRecoilValue()</code> once again:<br>再用<code>useRecoilValue()</code>函数来读取<code>todoListStatsState</code>的值：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoListStats</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        totalNum,</span><br><span class="line">        totalCompletedNum,</span><br><span class="line">        totalUncompletedNum,</span><br><span class="line">        percentCompleted,</span><br><span class="line">    &#125; = useRecoilValue(todoListStatsState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> formattedPercentCompleted = <span class="built_in">Math</span>.round(percentCompleted * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Total items: &#123;totalNum&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Items completed: &#123;totalCompletedNum&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Items not completed: &#123;totalUncompletedNum&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Percent completed: &#123;formattedPercentCompleted&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
To summarize, we’ve created a todo list app that meets all of our requirements:<br>总结，我们已经创建了满足我们以下需求的todo list应用：</li>
<li>Add todo items 增加item</li>
<li>Edit todo items 编辑item</li>
<li>Delete todo items 删除item</li>
<li>Filter todo items 过滤item</li>
<li>Display useful stats 展示统计</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/tutorial/atoms"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/tutorial/atoms/"
    >Recoil基础--Atoms共享状态</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/tutorial/atoms/" class="article-date">
  <time datetime="2020-11-02T10:25:18.000Z" itemprop="datePublished">2020-11-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Atoms共享状态"><a href="#Atoms共享状态" class="headerlink" title="Atoms共享状态"></a>Atoms共享状态</h1><p>Atoms contain the source of truth for our application state. In our todo-list, the source of truth will be an array of objects, with each object representing a todo item.<br>Atoms包含了应用的状态资源，在我们的todo-list的例子里，数据来源是一个包含了多个对象的数组，每一个对象就是一个todo item项.<br>We’ll call our list atom <code>todoListState</code> and create it using the <code>atom()</code> function:<br>用 <code>atom()</code>方法创建列表的Atom，并调用<code>todoListState</code>:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoListState = atom(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;todoListState&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: [],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>We give our atom a unique <code>key</code> and set the <code>default</code> value to an empty array. To read the contents of this atom, we can use the <code>useRecoilValue()</code> hook in our TodoList component:<br>给atom添加一个唯一的<code>标示</code>，设置一个空数组作为<code>默认值</code>。我们可以在组件中使用用<code>useRecoilValue()</code>钩子函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> todoList = useRecoilValue(todoListState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;/* <span class="tag">&lt;<span class="name">TodoListStats</span> /&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml">                &#123;/* <span class="tag">&lt;<span class="name">TodoListFilters</span> /&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">TodoItemCreator</span> /&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">                &#123;todoList.map((todoItem) =&gt; (</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">TodoItem</span> <span class="attr">key</span>=<span class="string">&#123;todoItem.id&#125;</span> <span class="attr">item</span>=<span class="string">&#123;todoItem&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                ))&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The commented-out components will be implemented in the sections that follow.<br>注释部分的组件将会在接下来的部分讲解。<br>To create new todo items, we need to access a setter function that will update the contents of the <code>todoListState</code>. We can use the <code>useSetRecoilState()</code> hook to get a setter function in our <code>TodoItemCreator</code> component:<br>创建新的todo items项，需要创建一个新的setter函数来更新<code>todoListState</code>的内容。那么在<code>TodoItemCreator</code>组件中，我们可以通过<code>useSetRecoilState()</code>钩子函数来创建这个setter函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoItemCreator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [inputValue, setInputValue] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> setTodoList = useSetRecoilState(todoListState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> addItem = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setTodoList(<span class="function">(<span class="params">oldTodoList</span>) =&gt;</span> [</span><br><span class="line">        ...oldTodoList,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">id</span>: getId(),</span><br><span class="line">            <span class="attr">text</span>: inputValue,</span><br><span class="line">            <span class="attr">isComplete</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        ]);</span><br><span class="line">        setInputValue(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onChange = <span class="function">(<span class="params">&#123;target: &#123;value&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        setInputValue(value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addItem&#125;</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utility for creating unique Id</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice we use the <strong>updater</strong> form of the setter function so that we can create a new todo list based on the old todo list.<br>注意我们使用了setter函数中新的更新器，以至于我们能基于之前的todo list来创建新的todo list.<br>The <code>TodoItem</code> component will display the value of the todo item while allowing you to change its text and delete the item. We use <code>useRecoilState()</code> to read <code>todoListState</code> and to get a setter function that we use to update the item text, mark it as completed, and delete it:<br>当更改<code>TodoItem</code>组件的内容或者删除其中一个item的时候，<code>TodoItem</code>组件就展示todo item项的内容。我们通过使用<code>useRecoilState()</code>来读取<code>todoListState</code>并且通过setter函数得到更新的item内容，这意味着更新的完成，并且已经删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoItem</span>(<span class="params">&#123;item&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [todoList, setTodoList] = useRecoilState(todoListState);</span><br><span class="line">  <span class="keyword">const</span> index = todoList.findIndex(<span class="function">(<span class="params">listItem</span>) =&gt;</span> listItem === item);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> editItemText = <span class="function">(<span class="params">&#123;target: &#123;value&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newList = replaceItemAtIndex(todoList, index, &#123;</span><br><span class="line">            ...item,</span><br><span class="line">            <span class="attr">text</span>: value,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setTodoList(newList);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> toggleItemCompletion = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newList = replaceItemAtIndex(todoList, index, &#123;</span><br><span class="line">            ...item,</span><br><span class="line">            <span class="attr">isComplete</span>: !item.isComplete,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setTodoList(newList);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> deleteItem = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newList = removeItemAtIndex(todoList, index);</span><br><span class="line"></span><br><span class="line">        setTodoList(newList);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;item.text&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;editItemText&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">checked</span>=<span class="string">&#123;item.isComplete&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">onChange</span>=<span class="string">&#123;toggleItemCompletion&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;deleteItem&#125;</span>&gt;</span>X<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceItemAtIndex</span>(<span class="params">arr, index, newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...arr.slice(<span class="number">0</span>, index), newValue, ...arr.slice(index + <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeItemAtIndex</span>(<span class="params">arr, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...arr.slice(<span class="number">0</span>, index), ...arr.slice(index + <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And with that we’ve got a fully functional todo list! In the next section we’ll see how we can use selectors to take our list to the next level.<br>这样我们就得到了完整的todolist 组件。在下一个章节，我们将看看selectors是如何将我们的组件提升到一个新的高度的。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/tutorial/introduce"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/tutorial/introduce/"
    >Recoil基础--基础介绍</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/tutorial/introduce/" class="article-date">
  <time datetime="2020-11-02T10:25:18.000Z" itemprop="datePublished">2020-11-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>This section assumes you have installed Recoil and React. See the <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/introduction/getting-started">Getting Started</a> page for how to get started with Recoil and React from scratch. Components in the following sections are assumed to have a <code>&lt;RecoilRoot /&gt;</code> in the parent tree.<br>这一章节主要是安装Recoil和React,可以查看<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/introduction/getting-started">开始</a>页如何安装Recoil和React,在下面的章节中，根组件中都会使用<code>&lt;RecoilRoot /&gt;</code>组件。<br>In this tutorial, we’ll be building a simple todo-list application. Our app will be able to do the following:<br>我们会创建一个简单的todo-list的应用。我们的应用会做到以下几点：</p>
<ul>
<li>Add todo items 添加todo项</li>
<li>Edit todo items 开发todo项</li>
<li>Delete todo items 删除todo项</li>
<li>Filter todo items 过滤todo项</li>
<li>Display useful stats 展示state<br>Along the way, we’ll cover atoms, selectors, atom families, and the hooks exposed by the Recoil API. We’ll also cover optimization<br>这样，我们会很好的覆盖到Atoms,selectors,atom全家桶，以及Recoil API 暴露的hooks。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/introduce/concepts"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/introduce/concepts/"
    >Recoil简介--核心概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/introduce/concepts/" class="article-date">
  <time datetime="2020-10-28T10:25:18.000Z" itemprop="datePublished">2020-10-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="OverViews-概览"><a href="#OverViews-概览" class="headerlink" title="OverViews 概览"></a>OverViews 概览</h3><p>Recoil lets you create a data-flow graph that flows from atoms (shared state) through selectors (pure functions) and down into your React components. Atoms are units of state that components can subscribe to. Selectors transform this state either synchronously or asynchronously.<br>Recoil可以通过Selector(纯函数)和Atoms(共享状态)来创建组件之间共享数据的数据流图。Atoms是组件可以订阅到的状态单元。Selector可以是同步也可以是异步。</p>
<h3 id="Atoms-共享状态"><a href="#Atoms-共享状态" class="headerlink" title="Atoms 共享状态"></a>Atoms 共享状态</h3><p>Atoms are units of state. They’re updateable and subscribable: when an atom is updated, each subscribed component is re-rendered with the new value. They can be created at runtime, too. Atoms can be used in place of React local component state. If the same atom is used from multiple components, all those components share their state.Atoms are created using the atom function:<br>Atoms就是状态单元，他们是可更新和可订阅的。一但某一个Atom更新，那么订阅他的组件就会得到新值重新渲染。这些Atoms可以在运行时被创建，也可在局部组件中使用。如果同一个Atom被多个组件使用，那么这些组件就会共享这个Atom.Atom可以通过Atom函数来创建：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fontSizeState = atom(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;fontSizeState&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">14</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Atoms need a unique key, which is used for debugging, persistence, and for certain advanced APIs that let you see a map of all atoms. It is an error for two atoms to have the same key, so make sure they’re globally unique. Like React component state, they also have a default value.<br>Atoms需要一个唯一的标示key,用于调试、数据持久化、和确保整个Atom整个系统高阶API正常运行。一旦有俩个Atoms有了相同的key就会报错，所以要确保这个标示全局唯一，就像React组件的状态一样，他们也有自己的默认值。</p>
<p>To read and write an atom from a component, we use a hook called <code>useRecoilState</code>. It’s just like React’s <code>useState</code>, but now the state can be shared between components:<br>在组件中开发Atom，会用到useRecoilState这个hooks函数。他就像React中的useState一样，但是运用Atom的hooks函数可以让状态在组件之间共享：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FontButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [fontSize, setFontSize] = useRecoilState(fontSizeState);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setFontSize((size) =&gt; size + 1)&#125; style=&#123;&#123;fontSize&#125;&#125;&gt;</span></span><br><span class="line"><span class="xml">                Click to Enlarge</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Clicking on the button will increase the font size of the button by one. But now some other component can also use the same font size:<br>点击按钮就会增加按钮中字体的大小，但是这样在其他组件中用到同样字体大小的时候，其他组件的字体大小也会变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Text</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [fontSize, setFontSize] = useRecoilState(fontSizeState);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize&#125;&#125;</span>&gt;</span>This text will increase in size too.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Selectors-纯函数"><a href="#Selectors-纯函数" class="headerlink" title="Selectors 纯函数"></a>Selectors 纯函数</h3><p>A selector is a pure function that accepts atoms or other selectors as input. When these upstream atoms or selectors are updated, the selector function will be re-evaluated. Components can subscribe to selectors just like atoms, and will then be re-rendered when the selectors change.<br>Selector是一个以Atom和其他的Selector为参数的纯函数。当这些上游的Atoms和Selector更新的时候。该Selecotor就会重新计算。组件也可以像Atom一样订阅Selector.当Selector发生变化的时候，组件也会被重新渲染。<br>Selectors are used to calculate derived data that is based on state. This lets us avoid redundant state, usually obviating the need for reducers to keep state in sync and valid. Instead, a minimal set of state is stored in atoms, while everything else is efficiently computed as a function of that minimal state. Since selectors keep track of what components need them and what state they depend on, they make this functional approach more efficient.<br>Selector被用来基于原始State的派生数据的计算。因为不需要使用 reducer 来保证数据的一致性和有效性，所以可以避免冗余数据。而是数据都是通过基于存储在Atom上的原始数据计算得到的。由于 Selector 会追踪使用它们的组件以及它们依赖的数据状态，所以函数式编程会比较高效。<br>From the point of view of components, selectors and atoms have the same interface and can therefore be substituted for one another.<br>因为 Seletor 和 Atom 给组件提供相同的方法，所以它们可以相互替代。<br>Selectors are defined using the selector function:<br>Selector可以通过Selector函数创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fontSizeLabelState = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;fontSizeLabelState&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fontSize = get(fontSizeState);</span><br><span class="line">        <span class="keyword">const</span> unit = <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;fontSize&#125;</span><span class="subst">$&#123;unit&#125;</span>`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>The <code>get</code> property is the function that is to be computed. It can access the value of atoms and other selectors using the <code>get</code> argument passed to it. Whenever it accesses another atom or selector, a dependency relationship is created such that updating the other atom or selector will cause this one to be recomputed.<br><code>get</code>属性是一个用于计算的函数。它可以使用入参 <code>get</code> 字段来访问输入的 Atom 和 Selector。当它访问其他 Atom 和 Selector 时，这层依赖关系会保证更新状态的同步。<br>In this fontSizeLabelState example, the selector has one dependency: the fontSizeState atom. Conceptually, the fontSizeLabelState selector behaves like a pure function that takes a fontSizeState as input and returns a formatted font size label as output.<br>In this <code>fontSizeLabelState</code> example, the selector has one dependency: the <code>fontSizeState</code> atom. Conceptually, the <code>fontSizeLabelState</code> selector behaves like a pure function that takes a <code>fontSizeLabelState</code> as input and returns a formatted font size label as output.<br>参考上述 <code>fontSizeLabelState</code> 示例，它依赖于 <code>fontSizeLabelState</code>使用 <code>fontSizeLabelState</code> 作为入参，并返回格式化之后的字号文本。<br>Selectors can be read using <code>useRecoilValue()</code>, which takes an atom or selector as an argument and returns the corresponding value. We don’t use the <code>useRecoilState()</code> as the <code>fontSizeLabelState</code> selector is not writeable see the <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/selector">selector API reference</a> for more information on writeable selectors):<br>我们可以通过在 <code>useRecoilValue()</code> 方法中输入 Atom 或者 Selector 来获取对应的数据。这里不用 <code>useRecoilState()</code> 是因为 <code>fontSizeLabelState</code> 是一个不可写 Selector，更多细节参考 <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/selector">Selector</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FontButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [fontSize, setFontSize] = useRecoilState(fontSizeState);</span><br><span class="line">    <span class="keyword">const</span> fontSizeLabel = useRecoilValue(fontSizeLabelState);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>Current font size: $&#123;fontSizeLabel&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setFontSize(fontSize + 1)&#125; style=&#123;&#123;fontSize&#125;&#125;&gt;</span></span><br><span class="line"><span class="xml">                Click to Enlarge</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Clicking on the button now does two things: it increases the font size of the button while also updating the font size label to reflect the current font size.<br>点击按钮可以看到按钮和文本的字号同时在更新。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/introduce/installation"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/introduce/installation/"
    >Recoil简介--安装教程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/introduce/installation/" class="article-date">
  <time datetime="2020-10-28T10:25:18.000Z" itemprop="datePublished">2020-10-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>The Recoil package lives in npm. To install the latest stable version, run the following command:<br>Recoil包已经发不到npm,可以通过下列命令安装最新的最稳定的版本：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> recoil</span><br></pre></td></tr></table></figure>
<p>或者是用yarn</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="builtin-name">add</span> recoil</span><br></pre></td></tr></table></figure>
<h3 id="Bundler"><a href="#Bundler" class="headerlink" title="Bundler"></a>Bundler</h3><p>Recoil installed via NPM pairs nicely with module bundlers such as Webpack or Rollup.<br>就像webpack或者Rollup一样，Recoil可以搭配模块坏bundlers通过npm安装。</p>
<h3 id="ES5-support-ES5支持"><a href="#ES5-support-ES5支持" class="headerlink" title="ES5 support ES5支持"></a>ES5 support ES5支持</h3><p>Recoil builds are not transpiled to ES5, and we do not support the use of Recoil with ES5. If you need to support browsers that do not provide ES6 features natively, you can do so by compiling your code with Babel and using preset @babel/preset-env. However, we do not support this and you may run into problems.<br>Recoil的构建不能转化支持ES5，所以我们并不建议使用ES5。如果你需要兼容不支持ES6的本地浏览器。你也可以通过安装@babel/preset-env插件的方式通过babel转译来实现，但是我们并不支持这么做，这可能会出现问题。</p>
<p>In particular, just like React, Recoil depends on the Map and Set types and other features of ES6. Emulation of these features using polyfills may result in far worse performance.<br>就像React一样，Recoil依赖于Map或者Set类型的ES6语法，但是如果通过使用polyfills来达到这一目的也许会得到事倍功半的效果。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>Since version 0.0.11, Recoil offers a UMD build that can be directly used in a <code>&lt;script&gt;</code> tag and exposes the symbol Recoil to the global namespace. We recommend linking to a specific version number and build to avoid unexpected breakage from newer versions:<br>从0.0.11版本开始，Recoil提供了UMD的构建方式，可以直接使用<code>&lt;script&gt;</code>标签,将Recoil暴露到全局。我们推荐引入一个具体版本，以免被收到新版本的影响。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/recoil@0.0.11/umd/recoil.production.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>You can browse all Recoil files on the CDN at <a target="_blank" rel="noopener" href="https://www.jsdelivr.com/package/npm/recoi">jsdelivr</a>.<br>可以 通过CDN下载所有有关<a target="_blank" rel="noopener" href="https://www.jsdelivr.com/package/npm/recoil">Recoil的资料</a>。</p>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>If you are using <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> in your project. For example, with an eslint config like this:<br>如果你在你的项目里使用了<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a>插件，例如，eslint的配置是这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// previous .eslint config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;react-hooks&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;react-hooks/exhaustive-deps&quot;</span>: <span class="string">&quot;warn&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is recommended to add <a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useRecoilCallback">‘useRecoilCallback’</a> to the list of additionalHooks. With this change, ESLint will warn when the dependencies passed to useRecoilCallback() are specified incorrectly and suggests a fix. The format of additionalHooks is a regex string.<br>推荐在运用hooks的列表中添加<a target="_blank" rel="noopener" href="https://recoiljs.org/docs/api-reference/core/useRecoilCallback"><code>useRecoilCallback</code></a>，有了这个操作，eslint就会在有参数传入<code>useRecoilCallback()</code>函数后执行检查是否正确，并提示修复。hooks的格式是一个正则表达式。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modified .eslint config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;react-hooks&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;react-hooks/exhaustive-deps&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;warn&quot;</span>, &#123;</span><br><span class="line">                <span class="attr">&quot;additionalHooks&quot;</span>: <span class="string">&quot;useRecoilCallback&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Nightly-Builds-Nightly构建"><a href="#Nightly-Builds-Nightly构建" class="headerlink" title="Nightly Builds Nightly构建"></a>Nightly Builds Nightly构建</h3><p>We build a package once every day based on the current master branch and publish it as the nightly branch on GitHub. You can use this branch via npm:<br>我们每天会依赖最新的master分支构建一次，并且以nightly分支发布到Github上，可以通过这个分支使用npm安装：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https:<span class="regexp">//gi</span>thub.com<span class="regexp">/facebookexperimental/</span>Recoil.git<span class="comment">#nightly</span></span><br></pre></td></tr></table></figure>
<p>yarn：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add https:<span class="regexp">//gi</span>thub.com<span class="regexp">/facebookexperimental/</span>Recoil.git<span class="comment">#nightly</span></span><br></pre></td></tr></table></figure>
<p>or add a dependency in package.json and run npm install or yarn:</p>
<p>或者是在package.json中添加依赖，并且通过命令<code>npm install</code> 或者<code>yarn</code>安装：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;recoil&quot;</span>: <span class="string">&quot;facebookexperimental/Recoil.git<span class="subst">#nightly</span>&quot;</span>,</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/introduce/introduce"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/introduce/introduce/"
    >Recoil简介</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/introduce/introduce/" class="article-date">
  <time datetime="2020-10-28T10:25:18.000Z" itemprop="datePublished">2020-10-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="Recoil"><a href="#Recoil" class="headerlink" title="Recoil"></a>Recoil</h3><p>A state management library for React。<br>recoil是react的状态管理库，他具备三大特点。</p>
<h3 id="Minimal-and-Reactish-简练并保持与-React-一致"><a href="#Minimal-and-Reactish-简练并保持与-React-一致" class="headerlink" title="Minimal and Reactish 简练并保持与 React 一致"></a>Minimal and Reactish 简练并保持与 React 一致</h3><p>Recoil works and thinks like React. Add some to your app and get fast and flexible shared state.<br>Recoil 的工作方式和原理与 React 完全一致，在React应用中添加Recoil能够快速，灵活的共享状态。</p>
<h3 id="Data-Flow-Graph-数据流"><a href="#Data-Flow-Graph-数据流" class="headerlink" title="Data-Flow Graph  数据流"></a>Data-Flow Graph  数据流</h3><p>Derived data and asynchronous queries are tamed with pure functions and efficient subscriptions.<br>纯函数和高效订阅为派生数据和异步查询提供支持。</p>
<h3 id="Cross-App-Observation-跨应用监听"><a href="#Cross-App-Observation-跨应用监听" class="headerlink" title="Cross-App Observation 跨应用监听"></a>Cross-App Observation 跨应用监听</h3><p>Implement persistence, routing, time-travel debugging, or undo by observing all state changes across your app, without impairing code-splitting.<br>不分割代码，通过对全局应用数据对监听，实现数据，路由，调试的持久化，或者是更改成为可能。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-recoil/introduce/motivation"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/recoil/introduce/motivation/"
    >Recoil简介--设计初衷</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/recoil/introduce/motivation/" class="article-date">
  <time datetime="2020-10-28T10:25:18.000Z" itemprop="datePublished">2020-10-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/recoil/">recoil</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="Motivation-初衷"><a href="#Motivation-初衷" class="headerlink" title="Motivation 初衷"></a>Motivation 初衷</h3><p>For reasons of compatibility and simplicity, it’s best to use React’s built-in state management capabilities rather than external global state. But React has certain limitations:<br>秉承简单与兼容性至上的原则，最好的状态管理方式当然是直接使用 React 内置能力而不是外部全部状态。然而 React 确实存在着一些问题：</p>
<ul>
<li>Component state can only be shared by pushing it up to the common ancestor, but this might include a huge tree that then needs to re-render.<br>组件状态只能与其祖先组件进行共享，这可能会带来组件树中大量的重绘开销。</li>
<li>Context can only store a single value, not an indefinite set of values each with its own consumers.<br>Context 只能保存一个特定值而不是与其 Consumer 共享一组不确定的值。</li>
<li>Both of these make it difficult to code-split the top of the tree (where the state has to live) from the leaves of the tree (where the state is used).<br>以上两点导致组件树顶部组件（状态生产者）与组件树底部组件（状态消费者）之间的代码拆分变得非常困难。</li>
</ul>
<p>We want to improve this while keeping both the API and the semantics and behavior as Reactish as possible.<br>我们希望在尽可能保持 React 代码风格和语义化的前提下解决以上问题。</p>
<p>Recoil defines a directed graph orthogonal to but also intrinsic and attached to your React tree. State changes flow from the roots of this graph (which we call atoms) through pure functions (which we call selectors) and into components. With this approach:<br>Recoil 在组件树中定义了一个正交且内聚的单向图谱。状态变更通过以下方法从图谱的底部（atoms）通过纯函数（selectors）进入组件：</p>
<ul>
<li>We get a boilerplate-free API where shared state has the same simple get/set interface as React local state (yet can be encapsulated with reducers etc. if needed).<br>我们提供了一些无依赖的方法，这些方法像 React 局部状态一样暴露相同的 get/set 接口（简单理解为 reducers 之类的概念亦可）。</li>
<li>We have the possibility of compatibility with Concurrent Mode and other new React features as they become available.<br>我们能够与一些 React 新功能（比如并发模式）兼容。</li>
<li>The state definition is incremental and distributed, making code-splitting possible.<br>状态定义是可伸缩和分布式的，代码拆分成为可能。</li>
<li>State can be replaced with derived data without modifying the components that use it.<br>不用修改组件即可派生数据状态。</li>
<li>Derived data can move between being synchronous and asynchronous without modifying the components that use it.<br>派生数据状态支持同步和异步。</li>
<li>We can treat navigation as a first-class concept, even encoding state transitions in links.<br>我们把跳转看作一级概念，甚至可以对链接中的状态流转进行编码。</li>
<li>It’s easy to persist the entire application state in a way that is backwards-compatible, so persisted states can survive application changes.<br>所以可以简单地使用向后兼容的方式来持久化整个应用的状态，应用变更时持久化状态也可以因此得以保留。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/recoil/" rel="tag">recoil</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> Lee
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Lee前端技术栈"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>