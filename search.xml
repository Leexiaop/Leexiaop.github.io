<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS-flex布局是什么</title>
    <url>/css/2/</url>
    <content><![CDATA[<p>说起flex布局，应该是我们比较熟悉的一种，但是有很多不常用的属性，我们还是需要总结一下：</p>
<h3 id="什么是flex布局"><a href="#什么是flex布局" class="headerlink" title="什么是flex布局"></a>什么是flex布局</h3><p>flex布局就是flexible box，就是弹性盒子的意思，也就是为盒子提供最大的灵活性。为任意的盒子指定flex布局：</p>
<ul>
<li>任意元素<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">container</span> &#123;</span><br><span class="line">    <span class="keyword">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>行内元素<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: <span class="keyword">inline</span>-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</code><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>采用flex布局的元素，称为容器，而容器中的子元素则称为项目。<br><img src="/css/2/flex-1.png" alt="flex布局"><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。<h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3></li>
<li>flex-direction </li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>flex-direction决定了主轴的方向，也就是项目排列的方向。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: <span class="keyword">column</span>-<span class="keyword">reverse</span> | <span class="keyword">column</span>| <span class="keyword">row</span> | <span class="keyword">row</span>-<span class="keyword">reverse</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>column-reverse沿着纵轴的负正方向排列;</p>
</li>
<li><p>column沿着纵轴方向负排列；</p>
</li>
<li><p>row (默认值)沿着横轴正方向排列；</p>
</li>
<li><p>row-reverse 沿着横轴的负方向排列；<br><img src="/css/2/flex-2.png" alt="flex布局"></p>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>flex-wrap表示容器中的项目是否换行。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-<span class="built_in">wrap</span>: nowrap | <span class="built_in">wrap</span> | <span class="built_in">wrap</span>-<span class="built_in">reverse</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/css/2/flex-3.png" alt="flex布局"></p>
</li>
<li><p>nowrap 不换行<br><img src="/css/2/flex-3-1.png" alt="flex布局"></p>
</li>
<li><p>wrap允许换行，第一行在上方。<br><img src="/css/2/flex-3-2.jpeg" alt="flex布局"></p>
</li>
<li><p>wrap-reverse 换行，第一行在下方。<br><img src="/css/2/flex-3-3.jpeg" alt="flex布局"></p>
</li>
</ul>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow是flex-direction 和flex-wrap的简写， 默认值为row和nowrap</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line">  flex-flow: <span class="params">&lt;flex-direction&gt;</span> || <span class="params">&lt;flex-wrap&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content属性表示沿主轴排列的对奇方式：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-<span class="keyword">end</span> | center | <span class="literal">space</span>-<span class="keyword">between</span> | <span class="literal">space</span>-<span class="keyword">around</span> | <span class="literal">space</span>-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>center剧中对其，</li>
<li>flex-start 左对齐</li>
<li>flex-end右对齐</li>
<li>space-between俩端对齐</li>
<li>space-around每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
<li>space-evenly 每个项目两侧的间隔以及同项目流两侧的间隔相等。<br><img src="/css/2/flex-4.png" alt="flex布局"></li>
</ul>
<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>align-items是表示其在交叉轴的对齐方式。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。<br><img src="/css/2/flex-5.png" alt="flex布局"><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">space</span>-between | <span class="type">space</span>-around | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self<h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line"><span class="symbol">  order:</span> <span class="params">&lt;integer&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/css/2/flex-7.png" alt="flex布局"><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/css/2/flex-8.png" alt="flex布局"><br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小.<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;<span class="symbol">&#x27;flex</span>-grow&#x27;&gt; &lt;<span class="symbol">&#x27;flex</span>-shrink&#x27;&gt;? || &lt;<span class="symbol">&#x27;flex</span>-basis&#x27;&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: <span class="built_in">auto</span> | <span class="type">flex</span>-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/css/2/flex-10.png" alt="flex布局"><br>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。<br>(That’s all!)</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS--BFC模型是什么</title>
    <url>/css/5/</url>
    <content><![CDATA[<p>编写中，敬请期待。。。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS--table布局是什么</title>
    <url>/css/4/</url>
    <content><![CDATA[<p>编写中，敬请期待。。。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS--盒子模型</title>
    <url>/css/1/</url>
    <content><![CDATA[<p>编写中，敬请期待。。。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS--grid布局是什么</title>
    <url>/css/3/</url>
    <content><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>grid布局是css中最强大的布局之一，他是将网页分割成网状结构，即一个个网格项目，现在已经内置到浏览器。grid布局和flex布局有几分相似，flex是轴线布局。只能针对项目的轴线布局，可以看作是<code>一维布局</code>，Grid布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目”所在的单元格，可以看作是<code>二维布局</code>。Grid 布局远比Flex 布局强大。下面的布局是grid布局的拿手好戏：<br><img src="/css/3/grid-1.png" alt="grid布局"></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在了解grid布局之前，先说一些基本概念：</p>
<ul>
<li><p>容器和项目<br>容器：采用网格布局的区域，被叫做“容器”；<br>项目：容器内部采用网格定位的子元素（必须是子元素），称为”项目”。Grid 布局只对项目生效。</p>
</li>
<li><p>行，列和单元格<br>行：容器中水平方向的区域称为行；<br>列：容器中垂直方向的区域称为列；<br>单元格：行和列相交就是单元格，一般情况下单元格=m行*n列。<br><img src="/css/3/grid-2.png" alt="grid布局"></p>
</li>
<li><p>网格<br>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。<br>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。<br><img src="/css/3/grid-3.png" alt="grid布局"><br>grid布局的属性分为俩种，一种是容器属性，一种是项目属性。</p>
<h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><p>display: grid; //  指定容器采用grid布局<br>display: inline-grid;  //  指定容器采用内成行内grid布局。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">container</span> &#123;</span><br><span class="line">    <span class="keyword">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/css/3/grid-4.png" alt="grid布局"></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: <span class="keyword">inline</span>-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/css/3/grid-5.png" alt="grid布局"><br><code>注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</code></p>
</li>
</ul>
<h4 id="grid-template-columns-属性，grid-template-rows-属性"><a href="#grid-template-columns-属性，grid-template-rows-属性" class="headerlink" title="grid-template-columns 属性，grid-template-rows 属性"></a>grid-template-columns 属性，grid-template-rows 属性</h4><p>从字面意思就可以看出是和列和行有关的属性，没错，grid-template-columns用来指定容器中列的宽度，grid-template-rows用来指定容器中行的高度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用觉得单位，也可以使用相对单位，百分比等。<br><img src="/css/3/grid-6.png" alt="grid布局"></p>
<ul>
<li><p>repeat()<br>有时候列或者行比较多的时候，重复写比较麻烦，所以提供了repeat方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">100px</span>);</span><br><span class="line">    grid-template-rows: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。repeat也可以重复某种模式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100</span>rpx, <span class="number">80</span>rpx, <span class="number">30</span>rpx);</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了六列，第一列和第四列宽100px,以此类推。</p>
</li>
<li><p>auto-fill 关键字<br>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/css/3/grid-7.png" alt="grid布局"></p>
</li>
<li><p>fr 关键字<br>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fr可以与绝对长度的单位结合使用，这时会非常方便。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一列的宽度为150像素，第二列的宽度是第三列的一半。<br><img src="/css/3/grid-9.png" alt="grid布局"></p>
</li>
<li><p>minmax()<br>minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。</p>
</li>
<li><p>auto 关键字</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。</p>
</li>
<li><p>网格线的名称<br>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">container</span> &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: <span class="comment">[c1]</span> 100px <span class="comment">[c2]</span> 100px <span class="comment">[c3]</span> auto <span class="comment">[c4]</span>;</span><br><span class="line">    grid-template-rows: <span class="comment">[r1]</span> 100px <span class="comment">[r2]</span> 100px <span class="comment">[r3]</span> auto <span class="comment">[r4]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>布局实例<br>grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">wrapper</span> &#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-<span class="keyword">template</span>-<span class="keyword">columns</span>: <span class="number">70</span>% <span class="number">30</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将左边栏设为70%，右边栏设为30%。<br>栅格布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="grid-row-gap-属性，grid-column-gap-属性，grid-gap-属性"><a href="#grid-row-gap-属性，grid-column-gap-属性，grid-gap-属性" class="headerlink" title="grid-row-gap 属性，grid-column-gap 属性，grid-gap 属性"></a>grid-row-gap 属性，grid-column-gap 属性，grid-gap 属性</h4><p>gap意思为间距的意思，所以见字得意，grid-row-gap, grid-column-gap,grid-gap都是设置间距的意思，分别是行间距，列间距，以及二者的简写。<code>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</code><br><img src="/css/3/grid-10.png" alt="grid布局"></p>
<h4 id="grid-template-areas-属性"><a href="#grid-template-areas-属性" class="headerlink" title="grid-template-areas 属性"></a>grid-template-areas 属性</h4><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-areas: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                        <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                        <span class="string">&#x27;g h i&#x27;</span>;</span><br><span class="line">    // grid-template-areas: <span class="string">&#x27;a a a&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;b b b&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;c c c&#x27;</span>;</span><br><span class="line">    //  grid-template-areas: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                        <span class="string">&quot;main main sidebar&quot;</span></span><br><span class="line">                        <span class="string">&quot;footer footer footer&quot;</span>;</span><br><span class="line">    //  grid-template-areas: <span class="string">&#x27;a . c&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;d . f&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;g . i&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间一列点表示没有用到该单元格，或者该单元格不属于任何区域。<br><code>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。</code></p>
</li>
</ul>
<h4 id="grid-auto-flow-属性"><a href="#grid-auto-flow-属性" class="headerlink" title="grid-auto-flow 属性"></a>grid-auto-flow 属性</h4><p>这个属性决定了容器中的项目的排列方式，默认情况下的值是row.既是按照行排列，先填满第一行，再第二行。</p>
<ul>
<li>row<br><img src="/css/3/grid-6.png" alt="grid布局"></li>
<li>column<br><img src="/css/3/grid-11.png" alt="grid布局"></li>
<li>row dense:先行后列，并且尽可能紧密填满，尽量不出现空格。<br><img src="/css/3/grid-12.png" alt="grid布局"></li>
<li>column dense:先列后行，并且尽量填满空格。<br><img src="/css/3/grid-13.png" alt="grid布局"><h4 id="justify-items-属性，align-items-属性，place-items-属性"><a href="#justify-items-属性，align-items-属性，place-items-属性" class="headerlink" title="justify-items 属性，align-items 属性，place-items 属性"></a>justify-items 属性，align-items 属性，place-items 属性</h4>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    justify-items: start | <span class="type">end</span> | <span class="type">center</span> | <span class="type">stretch</span>;</span><br><span class="line">    align-items: start | <span class="type">end</span> | <span class="type">center</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">container</span> &#123;</span><br><span class="line">    justify-items: <span class="literal">start</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/css/3/grid-14.png" alt="grid布局"><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/css/3/grid-15.png" alt="grid布局"><br>place-items属性是align-items属性和justify-items属性的合并简写形式。<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">container</span> &#123;</span><br><span class="line">    place-items: <span class="literal">start</span> <span class="literal">start</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="justify-content-属性，align-content-属性，place-content-属性"><a href="#justify-content-属性，align-content-属性，place-content-属性" class="headerlink" title="justify-content 属性，align-content 属性，place-content 属性"></a>justify-content 属性，align-content 属性，place-content 属性</h4>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    justify-content: start | <span class="keyword">end</span> | center | stretch | <span class="literal">space</span>-<span class="keyword">around</span> | <span class="literal">space</span>-<span class="keyword">between</span> | <span class="literal">space</span>-evenly;</span><br><span class="line">    align-content: start | <span class="keyword">end</span> | center | stretch | <span class="literal">space</span>-<span class="keyword">around</span> | <span class="literal">space</span>-<span class="keyword">between</span> | <span class="literal">space</span>-evenly;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>start - 对齐容器的起始边框。<br><img src="/css/3/grid-16.png" alt="grid布局"></li>
<li>end - 对齐容器的结束边框。<br><img src="/css/3/grid-17.png" alt="grid布局"></li>
<li>center - 容器内部居中。<br><img src="/css/3/grid-18.png" alt="grid布局"></li>
<li>stretch - 项目大小没有指定时，拉伸占据整个网格容器.<br><img src="/css/3/grid-19.png" alt="grid布局"></li>
<li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。<br><img src="/css/3/grid-20.png" alt="grid布局"></li>
<li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。<br><img src="/css/3/grid-21.png" alt="grid布局"></li>
<li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。<br><img src="/css/3/grid-22.png" alt="grid布局"></li>
</ul>
<p>place-content属性是align-content属性和justify-content属性的合并简写形式.</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">place-<span class="built_in">content</span>: &lt;align-<span class="built_in">content</span>&gt; &lt;justify-<span class="built_in">content</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="grid-auto-columns-属性，grid-auto-rows-属性"><a href="#grid-auto-columns-属性，grid-auto-rows-属性" class="headerlink" title="grid-auto-columns 属性，grid-auto-rows 属性"></a>grid-auto-columns 属性，grid-auto-rows 属性</h4><p>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-<span class="attribute">auto</span>-rows: <span class="number">50px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/css/3/grid-23.png" alt="grid布局"></p>
<h4 id="grid-template-属性，grid-属性"><a href="#grid-template-属性，grid-属性" class="headerlink" title="grid-template 属性，grid 属性"></a>grid-template 属性，grid 属性</h4><p>grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。</p>
<p>grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
<h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><h4 id="grid-column-start-属性，grid-column-end-属性，grid-row-start-属性，grid-row-end-属性"><a href="#grid-column-start-属性，grid-column-end-属性，grid-row-start-属性，grid-row-end-属性" class="headerlink" title="grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性"></a>grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性</h4><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p>
<ul>
<li>grid-column-start属性：左边框所在的垂直网格线</li>
<li>grid-column-end属性：右边框所在的垂直网格线</li>
<li>grid-row-start属性：上边框所在的水平网格线</li>
<li>grid-row-end属性：下边框所在的水平网格线<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">.item<span class="number">-1</span> &#123;</span><br><span class="line">    grid-<span class="keyword">column</span>-<span class="keyword">start</span>: <span class="number">2</span>;</span><br><span class="line">    grid-<span class="keyword">column</span>-<span class="keyword">end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。<br><img src="/css/3/grid-24.png" alt="grid布局"><br>只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</li>
</ul>
<p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">.item<span class="number">-1</span> &#123;</span><br><span class="line">    grid-<span class="keyword">column</span>-<span class="keyword">start</span>: <span class="number">1</span>;</span><br><span class="line">    grid-<span class="keyword">column</span>-<span class="keyword">end</span>: <span class="number">3</span>;</span><br><span class="line">    grid-<span class="keyword">row</span>-<span class="keyword">start</span>: <span class="number">2</span>;</span><br><span class="line">    grid-<span class="keyword">row</span>-<span class="keyword">end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/css/3/grid-25.png" alt="grid布局"><br>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">.item<span class="number">-1</span> &#123;</span><br><span class="line">    grid-<span class="keyword">column</span>-<span class="keyword">start</span>: <span class="keyword">header</span>-<span class="keyword">start</span>;</span><br><span class="line">    grid-<span class="keyword">column</span>-<span class="keyword">end</span>: <span class="keyword">header</span>-<span class="keyword">end</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">.item<span class="number">-1</span> &#123;</span><br><span class="line">    grid-<span class="keyword">column</span>-<span class="keyword">start</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/css/3/grid-26.png" alt="grid布局"><br>使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序</p>
<h4 id="grid-column-属性，grid-row-属性"><a href="#grid-column-属性，grid-row-属性" class="headerlink" title="grid-column 属性，grid-row 属性"></a>grid-column 属性，grid-row 属性</h4><p>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">.item<span class="number">-1</span> &#123;</span><br><span class="line">    grid-<span class="keyword">column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">    grid-<span class="keyword">row</span>: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line">.item<span class="number">-1</span> &#123;</span><br><span class="line">    grid-<span class="keyword">column</span>-<span class="keyword">start</span>: <span class="number">1</span>;</span><br><span class="line">    grid-<span class="keyword">column</span>-<span class="keyword">end</span>: <span class="number">3</span>;</span><br><span class="line">    grid-<span class="keyword">row</span>-<span class="keyword">start</span>: <span class="number">1</span>;</span><br><span class="line">    grid-<span class="keyword">row</span>-<span class="keyword">end</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">    grid-column: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">    grid-row: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">    grid-column: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">    grid-row: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/css/3/grid-27.png" alt="grid布局"><br>斜杠以及后面的部分可以省略，默认跨越一个网格。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">.item-<span class="number">1</span> &#123;</span><br><span class="line">    <span class="built_in">grid</span>-column: <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">grid</span>-<span class="built_in">row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="grid-area-属性"><a href="#grid-area-属性" class="headerlink" title="grid-area 属性"></a>grid-area 属性</h4><p>grid-area属性指定项目放在哪一个区域.</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">item</span><span class="number">-1</span> &#123;</span><br><span class="line">    grid-area: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/css/3/grid-28.png" alt="grid"><br>grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">    grid-area: &lt;<span class="keyword">row</span>-<span class="keyword">start</span>&gt; / &lt;<span class="keyword">column</span>-<span class="keyword">start</span>&gt; / &lt;<span class="keyword">row</span>-<span class="keyword">end</span>&gt; / &lt;<span class="keyword">column</span>-<span class="keyword">end</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="justify-self-属性，align-self-属性，place-self-属性"><a href="#justify-self-属性，align-self-属性，place-self-属性" class="headerlink" title="justify-self 属性，align-self 属性，place-self 属性"></a>justify-self 属性，align-self 属性，place-self 属性</h4><p>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p>
<p>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">    justify-self: start | <span class="type">end</span> | <span class="type">center</span> | <span class="type">stretch</span>;</span><br><span class="line">    align-self: start | <span class="type">end</span> | <span class="type">center</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>  &#123;</span><br><span class="line">    justify-self: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/css/3/grid-29.png" alt="grid布局"><br>place-self属性是align-self属性和justify-self属性的合并简写形式。<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">place-<span class="literal">self</span>: &lt;align-<span class="literal">self</span>&gt; &lt;justify-<span class="literal">self</span>&gt;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>基础排序算法总结</title>
    <url>/algorithm/12/</url>
    <content><![CDATA[<p>前面说完了十种基础排序，是时候做一个总结了。排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。<br><img src="/algorithm/12/1.png" alt="基础排序算法"><br><img src="/algorithm/12/2.png" alt="基础排序算法"><br>所以选择方法，还是要选择稳定的，时间复杂度和空间复杂度低的方法。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(十)--堆排序</title>
    <url>/algorithm/11/</url>
    <content><![CDATA[<p>堆排序思想：堆排序（HeapSort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ul>
<p>堆排序的平均时间复杂度为 Ο(nlogn)。<br>算法步骤：</p>
<ul>
<li>创建一个堆 H[0……n-1]；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li>
<li>重复步骤 2，直到堆的尺寸为 1。</li>
</ul>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">// 因为声明的多个函数都需要数据长度，所以把<span class="built_in">len</span>设置成为全局变量</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">len</span></span><br><span class="line"><span class="built_in">var</span> buildMaxHeap = (arr) =&gt; &#123;   // 建立大顶堆</span><br><span class="line">    <span class="built_in">len</span> = arr.length;</span><br><span class="line">    for (<span class="built_in">var</span> i = Math.floor(<span class="built_in">len</span>/<span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> heapify = (arr, i) =&gt; &#123;     // 堆调整</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">left</span> = <span class="number">2</span> * i + <span class="number">1</span>,</span><br><span class="line">        <span class="built_in">right</span> = <span class="number">2</span> * i + <span class="number">2</span>,</span><br><span class="line">        largest = i;</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">left</span> &lt; <span class="built_in">len</span> &amp;&amp; arr[<span class="built_in">left</span>] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = <span class="built_in">left</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">right</span> &lt; <span class="built_in">len</span> &amp;&amp; arr[<span class="built_in">right</span>] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = <span class="built_in">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">if</span> (largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> swap = (arr, i, j) =&gt; &#123;</span><br><span class="line">    <span class="built_in">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> heapSort = (arr) =&gt; &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"></span><br><span class="line">    for (<span class="built_in">var</span> i = arr.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        <span class="built_in">len</span>--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> arr1=[<span class="number">8</span>,<span class="number">39</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">20</span>,<span class="number">44</span>,<span class="number">440</span>];</span><br><span class="line">console.log(heapSort(arr1))</span><br><span class="line">//  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">20</span>,<span class="number">39</span>,<span class="number">44</span>,<span class="number">400</span>,<span class="number">440</span>,<span class="number">500</span>]</span><br></pre></td></tr></table></figure>
<p>注：堆排序对堆知识的要求比较高。但是思想相对简单。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(九)--桶排序</title>
    <url>/algorithm/10/</url>
    <content><![CDATA[<p>桶排序的思想：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br>元素分布在桶中：<br><img src="/algorithm/10/1.png" alt="桶排序--1"><br>元素在每个桶中排序<br><img src="/algorithm/10/2.png" alt="桶排序--2"><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  默认bucketSize = 5，默认分5个桶</span></span><br><span class="line">var bucketSort = (arr, bucketSize = <span class="number">5</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.<span class="built_in">length</span>) <span class="keyword">return</span></span><br><span class="line">    let <span class="built_in">min</span> = arr[<span class="number">0</span>]</span><br><span class="line">    let <span class="built_in">max</span> = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">//  用来装桶的桶</span></span><br><span class="line">    let list = []</span><br><span class="line">    <span class="comment">//  返回的结果</span></span><br><span class="line">    let result = []</span><br><span class="line">    <span class="comment">//  获取数组中的最小值和最大值</span></span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">1</span>; i &lt; arr.<span class="built_in">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">max</span> = arr[i] &lt;= <span class="built_in">max</span> ? <span class="built_in">max</span> : arr[i]</span><br><span class="line">        <span class="built_in">min</span> = arr[i] &gt;= <span class="built_in">min</span> ? <span class="built_in">min</span> : arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  桶的数量为bucketCount</span></span><br><span class="line">    let bucketCount = (<span class="built_in">max</span> - <span class="built_in">min</span>)/bucketSize</span><br><span class="line">    <span class="keyword">for</span> (let a = <span class="number">0</span>; a &lt; arr.<span class="built_in">length</span>; a++) &#123;</span><br><span class="line">        <span class="comment">//  获取桶的编号</span></span><br><span class="line">        let <span class="keyword">index</span> = Math.<span class="built_in">floor</span>((arr[a] - <span class="built_in">min</span>)/bucketCount)</span><br><span class="line">        <span class="keyword">if</span> (list[<span class="keyword">index</span>]) &#123;</span><br><span class="line">            let k = list[<span class="keyword">index</span>].<span class="built_in">length</span> - <span class="number">1</span></span><br><span class="line">            <span class="comment">//  对桶进行排序</span></span><br><span class="line">            <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; list[<span class="keyword">index</span>][k] &gt; arr[a]) &#123;</span><br><span class="line">                <span class="comment">//  桶前面的数字放到后面去</span></span><br><span class="line">                list[<span class="keyword">index</span>][k + <span class="number">1</span>] = list[<span class="keyword">index</span>][k]</span><br><span class="line">                k--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  不用排序的，直接加在桶的最后面</span></span><br><span class="line">            list[<span class="keyword">index</span>][k+<span class="number">1</span>] = arr[a]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  没有值则生成桶，并把值放到对应的桶中</span></span><br><span class="line">            list[<span class="keyword">index</span>]=[];</span><br><span class="line">            list[<span class="keyword">index</span>][<span class="number">0</span>]=arr[a]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (n &lt;= bucketSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[n]) &#123;</span><br><span class="line">            result = result.concat(list[n])</span><br><span class="line">        &#125;</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">arr = [<span class="number">43</span>, <span class="number">25</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">37</span>, <span class="number">25</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">49</span>]</span><br><span class="line">console.<span class="built_in">log</span>(bucketSort(arr))</span><br><span class="line"><span class="comment">//  [3, 9, 21, 25, 25, 29, 37, 43, 49]</span></span><br></pre></td></tr></table></figure>
注：桶排序是一种思想，实际中并不常用。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法--反转整数</title>
    <url>/algorithm/13/</url>
    <content><![CDATA[<p>题目：给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−2<sup>31</sup>,  2<sup>31</sup> − 1] ，就返回 0。</p>
<p>解析：分析题目中的点。</p>
<ul>
<li>整数，可以是正数，也可以是负数，这里需要注意负号；</li>
<li>反转后的结果有范围，注意范围，越界返回是0.</li>
</ul>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> reserve = (x) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> x</span><br><span class="line">    let neg = x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span></span><br><span class="line">    let <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    x *= neg</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">str</span> += x % <span class="number">10</span></span><br><span class="line">        x = parseInt(x / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">str</span> &lt;= <span class="number">-2147483648</span></span><br><span class="line">        || <span class="built_in">str</span> &gt;= <span class="number">2147483647</span>) &#123;</span><br><span class="line">            <span class="built_in">str</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span> * neg</span><br><span class="line">&#125;</span><br><span class="line">reserve(<span class="number">123</span>)</span><br><span class="line"><span class="comment">//  321</span></span><br><span class="line">reserve(<span class="number">-321</span>)</span><br><span class="line"><span class="comment">//  -123</span></span><br><span class="line">reserve(<span class="number">2147483648</span>)</span><br><span class="line"><span class="comment">//  0</span></span><br></pre></td></tr></table></figure>
<p>注意：这里应该有一个优化的地方，就是越界的比较，其实并不需要比较2<sup>31</sup>次方。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法--回文数</title>
    <url>/algorithm/14/</url>
    <content><![CDATA[<p>题目：给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p>
<p>解析：分析题目中的点。</p>
<ul>
<li>负数不是回文数<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">var isPalindrome = function(x) &#123;</span><br><span class="line">    x = x.toString()</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> false</span><br><span class="line">    <span class="keyword">let</span> isTrue = false</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">right</span> = x.length - <span class="number">1</span></span><br><span class="line">    while (<span class="built_in">left</span> &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">        isTrue = x[<span class="built_in">left</span>] === x[<span class="built_in">right</span>]</span><br><span class="line">        <span class="built_in">left</span>++</span><br><span class="line">        <span class="built_in">right</span>--</span><br><span class="line">        <span class="keyword">if</span> (!isTrue) <span class="keyword">return</span> isTrue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isTrue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
That’s all!整体思路就是从俩边向中间循环，只要遇到不相等就跳出循环返回false。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法--求俩数之和</title>
    <url>/algorithm/1/</url>
    <content><![CDATA[<p>题目：给定一个数组nums和一个目标值target,从数组中找到俩个元素的和等于目标值target，并返回这俩个元素的位置。<br>思路一：暴力算法，将数组中的俩个元素相加，如果等于目标值target，那么返回其位置。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">let <span class="function"><span class="keyword">fun</span> = <span class="params">(nums, target)</span></span> =&gt; &#123;</span><br><span class="line">    let result = []</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (let j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                result.push(i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>1,这里需要注意的是循环的边界值，i &lt; nums.length - 1, j &lt; nums.length<br>2,因为做了俩层循环，所以时间复杂度是O(n<sup>2</sup>),声明了三个变量，空间复杂度是O(n)</p>
<p>思路二：由于上面的暴力算法时间复杂度比较高，所以我们可以再时间复杂度上做一点优化，我们可不可以将时间复杂度降低到O(N)呢？当然是可以的，对于每一个 nums[ i ]，我们首先查询哈希表中是否存在 target - nums[ i ]，然后将 nums[ i ] 插入到哈希表中，即可保证不会让 nums[ i ] 和自己匹配。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> fun = (nums, target) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> result = []</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">map</span> = <span class="built_in">new</span> Map()</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">map</span>.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">length</span>;i++) &#123;</span><br><span class="line">        <span class="built_in">let</span> item = target - nums[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.has(item) &amp;&amp; <span class="built_in">map</span>.<span class="built_in">get</span>(item) !== i) &#123;</span><br><span class="line">            result.<span class="built_in">push</span>(i);</span><br><span class="line">            result.<span class="built_in">push</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(item))</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>我们首先创建了一个map结构，用来保存数组中的元素和位置，作为哈希表。然后按照思路二来实现。遍历一次，也降低了时间复杂度。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法--罗马数字转整数</title>
    <url>/algorithm/15/</url>
    <content><![CDATA[<p>题目：将罗马数字转为整数，罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。对应结构为：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">字符  数值</span><br><span class="line"><span class="built_in">I</span>     <span class="number">1</span></span><br><span class="line"><span class="variable">V</span>     <span class="number">5</span></span><br><span class="line"><span class="variable">X</span>     <span class="number">10</span></span><br><span class="line"><span class="variable">L</span>     <span class="number">50</span></span><br><span class="line"><span class="built_in">C</span>     <span class="number">100</span></span><br><span class="line"><span class="built_in">D</span>     <span class="number">500</span></span><br><span class="line"><span class="variable">M</span>     <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>例如：罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II。下面情况为特殊情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>解析：看到这个题，我突然就想到了选择排序的思想。我们通过记住当前位置的值，比较相邻位置的大小来决定计算方式，是加还是减。就这么简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> roman = &#123; <span class="attr">I</span>:<span class="number">1</span>, <span class="attr">V</span>:<span class="number">5</span>, <span class="attr">X</span>:<span class="number">10</span>, <span class="attr">L</span>:<span class="number">50</span>, <span class="attr">C</span>:<span class="number">100</span>, <span class="attr">D</span>:<span class="number">500</span>, <span class="attr">M</span>:<span class="number">1000</span> &#125;</span><br><span class="line"><span class="keyword">var</span> romanToInt = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> pre = roman[s[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> num = roman[s[i]]</span><br><span class="line">        <span class="comment">//  这里为特殊情况说明是左边比右边小</span></span><br><span class="line">        <span class="keyword">if</span> (pre &lt; num) &#123;</span><br><span class="line">            sum -= pre</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += pre</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新pre的值</span></span><br><span class="line">        pre = num</span><br><span class="line">    &#125;</span><br><span class="line">    sum += pre</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(romanToInt(<span class="string">&#x27;III&#x27;</span>)) <span class="comment">//    3</span></span><br><span class="line"><span class="built_in">console</span>.log(romanToInt(<span class="string">&#x27;IV&#x27;</span>)) <span class="comment">//    4</span></span><br></pre></td></tr></table></figure>
<p>That’s all!十大基础算法是重点，这就是九阳神功内功心法，一通百通。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法--判断括号是否有效</title>
    <url>/algorithm/17/</url>
    <content><![CDATA[<p>题目：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ul>
<p>解析：因为括号是成对出现的，所以，我们首先可以判断一下长度，如果是奇数，那么直接返回false。其次，我们很容易就可以想到栈的思想，因为栈的特点是先进后出。所以，我们可以栈的近出，来比对是否是有效字符串。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过字典来存储括号对</span></span><br><span class="line"><span class="keyword">const</span> dic = &#123;<span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>&#125;</span><br><span class="line">var isValid = function(s) &#123;</span><br><span class="line">    <span class="comment">//  判断字符串是不是奇数</span></span><br><span class="line">    <span class="keyword">if</span> (!s || s.length % <span class="number">2</span> !==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">    let stack = []</span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">key</span> of s) &#123;</span><br><span class="line">        <span class="comment">//  如果是向右侧的括号押入栈中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> === <span class="string">&#x27;&#123;&#x27;</span> || <span class="built_in">key</span> === <span class="string">&#x27;(&#x27;</span> || <span class="built_in">key</span> === <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            stack.push(<span class="built_in">key</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//  如果栈为空，说明括号对缺乏向右侧的半边，返回false</span></span><br><span class="line">            <span class="comment">//  依次出栈与入栈不同，那么就返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.length || stack.pop() !== dic[<span class="built_in">key</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  最终如果栈为空，那么字符串是有效的返回true</span></span><br><span class="line">    <span class="keyword">return</span> !stack.length</span><br><span class="line">&#125;</span><br><span class="line">isValid(<span class="string">&#x27;[()]&#123;&#125;&#x27;</span>)   <span class="comment">//  true</span></span><br></pre></td></tr></table></figure>
<p>注：利用不同数据结构，本题中主要是利用栈结构的原理，相对比较简单。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--删除数组中的指定元素</title>
    <url>/algorithm/19/</url>
    <content><![CDATA[<p>题目：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>解析：看到这个题，与上一个删除有序数组中的重复元素，很相似，只不过这次要删除的元素被指定了，而且数组也不是有序的，但是实现起来要比之前简单，看代码：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">var removeDuplicates = <span class="keyword">function</span>(nums, <span class="keyword">val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== <span class="keyword">val</span>) &#123;</span><br><span class="line">            nums[j] = nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--删除有序数组中重复的元素</title>
    <url>/algorithm/18/</url>
    <content><![CDATA[<p>题目：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>分析：给定一个有序的数组，删除重复元素，看到这个条件，我就能突然想到了冒泡排序，那么自然而然的就有了双指针的思路。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> ( nums &amp;&amp; nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums.length) &#123;</span><br><span class="line">        <span class="comment">// 如果前一个和后一个不相等</span></span><br><span class="line">        <span class="comment">//  那么就说明这俩个元素不重复，i++</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== nums[j]) &#123;</span><br><span class="line">            nums[i+<span class="number">1</span>] = nums[j]</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        j++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">removeDuplicates([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="comment">//  5</span></span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法--求字符串最长公共前缀</title>
    <url>/algorithm/16/</url>
    <content><![CDATA[<p>题目：给定一个数组，其元素是由如果干个字符串组成，那么请找到他们从开始起的最长公共元素，如果没有返回空。例如[‘flower’, ‘flow’, ‘flor’], 则返回flo。<br>解析：看到这个题，不知道你是不是就想到了十大基础排序中的选择排序的思想，我们只需要通过选择排序的思想比较第一轮即可。比如拿出数组中的第一个元素，然后与后面的相比即可得出结果。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> longestCommonPrefix = (arr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr) <span class="built_in">return</span> &#x27;&#x27;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">length</span> &lt;= <span class="number">1</span>) <span class="built_in">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">let</span> pod = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; pod.<span class="built_in">length</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">let</span> j = <span class="number">0</span></span><br><span class="line">        <span class="built_in">let</span> isTrue = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; arr.<span class="built_in">length</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j][i] !== pod[i]) &#123;</span><br><span class="line">                isTrue = <span class="literal">false</span></span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTrue) <span class="built_in">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> pod.<span class="built_in">substring</span>(<span class="number">0</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">longestCommonPrefix([<span class="string">&quot;flower&quot;</span>,<span class="string">&quot;flow&quot;</span>,<span class="string">&quot;flight&quot;</span>])</span><br><span class="line">//  <span class="string">&quot;fl&quot;</span></span><br></pre></td></tr></table></figure>
<p>注：思想很简单，当然这也是建立在都是LeeCode上简单题的基础上，这里有个坑切记，for循环中变量i不能用let声明，要用var生明。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--验证是不是回文字符串</title>
    <url>/algorithm/21/</url>
    <content><![CDATA[<p>题目：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。本题中将空字符串,标点符号定义为有效回文字符串。</p>
<p>分析：注意这里的坑。</p>
<ul>
<li>1.忽略大小写，那么就需要统一字符串中每一个字符，要不都答谢大写，要么都小写；</li>
<li>2.将空字符串作为有效字符串，那么意味着需要将空字符串,标点符号跳过。<br>看代码：<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var isPalindrome = <span class="keyword">function</span>(s) &#123;</span><br><span class="line">    <span class="comment">//  将字符串统一转成小写</span></span><br><span class="line">    s = s.<span class="keyword">to</span><span class="constructor">LocaleLowerCase()</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> isTrue = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//  只考虑数字和字母，如果不是数字和字母，则跳过</span></span><br><span class="line">    <span class="keyword">let</span> reg = /^<span class="literal">[<span class="number">0</span>-<span class="number">9</span><span class="identifier">a</span>-<span class="identifier">zA</span>-Z]</span>+$/</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!reg.test(s<span class="literal">[<span class="identifier">left</span>]</span>)<span class="operator"> ||</span></span><br><span class="line"><span class="operator">            </span>!reg.test(s<span class="literal">[<span class="identifier">right</span>]</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!reg.test(s<span class="literal">[<span class="identifier">left</span>]</span>)) &#123;</span><br><span class="line">                left++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!reg.test(s<span class="literal">[<span class="identifier">right</span>]</span>)) &#123;</span><br><span class="line">                right--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isTrue = s<span class="literal">[<span class="identifier">left</span>]</span><span class="operator"> === </span>s<span class="literal">[<span class="identifier">right</span>]</span></span><br><span class="line">        <span class="keyword">if</span>(isTrue) &#123;</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isTrue = <span class="literal">false</span></span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isTrue</span><br><span class="line">&#125;;</span><br><span class="line">is<span class="constructor">Palindrome(&#x27;0P&#x27;)</span>  <span class="comment">// false</span></span><br><span class="line">is<span class="constructor">Palindrome(&#x27;A <span class="params">man</span>, <span class="params">a</span> <span class="params">plan</span>, <span class="params">a</span> <span class="params">canal</span>: Panama&#x27;)</span>  <span class="comment">// true</span></span><br><span class="line">is<span class="constructor">Palindrome(&#x27;<span class="params">race</span> <span class="params">a</span> <span class="params">car</span>&#x27;)</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
Yes, that’s all!</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--返回最后一个单词的长度</title>
    <url>/algorithm/22/</url>
    <content><![CDATA[<p>题目：给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。<br><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<p>分析：此题中唯一需要注意的就是空字符串的问题，包括，一个空字符串，或者最后有一个空。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  先将字符串通过空转化成数组</span></span><br><span class="line">    <span class="keyword">let</span> arr = s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> len = <span class="number">0</span></span><br><span class="line">    <span class="comment">//  注意i&gt;=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="comment">//  判断后面第一个不是空</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i]) &#123;</span><br><span class="line">            len = arr[i].length</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len</span><br><span class="line">&#125;</span><br><span class="line">lengthOfLastWord(<span class="string">&quot;hello world &quot;</span>) <span class="comment">// 5</span></span><br><span class="line">lengthOfLastWord(<span class="string">&quot; &quot;</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>较为简单，That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--实现一个strStr()函数</title>
    <url>/algorithm/20/</url>
    <content><![CDATA[<p>题目：实现一个strStr()方法，要求strStr有俩个参数，hayStack和needle参数，找出字符串hayStack中needle的位置，并返回这个位置。如果找不到就返回-1.</p>
<p>解析：查找位置，只能双层遍历，依次比对。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="function">(<span class="params">haystack, needle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= haystack.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> a = i, b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (b &lt; needle.length &amp;&amp;</span><br><span class="line">            haystack[a] === needle[b]) &#123;</span><br><span class="line">            a++</span><br><span class="line">            b++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b === needle.length) <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">strStr(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment">//  0</span></span><br><span class="line">strStr(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;ll&#x27;</span>)   <span class="comment">//  2</span></span><br><span class="line">strStr(<span class="string">&#x27;aaaaa&#x27;</span>, <span class="string">&#x27;bba&#x27;</span>)  <span class="comment">//  -1</span></span><br></pre></td></tr></table></figure>
<p>注意：整个代码结构是比较清晰易懂的，但是有几个地地方是需要注意：</p>
<ul>
<li>for循环中i是要小于等于（<code>&lt;=</code>）haystack.length,这是因为haystack和needle都可能出现为空的情况；</li>
<li>双层循环，要用变量接一下外层循环的变量，这里需要知道的是，双层遍历，外层循环一次，内层循环要全循环完，才能开始外层的第二次循环，以此类推；</li>
<li>注意while循环的条件。</li>
</ul>
<p>That’s all!这就是KMP算法。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--买卖股票的最佳时机(I)</title>
    <url>/algorithm/24/</url>
    <content><![CDATA[<p>题目：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。<br>分析：看到这个题，第一反应应该就是选择排序的思想。是的没有错。采用prices[i]和后面的每一个元素做对比。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> maxProfit = prices =&gt; &#123;</span><br><span class="line">    //  取第一个元素为最小值</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">sum</span> = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> po = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">            i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; <span class="built_in">sum</span>) &#123;</span><br><span class="line">            <span class="built_in">sum</span> = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">        po = prices[i] - <span class="built_in">sum</span> &gt; po ? </span><br><span class="line">            (prices[i] - <span class="built_in">sum</span>) : po</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> po</span><br><span class="line">&#125;</span><br><span class="line">maxProfit([<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>])    // <span class="number">5</span></span><br><span class="line">maxProfit([<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>])    // <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>空间复杂度为O(1),时间复杂度为O(1),但是请考虑下面的代码是不有问题。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">maxProfit</span> = <span class="attr">prices</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">pr</span> = <span class="number">0</span></span><br><span class="line">    for (<span class="keyword">let</span> <span class="attr">i</span> = <span class="number">0</span>;i &lt; prices.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        for (<span class="keyword">let</span> <span class="attr">j</span> = i+<span class="number">1</span>;j &lt; prices.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[j]&gt;prices[i]) &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="attr">sum</span> = prices[j] - prices[i]</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; pr) <span class="attr">pr</span> = sum</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请写下你的见解！</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--多数元素问题</title>
    <url>/algorithm/23/</url>
    <content><![CDATA[<p>题目：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>分析：看到这个题，其实我们就直接想到了，统计给定数组中元素出现次数的问题。所以照着这个方向做就OK！</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let majorityElement = (nums) =&gt; &#123;</span><br><span class="line">    let obj = &#123;&#125;</span><br><span class="line">    let arr = <span class="selector-attr">[]</span></span><br><span class="line">    nums<span class="selector-class">.forEach</span>(n =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj<span class="selector-class">.hasOwnProperty</span>(n)) &#123;</span><br><span class="line">            obj<span class="selector-attr">[n]</span> = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj<span class="selector-attr">[n]</span>++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> (let key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj<span class="selector-attr">[key]</span> &gt; (nums.length)/<span class="number">2</span>) &#123;</span><br><span class="line">            arr<span class="selector-class">.push</span>(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">majorityElement</span><span class="params">([<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span>    <span class="comment">//  3</span></span><br><span class="line"><span class="function"><span class="title">majorityElement</span><span class="params">([<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>])</span></span>    <span class="comment">//  2</span></span><br></pre></td></tr></table></figure>
<p>其实，思路就是哈希表+排序方式，That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--搜索插入位置</title>
    <url>/algorithm/25/</url>
    <content><![CDATA[<p>题目：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。</p>
<p>解析：</p>
<ul>
<li>首先给定的是一个有序数组，那么我们直接循环就OK，时间复杂度应该是O(1)</li>
<li>题目要求返回的是索引，并不是将目标元素插入到数组的某个位置，这就简单了，并不会对数组做什么操作。那么就可以说是<code>只要发现元素大于等于(&gt;=)目标元素就找到了这个位置</code>,否则就是没有找到这个位置，那么目标值一定是最大值，返回最后一个的下标就OK！</li>
<li>注意处理边界值。<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">let searchInsert = (nums, target) =&gt; &#123;</span><br><span class="line">    let <span class="keyword">index</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>;</span><br><span class="line">        i &lt; nums.<span class="built_in">length</span> - <span class="number">1</span>;</span><br><span class="line">        i++</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">index</span> = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">index</span> = nums.<span class="built_in">length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">index</span></span><br><span class="line">&#125;</span><br><span class="line">searchInsert([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span>)  <span class="comment">//  3</span></span><br><span class="line">searchInsert([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span>)  <span class="comment">//  1</span></span><br><span class="line">searchInsert([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span>)  <span class="comment">//  0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
题还是比较简单，但是别让自己的思维走进死胡同，其实对于Javascript来说，有个方法叫reduce，此法也许更简洁。That’s all!</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--反转字符串</title>
    <url>/algorithm/28/</url>
    <content><![CDATA[<p>题目：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>分析：本地中没什么难度，只是要注意的是不要使用额外空间，空间复杂度是O(1).</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">var reverseString = function(s) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">right</span> = s.length - <span class="number">1</span></span><br><span class="line">    while (<span class="built_in">left</span> &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = s[<span class="built_in">left</span>]</span><br><span class="line">        s[<span class="built_in">left</span>] = s[<span class="built_in">right</span>]</span><br><span class="line">        s[<span class="built_in">right</span>] = temp</span><br><span class="line">        <span class="built_in">left</span>++</span><br><span class="line">        <span class="built_in">right</span>--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;;</span><br><span class="line">reverseString([<span class="string">&quot;h&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;o&quot;</span>])</span><br><span class="line">//  [<span class="string">&quot;o&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;h&quot;</span>]</span><br><span class="line">reverseString([<span class="string">&quot;H&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;h&quot;</span>])</span><br><span class="line">//  [<span class="string">&quot;h&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;H&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--存在重复元素(I)</title>
    <url>/algorithm/29/</url>
    <content><![CDATA[<p>题目：给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>分析：这个题应该是比较简单的，哈希方式，统计字符出现的次数这个思路即可。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> containsDuplicate = function(nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">length</span> &lt; <span class="number">2</span>) <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">    <span class="built_in">let</span> isTrue = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">length</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">map</span>.hasOwnProperty(nums[i])) &#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]] = <span class="number">1</span></span><br><span class="line">            isTrue = <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isTrue = <span class="literal">true</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> isTrue</span><br><span class="line">&#125;;</span><br><span class="line">containsDuplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]) // <span class="literal">true</span></span><br><span class="line">containsDuplicate([<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>]) // <span class="literal">true</span></span><br><span class="line">containsDuplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(二)--冒泡排序</title>
    <url>/algorithm/3/</url>
    <content><![CDATA[<p>冒泡排序的思想：将数组中的前一项和后一项依此做比较，如果后一项比前一项小，那么互换位置，以此类推，时间复杂度为n<sup>2</sup>。<br><img src="/algorithm/3/3.gif" alt="冒泡排序"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">var bubbleSort = (arr) =&gt; &#123;</span><br><span class="line">    for(let i = 0;i &lt; arr.length - 1;i++) &#123;</span><br><span class="line">        for (let j = i + 1;j &lt; arr.length;j++) &#123;</span><br><span class="line">            if (arr<span class="comment">[i]</span> &gt; arr<span class="comment">[j]</span>) &#123;</span><br><span class="line">                let temp = arr<span class="comment">[i]</span></span><br><span class="line">                arr<span class="comment">[i]</span> = arr<span class="comment">[j]</span></span><br><span class="line">                arr<span class="comment">[j]</span> = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">bubbleSort(<span class="comment">[4,3,1,9,6,5,2,7,8]</span>)</span><br><span class="line">// <span class="comment">[1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure>
<p>注：冒泡排序效率低，基本不用。<br>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--存在重复元素(II)</title>
    <url>/algorithm/30/</url>
    <content><![CDATA[<p>题目：给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<p>分析：看题目，直接就想到了<code>哈希</code>方式。统计字符出现的次数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (obj[nums[i]] !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">            i - obj[nums[i]] &lt;= k) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">       obj[nums[i]] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line">containsNearbyDuplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], <span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line">containsNearbyDuplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--买卖股票的最佳时机(II)</title>
    <url>/algorithm/26/</url>
    <content><![CDATA[<p>题目：给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>分析：这就是标准的T+1股票，今天买进，只要涨，明天就卖出。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> maxProfit = prices =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        i &lt; prices.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i+<span class="number">1</span>] &gt; prices[i]) &#123;</span><br><span class="line">                <span class="built_in">sum</span> += prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">&#125;</span><br><span class="line">maxProfit([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  //  <span class="number">4</span></span><br><span class="line">maxProfit([<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>])  //  <span class="number">7</span></span><br><span class="line">maxProfit([<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>])  //  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>没什么好说的。That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(一)--选择排序</title>
    <url>/algorithm/2/</url>
    <content><![CDATA[<p>选择排序的思想：将数组的第一项，与后面的每一项做对比，找到最小的那一个，放到第一位，将剩余项所组成的数组的第一项与后面的每一项做对比，找到最小的项放到第一位，以此类推，时间复杂度为n<sup>2</sup>。<br><img src="/algorithm/2/2.gif" alt="选择排序"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">var <span class="attr">selectSort</span> = (arr) =&gt; &#123;</span><br><span class="line">    for (<span class="keyword">let</span> <span class="attr">i</span> = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="attr">minPos</span> = i</span><br><span class="line">        for (<span class="keyword">let</span> <span class="attr">j</span> = i + <span class="number">1</span>; j &lt; arr.length;j++) &#123;</span><br><span class="line">            <span class="attr">minPos</span> = arr[j] &lt; arr[minPos] ? j : minPos</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="attr">temp</span> = arr[i]</span><br><span class="line">        arr[i] = arr[minPos]</span><br><span class="line">        arr[minPos] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">selectSort([<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line">// [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>上面的方法是通过找最小值来实现的。那么，我们既然能找到最小值，同时，我们是不是也可以找到最大值呢？这样以来遍历就可以减少一半了，当然是可以的了，且看下面的代码。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> selectSort = (arr) =&gt; &#123;</span><br><span class="line">    let <span class="built_in">left</span> = <span class="number">0</span></span><br><span class="line">    let <span class="built_in">right</span> = arr.length - <span class="number">1</span></span><br><span class="line">    while(<span class="built_in">left</span> &lt; <span class="built_in">right</span>) &#123;</span><br><span class="line">        let <span class="built_in">min</span> = <span class="built_in">left</span></span><br><span class="line">        let <span class="built_in">max</span> = <span class="built_in">right</span></span><br><span class="line">        for(let i = <span class="built_in">left</span>;i &lt;= <span class="built_in">right</span>;i++) &#123;</span><br><span class="line">            <span class="built_in">min</span> = arr[i] &lt; arr[<span class="built_in">min</span>] ? i <span class="symbol">:</span> <span class="built_in">min</span></span><br><span class="line">            <span class="built_in">max</span> = arr[<span class="built_in">max</span>] &lt; arr[i] ? i <span class="symbol">:</span> <span class="built_in">max</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (arr[<span class="built_in">min</span>] &lt; arr[<span class="built_in">left</span>]) &#123;</span><br><span class="line">            let temp = arr[<span class="built_in">left</span>]</span><br><span class="line">            arr[<span class="built_in">left</span>] = arr[<span class="built_in">min</span>]</span><br><span class="line">            arr[<span class="built_in">min</span>] = temp</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (arr[<span class="built_in">max</span>] &gt; arr[<span class="built_in">right</span>]) &#123;</span><br><span class="line">            let temp = arr[<span class="built_in">right</span>]</span><br><span class="line">            arr[<span class="built_in">right</span>] = arr[<span class="built_in">max</span>]</span><br><span class="line">            arr[<span class="built_in">max</span>] = temp</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">left</span>++</span><br><span class="line">        <span class="built_in">right</span>--</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">selectSort([<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line">// [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>注意：选择排序的是一种不稳定的排序，如果出现俩个相邻的值相等，那么往往前一个值会跑到后一个值后面。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--求俩个数组的交集</title>
    <url>/algorithm/31/</url>
    <content><![CDATA[<p>题目：给定两个数组，编写一个函数来计算它们的交集。</p>
<p>分析：这是一个较为基础且常见的题，方法很多，比如：双指针法，去重法，二分查找法等：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">var intersection = function(nums1, nums2) &#123;</span><br><span class="line">    let arr = <span class="comment">[]</span></span><br><span class="line">    for (let i =0;i&lt;nums1.length;i++) &#123;</span><br><span class="line">        for (let j=0;j&lt;nums2.length;j++) &#123;</span><br><span class="line">            if (arr.indexOf(nums1<span class="comment">[i]</span>) === -1</span><br><span class="line">                &amp;&amp; arr.indexOf(nums2<span class="comment">[j]</span>) ===-1</span><br><span class="line">                    &amp;&amp; nums1<span class="comment">[i]</span> === nums2<span class="comment">[j]</span>) &#123;</span><br><span class="line">                arr.push(nums2<span class="comment">[j]</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">intersection(<span class="comment">[1,2,2,1]</span>, <span class="comment">[2,2]</span>)  //  <span class="comment">[2]</span></span><br><span class="line">intersection(<span class="comment">[4,9,5]</span>, <span class="comment">[9,4,9,8,4]</span>)  //  <span class="comment">[4,9]</span></span><br></pre></td></tr></table></figure>
<p>运行结果： 执行用时：596 ms, 在所有 JavaScript 提交中击败了5.22的用户<br>内存消耗：38 MB, 在所有 JavaScript 提交中击败了99.13%的用户<br>可以看到双指针法的时间复杂度较高，而空间复杂度低。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> intersection = function(nums1, nums2) &#123;</span><br><span class="line">    return <span class="selector-attr">[...new Set(nums1)]</span><span class="selector-class">.filter</span>(n =&gt; nums2<span class="selector-class">.includes</span>(n))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">intersection</span><span class="params">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">2</span>])</span></span>  <span class="comment">//  [2]</span></span><br><span class="line"><span class="function"><span class="title">intersection</span><span class="params">([<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>])</span></span>  <span class="comment">//  [4,9]</span></span><br></pre></td></tr></table></figure>
<p>先用new Set()对nums1去重，再过滤，这种方法本人认为局限性较大。</p>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--找出只出现一次的数字</title>
    <url>/algorithm/27/</url>
    <content><![CDATA[<p>题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。算法应该具有线性复杂度，并且不使用额外的空间。</p>
<p>解析：在给定的数组中，很有规律，除了只出现一次的元素外，其他的每个元素均只出现俩次，这就让我们想到了<code>异或运算(^)</code>。即，任意数a和0的运算：a⊕a=0;a⊕0=a,所以代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let singleNumber = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums.length) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(let <span class="selector-tag">i</span> of nums) &#123;</span><br><span class="line">        m ^= <span class="selector-tag">i</span></span><br><span class="line">    &#125;</span><br><span class="line">    return m</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">singleNumber</span><span class="params">([<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>])</span></span>   <span class="comment">//  4</span></span><br><span class="line"><span class="function"><span class="title">singleNumber</span><span class="params">([<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>])</span></span>   <span class="comment">//  1</span></span><br></pre></td></tr></table></figure>
<p>所以本题的思路是非常难的，代码很简单，快补充一下<code>异或运算</code>啊。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--合并俩个有序列表</title>
    <url>/algorithm/33/</url>
    <content><![CDATA[<p>题目：将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>分析：我们首先要创建俩个链表，然后比较俩个链表元素的大小，然后合并为一个新的链表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  创建链表节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  链表元素</span></span><br><span class="line">    <span class="built_in">this</span>.val = val</span><br><span class="line">    <span class="comment">//  链表元素的指向</span></span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  创建链表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NodeList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  表示链表的长度</span></span><br><span class="line">    <span class="built_in">this</span>.length = <span class="number">0</span></span><br><span class="line">    <span class="comment">//  表示链表的头节点</span></span><br><span class="line">    <span class="built_in">this</span>.head = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  实现向列表中添加元素的方法</span></span><br><span class="line">NodeList.protoType.append = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> Node(data)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.head) &#123;</span><br><span class="line">        <span class="comment">//  如果不存在头节点，把当前节点作为头节点</span></span><br><span class="line">        <span class="built_in">this</span>.head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  如果存在头节点就将每个节点都指向下一个节点</span></span><br><span class="line">        <span class="comment">//  最后将新节点追加到最后</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.head</span><br><span class="line">        <span class="keyword">while</span>(current.next) &#123;</span><br><span class="line">            current.next = current</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  创建返回链表的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getList</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> list = <span class="keyword">new</span> NodeList()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">        list.insert(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> l1 = getList([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">let</span> l2 = getList([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>这里我们就得到了俩个链表l1和l2，应该是这样的：<br><img src="/algorithm/33/1.png" alt="链表"><br><code>注意：在写append方法的时候，请不要用箭头函数，箭头函数没有this,会造成错误，本人开发时犯了这样的错，找了很久...</code><br>有了这俩个链表，我们可以进入正题，合并这俩个链表，最终得出结果：<code>[1,1,2,3,4,4]</code>:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mergeTwoLists =<span class="function"> (<span class="params">l1</span>,<span class="params">l2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1<span class="operator"> === </span>null) &#123;</span><br><span class="line">        return l2</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2<span class="operator"> === </span>null) &#123;</span><br><span class="line">        return l1</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.<span class="keyword">val</span> &lt; l2.<span class="keyword">val</span>) &#123;</span><br><span class="line">        l1.next = merge<span class="constructor">TwoLists(<span class="params">l1</span>.<span class="params">next</span>, <span class="params">l2</span>)</span></span><br><span class="line">        return l1</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.<span class="keyword">val</span> &gt; l2.<span class="keyword">val</span>) &#123;</span><br><span class="line">        l2.next = merge<span class="constructor">TwoLists(<span class="params">l1</span>, <span class="params">l2</span>.<span class="params">next</span>)</span></span><br><span class="line">        return l2</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">[]</span></span><br><span class="line">&#125;</span><br><span class="line">merge<span class="constructor">TwoLists(<span class="params">l1</span>.<span class="params">head</span>, <span class="params">l2</span>.<span class="params">head</span>)</span></span><br></pre></td></tr></table></figure>
<p>合并后的链表是这样的。<br><img src="/algorithm/33/2.png" alt="链表"><br>揭下来，转化为正常的数组：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrFormat =<span class="function"> (<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = data.next</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        arr.push(current.<span class="keyword">val</span>)</span><br><span class="line">        current = current.nex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr<span class="constructor">Format(<span class="params">mergeTwoLists</span>(<span class="params">l1</span>.<span class="params">head</span>, <span class="params">l2</span>.<span class="params">head</span>)</span>)</span><br><span class="line"><span class="comment">//  [1,1,2,3,4,4]</span></span><br></pre></td></tr></table></figure>
<p>至此，完整的链表合并完成，在js中本身没有链表这一数据结构，所以，模拟了链表，链表有俩个属性，val(值)和next(指针)俩个属性。<br>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--找出第一个不重复的字符</title>
    <url>/algorithm/32/</url>
    <content><![CDATA[<p>题目：给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p>分析：这种题目应该直接就会想到哈希表法。直接上代码。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstUniqChar = s =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> len = s.length</span><br><span class="line">    //  这里采用的是集合</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">set</span> = new <span class="keyword">Set</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len;i++) &#123;</span><br><span class="line">        <span class="built_in">set</span>[s[i]] = <span class="built_in">set</span>[s[i]] ? s[i] + <span class="number">1</span> : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; len;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>[s[j]] === <span class="number">1</span>) <span class="keyword">return</span> j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题中，空间复杂度为O(1),时间复杂度为O(2N),注意边界值。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--杨辉三角(I)</title>
    <url>/algorithm/35/</url>
    <content><![CDATA[<p>题目： 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。<br><img src="/algorithm/35/1.gif" alt="杨辉三角"></p>
<p>分析：在「杨辉三角」中，每个数是它左上方和右上方的数的和。这就是我们要实现的规律。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generate = numRows =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; numRows;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tempArr = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= i;j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (!result[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">sum</span> = <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="built_in">left</span> = result[i - <span class="number">1</span>][j - <span class="number">1</span>] |<span class="type">| 0</span></span><br><span class="line">                <span class="keyword">let</span> <span class="built_in">right</span> = result[i - <span class="number">1</span>][j] |<span class="type">| 0</span></span><br><span class="line">                <span class="built_in">sum</span> = <span class="built_in">left</span> + <span class="built_in">sum</span> + <span class="built_in">right</span></span><br><span class="line">            &#125;</span><br><span class="line">            tempArr.push(<span class="built_in">sum</span> |<span class="type">| 1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(tempArr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--最大子序和</title>
    <url>/algorithm/34/</url>
    <content><![CDATA[<p>题目：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> maxSubArray = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">sum</span> = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">length</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> &gt; nums[i] ? <span class="built_in">sum</span> : nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">sum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知道怎么说什么，所以没有写分析，That’s all.</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--实现最小栈操作</title>
    <url>/algorithm/37/</url>
    <content><![CDATA[<p>题目：设计一个支持 push，pop，top操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) —— 将元素 x 推入栈中。</li>
<li>pop() —— 删除栈顶的元素。</li>
<li>top() —— 获取栈顶元素。</li>
<li>getMin() —— 检索栈中的最小元素。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">let MinStack = function () &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">data</span> = []</span><br><span class="line">&#125;</span><br><span class="line">MinStack.prototype.push = function (x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">data</span>.push(x)</span><br><span class="line">&#125;</span><br><span class="line">MinStack.prototype.pop() = function () &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">data</span>.pop()</span><br><span class="line">&#125;</span><br><span class="line">MinStack.prototype.top = function () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.<span class="keyword">data</span>.length) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">data</span>.slice(<span class="keyword">this</span>.<span class="keyword">data</span>.length - <span class="number">1</span>, <span class="keyword">this</span>.<span class="keyword">data</span>.length)</span><br><span class="line">&#125;</span><br><span class="line">MinStack.prototype.getMin = function () &#123;</span><br><span class="line">    let num = <span class="keyword">this</span>.<span class="keyword">data</span>[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.<span class="keyword">data</span>.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.<span class="keyword">data</span>[i]) &#123;</span><br><span class="line">            num = <span class="keyword">this</span>.<span class="keyword">data</span>[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line">let stack = new MinStack()</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">4</span>)</span><br><span class="line">stack.pop() <span class="comment">//  4</span></span><br><span class="line">stack.top() <span class="comment">//  2</span></span><br><span class="line">stack.getMin() <span class="comment">//   1</span></span><br></pre></td></tr></table></figure>
That’s all.</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--爬楼梯问题</title>
    <url>/algorithm/40/</url>
    <content><![CDATA[<p>题目：假设你正在爬楼梯，需要n阶才能到达楼顶，每次你可以爬1或2个台阶，你有多少种不同爬到楼顶的方法？注：给定n是一个正整数。</p>
<p>分析：我们看下具体的解法：<br>0开始：     1种 –&gt; 1<br>1第一节楼梯：1种 –&gt; 1<br>2第二节楼梯：2种 –&gt; 11, 2<br>3第三节楼梯：3种 –&gt; 111, 12, 21<br>4第四节楼梯：5种 –&gt; 1111, 121, 112, 211, 22<br>5第五节楼梯：8种 –&gt; 11111, 1112, 1121, 1211, 2111, 221, 212, 122<br>.<br>.<br>.<br>1，1，2，3，5，8，13，21，44，65…<br>有没有发现一个规律，有没有，有没有，有没有，我擦…这不就是意大利数学家斐波那契额在1202年发现的那个兔子增长的规律吗？没错就是斐波那契数列。直接上代码:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> climbStairs =<span class="function"> <span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        return n</span><br><span class="line">    &#125;</span><br><span class="line">    return climb<span class="constructor">Stairs(<span class="params">n</span> - 1)</span> + climb<span class="constructor">Stairs(<span class="params">n</span>-2)</span></span><br><span class="line">&#125;</span><br><span class="line">climb<span class="constructor">Stairs(6)</span> <span class="comment">//   8</span></span><br><span class="line">climb<span class="constructor">Stairs(10)</span> <span class="comment">//   55</span></span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> climbStairs =<span class="function"> <span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">val</span> = <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">val</span><span class="literal">[<span class="identifier">i</span>]</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) return <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span><span class="literal">[<span class="number">1</span>]</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span><span class="literal">[<span class="number">2</span>]</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">val</span><span class="literal">[<span class="identifier">i</span>]</span> = <span class="keyword">val</span><span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span> + <span class="keyword">val</span><span class="literal">[<span class="identifier">i</span>-<span class="number">2</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="keyword">val</span><span class="literal">[<span class="identifier">n</span>]</span></span><br><span class="line">&#125;</span><br><span class="line">climb<span class="constructor">Stairs(6)</span> <span class="comment">//   8</span></span><br><span class="line">climb<span class="constructor">Stairs(10)</span> <span class="comment">//   55</span></span><br></pre></td></tr></table></figure>
<p>Yes, So easy!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--求一个数的平方根</title>
    <url>/algorithm/41/</url>
    <content><![CDATA[<p>题目：实现一个函数sqrt(x)，计算并返回x的平方根，其中x为非负整数，由于返回的类型为整数，结果只保留整数部分，小数部分将被舍去。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">let mySqrt = x =&gt; &#123;</span><br><span class="line">    <span class="built_in">var</span> high = x, low = <span class="number">1</span>, <span class="built_in">mid</span></span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        <span class="built_in">mid</span> = Math.floor((low + high)/<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">mid</span> * <span class="built_in">mid</span> &gt; x)&#123;</span><br><span class="line">            high = <span class="built_in">mid</span> - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        else <span class="built_in">if</span> (<span class="built_in">mid</span> * <span class="built_in">mid</span> &lt; x)&#123;</span><br><span class="line">            low = <span class="built_in">mid</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return <span class="built_in">mid</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return high</span><br><span class="line">&#125;</span><br><span class="line">mySqrt(<span class="number">8</span>) //    <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--斐波那契数列的实现及优化</title>
    <url>/algorithm/39/</url>
    <content><![CDATA[<p>题目：写一个函数，输入n,求斐波那契数列的第n项，即F(n)斐波那契数列的定义如下，F(0) = 0, F(1) = 1, F(n) = F(n - 1) + F(n - 2)(n&gt;1), 既： 0，1，1，2，3，5，8，13，21，44，65…</p>
<p>分析：斐波那契数列数列，是1202年由意大利数学家提出，用来描述兔子的增长过程发明的，既该序列是由前两项数值相加而成的。</p>
<p>所以，简单的代码实现就是递归：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let fib = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        return n</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        return fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">(<span class="number">0</span>)</span></span> <span class="comment">//   0</span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">(<span class="number">1</span>)</span></span> <span class="comment">//   1</span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">(<span class="number">2</span>)</span></span> <span class="comment">//   1</span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">(<span class="number">5</span>)</span></span> <span class="comment">//   5</span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">(<span class="number">6</span>)</span></span> <span class="comment">//   8</span></span><br><span class="line"><span class="function"><span class="title">fib</span><span class="params">(<span class="number">10</span>)</span></span> <span class="comment">//   55</span></span><br></pre></td></tr></table></figure>
<p><img src="/algorithm/39/1.png" alt="斐波那契数列"><br>我们可以看到代码实现非常的简单，但是存在的问题是执行效率太低了。从上图中可以看到，递归树中太多的值被重新计算。那么如何提高该数列的执行效率呢？答案是动态规划。来看下面的具体代码：</p>
<figure class="highlight pony"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fib = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="meta">val</span> = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="meta">val</span>[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="meta">val</span>[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="meta">val</span>[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="meta">val</span>[i] = <span class="meta">val</span>[i<span class="number">-1</span>] + <span class="meta">val</span>[i<span class="number">-2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="meta">val</span>[n<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">0</span>) <span class="comment">//   0</span></span><br><span class="line">fib(<span class="number">1</span>) <span class="comment">//   1</span></span><br><span class="line">fib(<span class="number">2</span>) <span class="comment">//   1</span></span><br><span class="line">fib(<span class="number">5</span>) <span class="comment">//   5</span></span><br><span class="line">fib(<span class="number">6</span>) <span class="comment">//   8</span></span><br><span class="line">fib(<span class="number">10</span>) <span class="comment">//   55</span></span><br></pre></td></tr></table></figure>
<p>我们通过val数组来保存中间值结果来优化递归执行效率低的问题。所以这样应该是斐波那契数列的一个优化版本。That’s all.</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--删除链表中的重复项</title>
    <url>/algorithm/42/</url>
    <content><![CDATA[<p>题目：存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。返回同样按升序排列的结果链表。</p>
<p>分析：升序链表，那么重复项一定就是相邻项，所以只需要判断相邻项是否相等，如果相等则就指向下一项即。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> ListNode (val, <span class="keyword">next</span>) &#123;</span><br><span class="line">    this.val = (val === undefined ? <span class="number">0</span> : val)</span><br><span class="line">    this.<span class="keyword">next</span> = (<span class="keyword">next</span> === undefined ? : null : <span class="keyword">next</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deleteDuplicates =<span class="built_in"> head</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">!head</span>) <span class="keyword">return</span><span class="built_in"> head</span></span><br><span class="line">    <span class="keyword">let</span> current =<span class="built_in"> head</span></span><br><span class="line">    while (current.<span class="keyword">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.val === current.<span class="keyword">next</span>.val) &#123;</span><br><span class="line">            current.<span class="keyword">next</span> = current.<span class="keyword">next</span>.<span class="keyword">next</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.<span class="keyword">next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span><span class="built_in"> head</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--杨辉三角(II)</title>
    <url>/algorithm/36/</url>
    <content><![CDATA[<p>题目：给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="/algorithm/36/../35/1.gif" alt="杨辉三角"></p>
<p>分析：其实上图中的关系可以看出，杨辉三角的层级比题目要求的索引少1，那么在这个基础上，我们就可以将上一题稍加改造就OK了。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getRow = rowIndex =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowIndex + <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tempArr = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (!result[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="built_in">sum</span> = <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="built_in">left</span> = result[i<span class="number">-1</span>][j<span class="number">-1</span>] |<span class="type">| 0</span></span><br><span class="line">                <span class="keyword">let</span> <span class="built_in">right</span> = result[i<span class="number">-1</span>][j] |<span class="type">| 0</span></span><br><span class="line">                <span class="built_in">sum</span> = <span class="built_in">left</span> + <span class="built_in">sum</span> + <span class="built_in">right</span></span><br><span class="line">            &#125;</span><br><span class="line">            tempArr.push(<span class="built_in">sum</span> |<span class="type">| 1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(tempArr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result[rowIndex]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>leeCode算法--计算加1问题</title>
    <url>/algorithm/38/</url>
    <content><![CDATA[<p>题目：给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>解析：题目中看似比较简单只是计算了一个数字加上1而已，但是这里却有不少的坑，比如：</p>
<ul>
<li>最后加一后是不是需要向前一位进一；</li>
<li>加一之后，有那些位需要进一</li>
<li>如果一个数字加一后，比原来的数多了一位怎么办。</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">let plusOne = <span class="keyword">digits</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">digits</span>.length) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    //  数字要从后向前遍历</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="keyword">digits</span>.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i<span class="comment">--) &#123;</span></span><br><span class="line">        //  从后向前加一</span><br><span class="line">        <span class="keyword">digits</span>[i]++</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">digits</span>[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            //  如果某一位数加一大于等于<span class="number">10</span>，</span><br><span class="line">            //  将本位数改为<span class="number">0</span>，前一位数加一</span><br><span class="line">            <span class="keyword">digits</span>[i] = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            //  否则，说明只是简单的加一，直接返回数组极好</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">digits</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //  当出现加完一后，新数要比原数多一位，只需要在最前面加<span class="number">1</span>就好</span><br><span class="line">    <span class="keyword">digits</span>.unshift(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">digits</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>yes, do you understand?</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(三)--插入排序</title>
    <url>/algorithm/4/</url>
    <content><![CDATA[<p>插入排序的思想: 插入排序有点像冒泡排序，但是插入排序是从index=1的位置开始，与前面的项做比较，如果比前面的项小，那么就互换位置，或者是将前面较小的项向后移动到对应的位置。<br><img src="/algorithm/4/4.gif" alt="插入排序"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">var insertSort = (arr) =&gt; &#123;</span><br><span class="line">    for(let i = 1;i &lt; arr.length;i++) &#123;</span><br><span class="line">        for(let j = i;j &gt; 0;j--) &#123;</span><br><span class="line">            if (arr<span class="comment">[j]</span> &lt; arr<span class="comment">[j-1]</span>) &#123;</span><br><span class="line">                let temp = arr<span class="comment">[j]</span></span><br><span class="line">                arr<span class="comment">[j]</span> = arr<span class="comment">[j - 1]</span></span><br><span class="line">                arr<span class="comment">[j - 1]</span> = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">insertSort(<span class="comment">[4,3,1,9,6,5,2,7,8]</span>)</span><br><span class="line">// <span class="comment">[1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure>
<p>注：三种基础排序中，插入排序是相对比较有用的一种，尤其是对于样本比较小，且基本有序的情况下，效率会非常的高。<br>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(五)--归并排序</title>
    <url>/algorithm/6/</url>
    <content><![CDATA[<p>归并排序的思想：归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>实现的步骤：</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
<p>时间复杂度为：nlogn。</p>
<p><img src="/algorithm/6/6.gif" alt="归并排序"></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var mergeSort = (arr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> middle = Math.<span class="built_in">floor</span>(arr.length/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">left</span> = arr.slice(<span class="number">0</span>, middle)</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">right</span> = arr.slice(middle)</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(<span class="keyword">left</span>), mergeSort(<span class="keyword">right</span>))</span><br><span class="line">&#125;</span><br><span class="line">var merge = (<span class="keyword">left</span>, <span class="keyword">right</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">left</span>.length &amp;&amp; <span class="keyword">right</span>.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">left</span>[<span class="number">0</span>] &lt;= <span class="keyword">right</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(<span class="keyword">left</span>.shift())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(<span class="keyword">right</span>.shift())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">left</span>.length) &#123;</span><br><span class="line">        result.push(<span class="keyword">left</span>.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">right</span>.length) &#123;</span><br><span class="line">        result.push(<span class="keyword">right</span>.shift())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">mergeSort([<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">//  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>归并排序是应用比较多的一种排序，是稳定的，掌握，掌握，掌握！！！<br>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(六)--快速排序</title>
    <url>/algorithm/7/</url>
    <content><![CDATA[<p>快速排序的思想：先在整个数列中找到一个基准（pivot），以这个基准为参照，重新排列整个数列，将其中的项目小于基准的排在基准的一边，将大于基准的排在基准的另一侧。等于基准排在哪边无所谓。递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br><img src="/algorithm/7/7.gif" alt="快速排序"></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">quickSort (arr, <span class="keyword">l</span>, r) &#123;</span><br><span class="line">    //  一个元素不需要排序，直接返回</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">l</span> &gt;= r) <span class="keyword">return</span> arr</span><br><span class="line">    //  找到基准的下标</span><br><span class="line">    <span class="keyword">let</span> partitionIndex = partition(arr, <span class="keyword">l</span>, r)</span><br><span class="line">    //  对基准左侧的数组排序,同时基准向左移动</span><br><span class="line">    quickSort(arr, <span class="keyword">l</span>, partitionIndex - <span class="number">1</span>)</span><br><span class="line">    //  对基准右侧的数组排序,同时基准向右移动</span><br><span class="line">    quickSort(arr, partitionIndex + <span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br><span class="line">partition (arr, <span class="keyword">l</span>, r) &#123;</span><br><span class="line">    //  取每段数组的最右边的元素为基准值</span><br><span class="line">    <span class="keyword">let</span> pivot = arr[r]</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">left</span> = <span class="keyword">l</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">right</span> = r - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">left</span> &lt;= <span class="keyword">right</span> &amp;&amp; arr[<span class="keyword">left</span>] &lt;= pivot) &#123;</span><br><span class="line">            <span class="keyword">left</span>++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">left</span> &lt;= <span class="keyword">right</span> &amp;&amp; arr[<span class="keyword">right</span>] &gt; pivot) &#123;</span><br><span class="line">            <span class="keyword">right</span>--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</span><br><span class="line">            this.swap(arr, <span class="keyword">left</span>, <span class="keyword">right</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //  最后剩下的元素做交换</span><br><span class="line">    swap(arr, <span class="keyword">left</span>, r)</span><br><span class="line">    //  这里返回的是<span class="keyword">left</span>,不是<span class="keyword">right</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span></span><br><span class="line">&#125;</span><br><span class="line">swap (arr, i, <span class="keyword">j</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">    arr[i] = arr[<span class="keyword">j</span>]</span><br><span class="line">    arr[<span class="keyword">j</span>] = temp</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>]</span><br><span class="line">quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>)</span><br><span class="line">console.<span class="built_in">log</span>(arr)</span><br><span class="line">//  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>注：快速排序稳定，且效率高，所以使用也比较多。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(四)--希尔排序</title>
    <url>/algorithm/5/</url>
    <content><![CDATA[<p>希尔排序的思想：希尔排序又被称作为改进版的插入排序，插入排序是相领俩相的比较，然后互换位置。而那么他们的间隔是1，而希尔排序的间隔要大于1，但是最后要执行一次间隔为1的插入排序，这样效率就比较高。<br>取最优间隔值：h = 3h + 1 ==&gt; 就是间隔去整个length的1/3是相对比较合理的。<br><img src="/algorithm/5/5.gif" alt="希尔排序"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">var <span class="attr">hillSort</span> = (arr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">h</span> = <span class="number">1</span></span><br><span class="line">    while(h &lt;= arr.length/<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="attr">h</span> = h * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    for(<span class="keyword">let</span> <span class="attr">gap</span> = h;gap &gt; <span class="number">0</span>;<span class="attr">gap</span> = (gap -<span class="number">1</span>)/<span class="number">3</span>) &#123;</span><br><span class="line">        for (<span class="keyword">let</span> <span class="attr">i</span> = gap;i &lt; arr.length;i++) &#123;</span><br><span class="line">            for(<span class="keyword">let</span> <span class="attr">j</span> = i;j &gt; gap - <span class="number">1</span>; j <span class="attr">-=</span> gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j-gap]) &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="attr">temp</span> = arr[j]</span><br><span class="line">                    arr[j] = arr[j-gap]</span><br><span class="line">                    arr[j-gap] = temp</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">hillSort([<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">//  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>希尔排序在实际的工作中应用应该比较少。<br>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(八)--基数排序</title>
    <url>/algorithm/9/</url>
    <content><![CDATA[<p>基数排序的思想：基数排序并不是比较排序，是桶排序的一种，基数排序要求，在基数排序之前先必须知道排序前的位数，然后将个位数先排，如果相等放在一个桶里，然后是十位，然后是百位，以此类推。<br><img src="/algorithm/9/9.gif" alt="基数排序"></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> radixSort = (arr, numberLength) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">mod</span> = <span class="number">10</span></span><br><span class="line">    <span class="built_in">let</span> dev = <span class="number">1</span></span><br><span class="line">    <span class="built_in">let</span> counter = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>;</span><br><span class="line">        i &lt; numberLength;</span><br><span class="line">        i++, <span class="built_in">mod</span> *= <span class="number">10</span>, dev *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">let</span> j = <span class="number">0</span>; j &lt; arr.<span class="built_in">length</span>;j++) &#123;</span><br><span class="line">                <span class="built_in">let</span> <span class="built_in">num</span> = parseInt((arr[j] <span class="symbol">%</span> <span class="built_in">mod</span>) / dev)</span><br><span class="line">                <span class="keyword">if</span> (!counter[<span class="built_in">num</span>]) &#123;</span><br><span class="line">                    counter[<span class="built_in">num</span>] = []</span><br><span class="line">                &#125;</span><br><span class="line">                counter[<span class="built_in">num</span>].<span class="built_in">push</span>(arr[j])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">let</span> pos = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">let</span> m = <span class="number">0</span>; m &lt; counter.<span class="built_in">length</span>; m++) &#123;</span><br><span class="line">                <span class="built_in">let</span> value = null</span><br><span class="line">                <span class="keyword">if</span> (counter[m]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (value = counter[m].shift()) &#123;</span><br><span class="line">                        arr[pos++] = value</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> arr = [<span class="number">342</span>, <span class="number">234</span>, <span class="number">675</span>, <span class="number">543</span>, <span class="number">23</span>, <span class="number">543</span>, <span class="number">764</span>]</span><br><span class="line">//  <span class="number">3</span>是表示最大数的个数</span><br><span class="line">console.<span class="built_in">log</span>(radixSort(arr, <span class="number">3</span>))</span><br><span class="line">//  [<span class="number">23</span>, <span class="number">234</span>, <span class="number">342</span>, <span class="number">543</span>, <span class="number">543</span>, <span class="number">675</span>, <span class="number">764</span>]</span><br></pre></td></tr></table></figure>
<p>注：基数排序和计数排序是有异曲同工之妙，他们都是在特定的情况下，才可以的。基数排序是稳定的。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>React--React中组件间的如何通信？</title>
    <url>/react/2/</url>
    <content><![CDATA[<p>我们之前说过React是一个组件至上的技术栈，所以，组件之间的通信就是大家关注的话题。主要有以下几种：</p>
<h3 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h3><p>父子组件的传值通过props来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&quot;I&#x27;m Lee!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&quot;&#123;name&#125;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                props.name</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子父组件"><a href="#子父组件" class="headerlink" title="子父组件"></a>子父组件</h3><p>子父组件的通信主要是通过callback来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> onChildClick = <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item) <span class="comment">//    点我</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Child</span> <span class="attr">callback</span>=<span class="string">&#123;onChildClick&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">props.callback</span>(&#x27;点我&#x27;) &#125;&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="父孙组件"><a href="#父孙组件" class="headerlink" title="父孙组件"></a>父孙组件</h3><p>父孙组建有俩中方式：</p>
<ul>
<li>以父子组件传值的方式，层层向下传递；</li>
<li>context上下文的方式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> context = createContext()</span><br><span class="line"><span class="keyword">var</span> parent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span> <span class="attr">count</span> &#125;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">context.Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">context.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;</span></span><br><span class="line"><span class="xml">                count =&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">context.Consumer</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无关-兄弟-组件"><a href="#无关-兄弟-组件" class="headerlink" title="无关(兄弟)组件"></a>无关(兄弟)组件</h3>非嵌套关系的组件通信主要有以下三种方式：</li>
<li>兄弟组件，可以通过找到共同的父组件，通过父子，子父组件的方式实现通信</li>
<li>可以通过redux, mobx, recoil等全局状态库来实现全局状态管理</li>
<li>可以通过自定义事件（发布订阅）</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React--React技术栈设计初衷什么？</title>
    <url>/react/1/</url>
    <content><![CDATA[<p>React作为当前最为流行的三大前端技术栈之一，备受大家开发者的关注。我们就来讲讲React技术栈的设计初衷是什么？打开React的官网可以醒目的看到一行大字—用于构建用户界面的JavaScript库。这基本就概括了React的核心：构建用户界面。</p>
<h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><p>React是声明式的编码方式，这使得React构建用户界面变的异常简单，这可以为应用的每一个状态设计简洁的UI视图，当数据改变时，React可以更有效的更新并且正确的渲染组件。以声明式编写UI，可以让代码更加可靠并方便调试。</p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件化应该算是React的又一大特点，React里使用了更加简化的组建模式，它将整个UI上的每一个功能模块定义成组件。然后将小的组件通过组合或者嵌套的方式再构成更大的组件。React组件具有以下特点：</p>
<ul>
<li>可组合：可以将简单的组件组合成复杂的组件</li>
<li>可重用：每个组件都是独立的，可以被其他组件调用</li>
<li>可维护：组件是独立的，将逻辑和UI封装，可维护性更高</li>
<li>可测试：组件的独立性决定了组件更容易测试</li>
</ul>
<h3 id="一次学习，随处遍写"><a href="#一次学习，随处遍写" class="headerlink" title="一次学习，随处遍写"></a>一次学习，随处遍写</h3><p>我认为React最强大的地方就在于一次学习，随处编写。就是说，无论你现在用的是什么技术栈，都可以随时引入React来开发新特性，而不需要重构现在的代码。React同时也支持服务端渲染，或者使用React Native开发原生App。React组件可以映射为对应的原声控件。在输出憝时候，到底输出的是web Dom, Ios，android控件是由平台决定的。</p>
<h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>当前Web应用越来越广泛。性能方面是一个不得不考虑的问题。传统页面每次刷新页面，都需要手动更新dom,这样性能的消耗是非常大的，因此，React使用虚拟DOM这一JavaScript对象树在每次页面更新后都会重新重新计算虚拟DOM，并且和上一次的虚拟DOM做对比，然后将变化的虚拟DOM更新到真实DOM上。这样就可以大大降低直接更新真是DOM带来的性能消耗。当然React也提供了shouldComponentUpdate这样的生命周期函数，和pureComponent来减少不必要的虚拟DOM的对比，以保证性能。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>函数式编程并不是起源于React,但是在我看来一定是扬于React,在新版本的React开发中，React提倡开发者使用函数式编程来开发组件。这样可以减少冗余代码，此外由于组件自身就是函数，更利于测试。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React--React中React Hooks的实现原理是什么？</title>
    <url>/react/4/</url>
    <content><![CDATA[<h3 id="曾经的react"><a href="#曾经的react" class="headerlink" title="曾经的react"></a>曾经的react</h3><p>react技术栈的迭代是非常快的，但是版本16也许是一次革命性的迭代。从版本16开始，react的底层由stack算法转变为fiber算法，大大提高了性能。而在16.8之后react又新增了hooks的概念。在老版本的react中，开发者所开发的大多都是class组件和少部分的函数组件，对于函数组件来说，它仅仅只是一个纯UI的展示组件，只能接受props，而不能有自己的state。而对于class组件来说，问题也是不少：组件状态复用艰难，让人无奈的this问题，高阶组件和函数组件的嵌套层次太深，复杂组件变得难以理解，以及难以记忆的生命周期等问题很让人头大。</p>
<h3 id="Hooks能做点什么"><a href="#Hooks能做点什么" class="headerlink" title="Hooks能做点什么"></a>Hooks能做点什么</h3><p>总的来说Hooks的出现就是为了解决这些问题而产生的：</p>
<ul>
<li>useState函数可以初始化状态，为函数组件赋予了状态；</li>
<li>useEffect函数代替了之前的生命周期函数，接受包含命令式，可能有副作用代码的函数；</li>
<li>useContext接受上下文对象，并返回上下文对象，让深嵌套的组件通信变的简单；</li>
<li>useReducer 是useState的代替方案，接受类型为state，action =&gt; newState的reducer，并返回与dispatch方法配对的当前状态；</li>
<li>useCallback返回一个记忆的memoried版本，该版本仅在其输入发生改变时才会更改，尤其是很好的解决了函数需要绑定this这一问题；</li>
<li>useMemo一个纯记忆函数</li>
<li>useRef返回一个可变的ref对象，其.current对象被定义为初始化传递的参数</li>
<li>…</li>
</ul>
<h3 id="Hooks的实现原理"><a href="#Hooks的实现原理" class="headerlink" title="Hooks的实现原理"></a>Hooks的实现原理</h3><p>React会维护俩个链表，一个是currentHook，另外一个是WorkInProgressHook,每一个节点类型都是Hooks，每当hooks函数被调用，react就会创建一个hooks对象，并挂在链表的尾部，函数组件之所以能做一些类组件不能做的事儿，就是因为hook对象，函数组件的状态，计算值，缓存等都是交给hook去完成的，这样组件通过Fiber.memoizedState属性指向hook链表的头部来关联hook对象和当前组件，这样就发挥了hooks的作用。每次调用hooks API的时候，就会首先调用createWorkInProgressHook函数。得到hooks的串联不是一个数组，而是一个链式结构，从根节点workInProgressHook向下通过next进行串联，这也是为什么Hooks不能嵌套使用，不能在条件判断中使用，不能在循环中使用，否则链式就会被破坏。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法(七)--计数排序</title>
    <url>/algorithm/8/</url>
    <content><![CDATA[<p>技数排序的思想：</p>
<ul>
<li>在数组中找到最大的一个，然后生成一个新的数组，计数数组</li>
<li>将原数组中的项作为计数数组的索引，将原数组中项出现的次数记录在计数数组中</li>
<li>将计数组的索引按出现的次数平铺在原数组中，并返回<br><img src="/algorithm/8/8.gif" alt="计数排序"><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var countSort =<span class="function"> (<span class="params">arr</span>, <span class="params">max</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> countArr = <span class="keyword">new</span> <span class="constructor">Array(<span class="params">max</span> + 1)</span></span><br><span class="line">    <span class="keyword">let</span> sortIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!countArr<span class="literal">[<span class="identifier">arr</span>[<span class="identifier">i</span>]</span>]) &#123;</span><br><span class="line">            countArr<span class="literal">[<span class="identifier">arr</span>[<span class="identifier">i</span>]</span>] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        countArr<span class="literal">[<span class="identifier">arr</span>[<span class="identifier">i</span>]</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; countArr.length;j++) &#123;</span><br><span class="line">        <span class="comment">//  判断countArr中存放的次数是大于0的</span></span><br><span class="line">        <span class="keyword">while</span>(countArr<span class="literal">[<span class="identifier">j</span>]</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr<span class="literal">[<span class="identifier">sortIndex</span><span class="operator">++</span>]</span> = j</span><br><span class="line">            <span class="comment">//  在countArr中存放的是数量</span></span><br><span class="line">            <span class="comment">//  所以需要没存一次就减少一次</span></span><br><span class="line">            countArr<span class="literal">[<span class="identifier">j</span>]</span>--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="literal">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>]</span></span><br><span class="line">count<span class="constructor">Sort(<span class="params">arr</span>, 12)</span></span><br><span class="line"><span class="comment">//  [1, 1, 2, 3, 3, 3, 4, 5, 5, 5, 7, 8, 8, 9, 9, 12]</span></span><br></pre></td></tr></table></figure>
注：<br>  我们可以看到，计数排序并不是像其他排序一样，通过比较大小，所以，计数排序是适合特定情况下的排序，计数排序要求输入的数据必须是有确定范围的整数。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>React--React中setState方法的理解？</title>
    <url>/react/5/</url>
    <content><![CDATA[<p>我们知道在react中，setState是调用频率非常高的一个函数。</p>
<h3 id="setState在默认情况下是异步的"><a href="#setState在默认情况下是异步的" class="headerlink" title="setState在默认情况下是异步的"></a>setState在默认情况下是异步的</h3><p>我们知道setState的调用是非常频繁的，那么如果setStates是同步执行，那么就意味着只要调用setState就会修改state,而state的变化，就会直接启动diff算法，从而重新渲染页面，这在性能方面的消耗实在是太过夸张。但是如果是异步执行，那么在多次setState之后，将这些操作一起合并执行。降低性能消耗成为可能。</p>
<h3 id="同步情况下的setState"><a href="#同步情况下的setState" class="headerlink" title="同步情况下的setState"></a>同步情况下的setState</h3><p>在setTimeout和原生事件中，setState是同步执行的。</p>
<h3 id="调用setState会发生什么"><a href="#调用setState会发生什么" class="headerlink" title="调用setState会发生什么"></a>调用setState会发生什么</h3><p>调用setState之后首先会将传入setState的参数和原来的state进行合并，得到新的state，那么这样state就被更新了，因为state的更新就会引起页面的重新渲染，所以，会调用触发所谓的调和过程，react的就以相对高效的方式来自动计算出新旧dom的差异，根据差异最小化来重新构建页面。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React--React的高阶组件是怎么一回事？</title>
    <url>/react/6/</url>
    <content><![CDATA[<p>A higher-order component is a function that takes a component and returns a new component.这是官方给出的关于高阶组件的解释。通俗讲，高阶组件是一个函数接受一个组件返回一个新的组件。</p>
<h3 id="高阶组件的应用场景"><a href="#高阶组件的应用场景" class="headerlink" title="高阶组件的应用场景"></a>高阶组件的应用场景</h3><ul>
<li>代码复用，逻辑抽象</li>
<li>渲染劫持</li>
<li>state抽象和更改</li>
<li>props更改<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="title">extend</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是普通组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hoc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  在此做一些额外的操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
我们可以看到，Hoc就是一个高阶组件，普通组件WrappedComponent没有什么感知。但是Hoc的出现提高了代码逻辑的复用。<h3 id="Hoc和mixin的比较"><a href="#Hoc和mixin的比较" class="headerlink" title="Hoc和mixin的比较"></a>Hoc和mixin的比较</h3>mixin的意思是混入。在vue常有这种操作， 而高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React--react如何做性能优化</title>
    <url>/react/8/</url>
    <content><![CDATA[<p>正在编写中。。。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--如何理解cookie, session, token？</title>
    <url>/javascript/1/</url>
    <content><![CDATA[<p>编写中，敬请期待。。。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>网络与安全</tag>
      </tags>
  </entry>
  <entry>
    <title>React--React中key的作用是什么？</title>
    <url>/react/7/</url>
    <content><![CDATA[<p>这是一个简单的问题。key是react用来追踪哪些列表的元素被修改，被添加或者是被删除的辅助标示。在开发过程中我们需要保证某个元素的key在其同级元素中具有唯一性。</p>
<p>在react的diff算法中react会借助元素的key来判断该元素是最新创建的还是被移动而来的，从而减少不必要的元素渲染。除此之外，react还要根据key来判断元素与本地状态的关联关系。</p>
<p>注意点：</p>
<ul>
<li>key的值一定要和具体的元素一一对应</li>
<li>尽量不要用数组中的index来作为key的值</li>
<li>永远不要视图在render的时候用随机数或者是其他的操作来给key加上不稳定的key，这样造成的性能开销比不加key的情况更糟糕。</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React--React中Fiber算法和stack算法有和优化之处？</title>
    <url>/react/3/</url>
    <content><![CDATA[<p>说到React，版本16将是一个较大的分水岭，尤其是在算法优化方面有了很大的更新，之前是stack算法而之后改成了fiber算法。</p>
<h3 id="stack算法的问题"><a href="#stack算法的问题" class="headerlink" title="stack算法的问题"></a>stack算法的问题</h3><p>在react一切都是组建的思想下，多层组建嵌套将会是一个非常常见的操作，那么生命周期的执行将会非常的繁琐。即，</p>
<ul>
<li>挂在阶段：<br>constructor<br>componentWillMount<br>render<br>componentDidMount</li>
<li>更新阶段<br>shouldComponentUpdate<br>componentWillUpdate<br>render<br>componentDidUpdate<br><img src="/react/3/2.jpg" alt="生命周期"><br>从顶层组件一直往下，知道最底层组建，然后再往上，组件的更新阶段也是同理。stack算法底层使用递归，而递归的方式并不会被轻易打断。那么如果组件的嵌套较深，那么递归的运算就会一直在运行，这样，react的渲染一直会占用着浏览器的主线程，这将会花费很长的时间。那么页面中的其他操作就会无法进行，出现页面卡死的现象。<h3 id="fiber算法原理"><a href="#fiber算法原理" class="headerlink" title="fiber算法原理"></a>fiber算法原理</h3>为了解决stack算法的问题，新版本的react采用了fiber算法，大致是这样做的，就是react将任务分成若干个片段，给每个任务分配一定的时间去执行这个任务，当时间耗尽后，就会检查任务列表中有没有新的或者是优先级更高的任务，如果有执行此任务，如果没有，就继续执行原来的任务。这种方式就是一步渲染的方式。加入fiber的react组件更新分为俩个阶段，以render为界，之前为phase1,之后为phase2。</li>
<li>phase1阶段<br>phase1阶段的生命周期是可中断的。每隔一段时间，就会跳出现有的渲染进程去确定是不是有新的，更重要的任务需要执行，主要是通过requestIdleCallback来构建新的tree，标出重要任务，放入到任务队列中。</li>
<li>phase2阶段<br>phase2阶段的生命周期是不可被中断的。这个阶段就是在render之后执行的，主要就是将phase1阶段的变更一次性的全部更新到DOM上。所以phase1阶段一定是一个完成的任务，否则就会重新再次执行phase1的阶段，这也就导致了某些生命周期可能会执行多次的原因。所以最好保证phase1阶段都做同一件事儿，要不然就会出问题，因此最好都是纯函数。</li>
</ul>
<h3 id="fiber数据结构"><a href="#fiber数据结构" class="headerlink" title="fiber数据结构"></a>fiber数据结构</h3><p>fiber数据结构本质上是一个链表，他有child和sibling属性，指向第一个子节点和相邻兄弟节点，从而构成fiber树，return属性指向其父节点。更新队列updateQueue是一个链表，有first和last属性指向第一个和最后一个update对象，每个fiber结构都有updateQueue属性，指向其更新的队列。每一个fiber都有一个alternate属性开始的时候指向一个自己的clone体，更新的时候会先更新这个alternate,然后通过alternate取代当前的fiber.<br><img src="/react/3/4.jpg" alt="生命周期"></p>
<h3 id="关键API–requestIdleCallback"><a href="#关键API–requestIdleCallback" class="headerlink" title="关键API–requestIdleCallback"></a>关键API–requestIdleCallback</h3><p>window.requestIdleCallback()方法将浏览器空闲时间段内的调用的函数排队。这使得主事件循环上执行后台和低优先级的工作。而不会影响延迟关键事件，如动画和输入响应。函数一般会按照先进先出的顺序执行。而如果回调函数指定执行超时，则有可能为了超时执行函数而打乱执行顺序，那么就可以在空闲回调函数中调用requestIdleCallback(),以便下一次通过时间循环之前调度另外一个回调。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>fiber算法和stack算法，做的优化主要是把任务才拆分成若干个小任务，可以随时控制任务开启和执行，采用异步的方式去执行任务。这样不会丢贞，而stack算法采用递归算法，无法中断，一条道走到黑，因此在动画等要求高的情况下，会出现卡顿现象。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--GET请求和POST请求的区别到底是什么？</title>
    <url>/javascript/2/</url>
    <content><![CDATA[<p>GET请求和POST请求是比较常见的俩种请求，基本都能说出一二，下面是来自w3c的标准答案：</p>
<ul>
<li>GET请求的参数是在url中，而POST请求的参数是request body中；</li>
<li>GET请求会主动被浏览器缓存，而POST请求不会，除非手动设置；</li>
<li>GET请求的参数会被缓存在浏览器的历史记录中，而PSOT请求不会；</li>
<li>GET请求会比POST请求更加安全，因为GET请求的参数是在URL中裸奔；</li>
<li>GET请求在浏览器回退的时候是无害的，而POST请求会再次发起请求；</li>
<li>GET请求的参数的长度会有限制，而POST请求没有；</li>
<li>GET请求对参数的数据类型，GET只接受ASCII字符，而POST没有限制；</li>
<li>GET请求产生的URL地址可以被Bookmark，而POST请求不可以。</li>
</ul>
<p>能答出这些答案的说明你很<code>牛逼</code>，但是离<code>相当牛逼</code>还差点对本质上区别的理解，且听我给你慢慢道来：</p>
<p>本质上来说，GET请求和POST请求其实没什么区别。get请求和post请求是什么，他们是HTTP协议中的俩种请求方法，那么HTTP又是什么呢？HTTP是基于TCP/IP的数据在万维网中传输的协议。因此，HTTP的底层就是TCP/IP，SO，GET请求和POST请求的底层也是TCP/IP,是不是很神奇？所以，GET/POST请求就是TCP链接，他们做的事情其实是一样的，把GET请求的参数放到request body中，把POST请求的参数放到URL上在技术层面将其实是可行的。那么为什么还有上面的那些区别呢？</p>
<p>其实在万维网的世界中，TCP就像是大货车，是用来运送数据的，这其实很安全，并不会出现丢包少包的现象。但有个很致命的问题就是，公路上跑的大货车都完全一样。根本无法区分。所谓无规矩不成方圆。所以，HTTP就应用而生。HTTP给大货车贴上了不同的标签。是GET，POST，PUT或者是DELETE等等？并且规定了所携带的货物（参数）放在那里？比如，GET请求要放到URL中，而POST请求要放到request body中。所以，这就是上面所说的GET请求的参数在URL，而POST请求参数在request body中的原因。</p>
<p>可是上面讲数据量的大小也不一样，这又是为什么呢？这是因为还有个运输公司的角色（浏览器）存在着。不同浏览器运输数据的成本也不相同，因此他们在浏览器和服务器数据传输上做了相应的限制。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p>
<p>所以，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>
<p>但是，但是，但是，但是，还没有完。。。。。</p>
<p>GET和POST还有一个重大区别：<code>GET产生一个TCP数据包；POST产生两个TCP数据包</code></p>
<ul>
<li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</li>
<li>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ul>
<p>这样来说，似乎GET请求会比POST请求更高效，但其实在网络环境比较好的情况下，几乎可以忽略他们的差别。还有一点就是其实并不是所有的浏览器的PSOT请求都是发送俩次，切记fireFox是个例外。</p>
<p>这才是GET请求和POST请求区别的完整版。。。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>网络与安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--关于Promise该了解些什么</title>
    <url>/javascript/10/</url>
    <content><![CDATA[<p>Promise是解决异步编程的解决方案，比传统的回调解决方案，要更加强大合理。所谓Promise,其实就是一个容器，保存在未来才会结束的事件。从语法上讲，Promise是一个对象。他有俩个特点：<br>（1）Promise的状态不受外界影响，Promise是一个异步操作，有三种状态，padding，fulfilled, rejected.只有异步操作的结果，可以决定当前的状态是哪一种？任何其他操作都无法改变这个状态。<br>（2）一旦状态改变就不会再变。任何时候都可以得到这个结果。只能从padding到fulfilled，从padding到rejected.<br>Promise也有缺点：<br>（1）一旦创建，就无法取消。创建就会立即执行，无法中途取消。<br>（2）如果不设置回调，那么Promise内部的错误不会反映到外部。<br>（3）当Promise处于padding状态的时候，并不能确认进行到什么阶段。<br>Promise的一些方法：</p>
<h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>then()方法定义在原型上，他的作用是为Promise实例添加状态时的回调函数。可以有俩个为function的参数，第一个为resolved状态的回调，第二个为rejected状态的回调，他们都是可选的。<code>then()返回一个新的Promise</code>,注意不是原来的那个实例，因此可以采用链式调用，后面接着then()</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。<code>如果then()方法的错误被下一个then()方法的第二个参数捕获，则不会被catch()捕获。</code>。如果 Promise 状态已经变成resolved，再抛出错误是无效的。如果没有使用catch()方法处理错误，那么Promise对象跑出的错误不会传递到外层。另外需要注意的是：<code>在链式调用中，如果前面的then()方法并没有错误，那么就会跳过后面的catch()方法,继续执行后面的then()方法，如果这是出现错误只能被其后面的catch捕获，与前面的catch()无关。还有，当在catch()方法中跑出错误时，本身是不能捕获到错误的，只能是后面的catch()来捕获。</code></p>
<h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h4><p>finally()方法的执行，与Promise的状态无关。finally()方法，旨在与不管promise对象最后的状态是什么都会执行的操作。finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p>Promise.all()的参数是一个数组，数组中是一个个Promise实例。当数组中所有的Promise实例的状态都变成fulfilled，Promise的状态才会变成fulfilled，此时返回值是一个数组。反之，只要有一个状态是rejected,那么Promise的状态就会变成rejected，此时返回值是第一个被rejected的实例的返回值。<br>如果某个promise实例是rejected，但是同时有自己的catch()，那么相对于Promise.all()并不会是rejected状态。而应该是正常返回到Promise.all()的fulfilled状态。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p>Promise.race()和Promise.all()相似，他们区别在于。Promise.race()中的Promise实例，只要有一个状态发生变化，那么Promise.race()的状态就会发生变化。</p>
<h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h4><p>Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。<br>Promise.allSettle()的最大用处在于：<code>他可以返回所有Promise的结果。</code></p>
<h4 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h4><p>该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。</p>
<p>Promise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>Promise.resolve()的作用是将现有对象转化为Promise对象。<br>（1）参数是一个Promise对象<br>此时，什么都不做，返回原来的Promise对象<br>（2）参数是一个thenable对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。<br>（3）参数不是具有then()方法的对象，或根本就不是对象<br>如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。<br>（4）Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。</p>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。后面可以接catch()方法。</p>
<h4 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h4><p>Promise.try()方法有点像try{}catch{}的用法，可以让同步函数，同步执行，异步函数，异步执行的时候，对于抛出的错误可以捕获。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.<span class="keyword">try</span>(<span class="function"><span class="params">()</span> =&gt;</span> database.users.get(&#123;id: userId&#125;))</span><br><span class="line">    .<span class="keyword">then</span>(...)</span><br><span class="line">    .<span class="keyword">catch</span>(...)</span><br></pre></td></tr></table></figure>
<h4 id="Promise的应用"><a href="#Promise的应用" class="headerlink" title="Promise的应用"></a>Promise的应用</h4><p>加载图片，一旦加载完成，Promise的状态就发生改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">        image.onload  = resolve;</span><br><span class="line">        image.onerror = reject;</span><br><span class="line">        image.src = path;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--有哪些情况会产生闭包？</title>
    <url>/javascript/5/</url>
    <content><![CDATA[<p>说起闭包，总是让人觉得陌生又熟悉，听起来似乎并不是那么难，却又好像从来没有知道哪些地方会永=用到闭包。我们来归纳一下，有什么情况下会是闭包。</p>
<h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>在你不知道的Javascript上卷一书中，闭包的定义是这样的：<code>当函数可以记住并访问所在的词法作用域,即使的函数是当前词法作用域之外执行，这时就产生了闭包。</code>怎么理解这句话呢？就是说当函数内部的东西，能在函数外面执行的时候，这就产生了闭包。是不是很简单？那么哪些情况会产生闭包呢？</p>
<h3 id="产生闭包的情况"><a href="#产生闭包的情况" class="headerlink" title="产生闭包的情况"></a>产生闭包的情况</h3><h4 id="（一）回调闭包"><a href="#（一）回调闭包" class="headerlink" title="（一）回调闭包"></a>（一）回调闭包</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到setTimeout定时器中有个函数叫timer,这个函数就是一个回调函数，我们可以看到，timer具有对wait函数作用域的全覆盖。也就是说，timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。当wait被执行1000毫秒之后，它的内部作用域并不会消失，timer 函数依然保有 wait(..)作用域的闭包。所以说，<code>本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!</code>。</p>
<h4 id="（二）自调函数（IIFE模式）"><a href="#（二）自调函数（IIFE模式）" class="headerlink" title="（二）自调函数（IIFE模式）"></a>（二）自调函数（IIFE模式）</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span> <span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">    console.log(a) //   2</span></span></span><br><span class="line"><span class="comment"><span class="function">&#125;</span>)<span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>我们再来看下闭包的定义，<code>函数可以记住并且访问当前词法作用域</code>，<code>使得函数是在当前词法作用域之外执行</code>，这时会产生闭包。所以，IIFE模式看起来并不闭包的一种，因为函数并不是在他定义的作用域之外执行，变量a是普通的词法作用域查找得到的，并不是通过闭包找到的。但是需要注意的是，它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用。</p>
<h4 id="（三）循环闭包"><a href="#（三）循环闭包" class="headerlink" title="（三）循环闭包"></a>（三）循环闭包</h4><p>循环闭包，最常见的就是for循环。看下面的代码（我们期待最后输出的结果是1，2，3，4，5）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">//   6（5次）</span></span><br><span class="line">    &#125;, i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来解释一下，6是怎么来的。我们可以看到循环的终止条件是 i 不再 &lt;=5。条件首次成立时 i 的值是 6。因此，输出显示的是循环结束时 i 的最终值。当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的， 但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。<br>我们来看IIFE模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">    (<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">//   6 (5次)</span></span><br><span class="line">    &#125;, <span class="number">1000</span>))()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不行。但是为什么呢?我们现在显然拥有更多的词法作用域了。的确每个延迟函数都会将IIFE 在每次迭代中创建的作用域封闭起来。如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一 个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log( j );</span><br><span class="line">        &#125;, j*<span class="number">1000</span> );</span><br><span class="line">    &#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok,这样就完美了。这些 IIFE 也不过就是函数，因此我们可以将 i 传递进去，在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p>
<h4 id="（四）块作用域闭包"><a href="#（四）块作用域闭包" class="headerlink" title="（四）块作用域闭包"></a>（四）块作用域闭包</h4><p>是的，你想的没错，就是let.let将一个块转换成一个可以被关闭的作用域看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i; <span class="comment">// 是的，闭包的块作用域!</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( j ); </span><br><span class="line">    &#125;, j*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这还不够完美。for 循环头部的 let 声明还会有一 个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随 后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就完美多了。</p>
<h4 id="（五）模块闭包"><a href="#（五）模块闭包" class="headerlink" title="（五）模块闭包"></a>（五）模块闭包</h4><p>不知道你有没有想过，模块的实现竟然能和闭包联系在一起吗？但是是肯定的。看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myModule</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">23</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAge</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getName,</span><br><span class="line">        getAge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = myModule()</span><br><span class="line">foo.getName() <span class="comment">//    小明</span></span><br><span class="line">foo.getAge() <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>
<p>这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露.</p>
<p>首先，myModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行 外部函数，内部作用域和闭包都无法被创建。<br>其次，myModule() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐 藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。<br>getName() 和 getAge() 函数具有涵盖模块实例内部作用域的闭包(通过调用 myModule() 实现)。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作 用域外部时，我们已经创造了可以观察和实践闭包的条件。<br>模块模式需要具备两个必要条件:</p>
<ul>
<li>必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块 实例)。</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并 且可以访问或者修改私有的状态。</li>
</ul>
<h4 id="六-ES6模块闭包"><a href="#六-ES6模块闭包" class="headerlink" title="(六) ES6模块闭包"></a>(六) ES6模块闭包</h4><p>ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当作独立 的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bar.js</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Let me introduce: &quot;</span> + who;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">export</span> hello;</span><br><span class="line"></span><br><span class="line">foo.js</span><br><span class="line">    <span class="comment">// 仅从 &quot;bar&quot; 模块导入 hello() import hello from &quot;bar&quot;;</span></span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">&quot;hippo&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awesome</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(</span><br><span class="line">        hello( hungry ).toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">export</span> awesome;</span><br><span class="line"></span><br><span class="line">baz.js</span><br><span class="line">    <span class="comment">// 导入完整的 &quot;foo&quot; 和 &quot;bar&quot; 模块</span></span><br><span class="line">    <span class="built_in">module</span> foo <span class="keyword">from</span> <span class="string">&quot;foo&quot;</span>; <span class="built_in">module</span> bar <span class="keyword">from</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        bar.hello( <span class="string">&quot;rhino&quot;</span> )</span><br><span class="line">    );  <span class="comment">// Let me introduce:</span></span><br><span class="line">    rhino foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>
<p>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上(在我们的例子里是 hello)。module 会将整个模块的 API 导入并绑定到一个变量上(在 我们的例子里是 foo 和 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公 共 API。这些操作可以在模块定义中根据需要使用任意多次。模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭 包模块一样。</p>
<p>尽管在这么多的场景中会出现闭包，所以我们一定要多多注意。</p>
<h3 id="使用闭包注意点"><a href="#使用闭包注意点" class="headerlink" title="使用闭包注意点"></a>使用闭包注意点</h3><ul>
<li><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
</li>
<li><p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--作用域是什么？</title>
    <url>/javascript/3/</url>
    <content><![CDATA[<p>Javascript作用域问题，看似简单，想要说明白却着实不简单。那么作用域到底是什么呢？且听我慢慢道来：</p>
<p>想要理解作用域的问题，要先了解一下编译的原理是怎么样的？<br>我们都知道Javascript通常来说是一门动态的，解释执行的语言，但是实际上来说他是一门编译语言，所以，和传统的语言的编译基本类似，只是在某些阶段比较复杂而已。大致需要经历三个阶段：</p>
<h5 id="分词-词法分析"><a href="#分词-词法分析" class="headerlink" title="分词/词法分析"></a>分词/词法分析</h5><p>这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块就是被称为是词法单元。例如：var a = 2;会被分解为 var ，a，=，2，；，空格是否会被当作词法单元，取决于空格的意义。</p>
<h5 id="解析-语法分析"><a href="#解析-语法分析" class="headerlink" title="解析/语法分析"></a>解析/语法分析</h5><p>这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。</p>
<h5 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h5><p>这个过程是将AST树转化为真正代码的过程。具体来说，就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。</p>
<p>简单地说，任何 JavaScript 代码片段在执行前都要进行编译(通常就在执行前)。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且 通常马上就会执行它。</p>
<p>那么是谁做了承接以上三个步骤的共能了呢？下面来介绍几个概念：</p>
<ul>
<li>引擎：负责从头到尾整个javascript的编译和执行过程。</li>
<li>编译器：负责语法分析以及代码生成。</li>
<li>作用域：负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</li>
</ul>
<p>我们来看var a = 2;这样的一个例子：<br>首先，编译器会将这段代码解析成词法单元；<br>然后，将词法单元解析生成一颗结构树；<br>最后，就是代码生成：</p>
<ul>
<li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译;否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。</li>
<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量。如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常!</li>
</ul>
<p>总结:变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如 果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对 它赋值。</p>
<h5 id="LHS查询和RHS查询"><a href="#LHS查询和RHS查询" class="headerlink" title="LHS查询和RHS查询"></a>LHS查询和RHS查询</h5><p>引擎在执行时，就会执行查找，所以，就会执行LHS查询和RHS查询，就是赋值操作的左侧和右侧。当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。</p>
<p>为什么区分 LHS 和 RHS 是一件重要的事情?<br>因为在变量还没有声明(在任何作用域中都无法找到该变量)的情况下，这两种查询的行 为是不一样的。<br>考虑如下代码:</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">    console.log( a + b );</span></span></span><br><span class="line"><span class="comment"><span class="function">    b = a;</span></span></span><br><span class="line"><span class="comment"><span class="function">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">( 2 )</span>;</span></span><br></pre></td></tr></table></figure>
<p>第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变 量，因为在任何相关的作用域中都无法找到它。</p>
<p>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型。相较之下，当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。</p>
<p>“不，这个变量之前并不存在，但是我很热心地帮你创建了一个。”</p>
<p>ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上 有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。</p>
<p>接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。</p>
<p>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p>
<h5 id="嵌套作用域和作用域链"><a href="#嵌套作用域和作用域链" class="headerlink" title="嵌套作用域和作用域链"></a>嵌套作用域和作用域链</h5><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。<br>遍历嵌套作用域链的规则很简单:引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--call,apply,bind的区别以及如何手动实现他们？</title>
    <url>/javascript/7/</url>
    <content><![CDATA[<h2 id="call-apply-bind的区别"><a href="#call-apply-bind的区别" class="headerlink" title="call,apply,bind的区别"></a>call,apply,bind的区别</h2><p>我们知道call, apply, bind的最大用处就是用来改变函数中this的指向问题。那么他们有什么区别呢？</p>
<ul>
<li>call和apply的区别<br>call和apply的第一个参数都是绑定的对象，只是第二个参数不一样，call的第二个参数是一个序列还的列表，apply的第二个参数是一个数组。并且call和apply会立即执行。</li>
<li>call, apply和bind的区别<br>bind方法是事先把fn的this改变为我们要想要的结果，并且把对应的参数值准备好，以后要用到了，直接的执行即可，也就是说bind同样可以改变this的指向，但和apply、call不同就是不会马上的执行。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;李雷&#x27;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;韩梅梅&#x27;</span>,</span><br><span class="line">    age: <span class="number">8</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span>: <span class="title">function</span> <span class="params">(from, to)</span></span> &#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="string">&#x27;岁来自&#x27;</span> + from + <span class="string">&#x27;去往&#x27;</span> + to)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name: <span class="string">&#x27;lily&#x27;</span>,</span><br><span class="line">    age: <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="keyword">fun</span>.call(db, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>)  <span class="comment">//    lily7岁来自北京去往上海</span></span><br><span class="line">obj.<span class="keyword">fun</span>.apply(db, [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>])  <span class="comment">//    lily7岁来自北京去往上海</span></span><br><span class="line">obj.<span class="keyword">fun</span>.bind(db, <span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>)()   <span class="comment">//    lily7岁来自北京去往上海</span></span><br><span class="line">obj.<span class="keyword">fun</span>.bind(db, [<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>])()   <span class="comment">//    lily7岁来自北京,上海去往undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="call-apply的应用"><a href="#call-apply的应用" class="headerlink" title="call, apply的应用"></a>call, apply的应用</h2><h3 id="求最大值和最小值"><a href="#求最大值和最小值" class="headerlink" title="求最大值和最小值"></a>求最大值和最小值</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var</span> arr =<span class="meta"> [1,4,2,5,76,3,20]</span></span><br><span class="line"><span class="attribute">Math</span>.max.call(null, <span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">76</span>,<span class="number">3</span>,<span class="number">20</span>)    // <span class="number">76</span></span><br><span class="line"><span class="attribute">Math</span>.max.apply(null, arr) //    <span class="number">76</span></span><br><span class="line"><span class="attribute">Math</span>.min.call(null, <span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">76</span>,<span class="number">3</span>,<span class="number">20</span>)    // <span class="number">1</span></span><br><span class="line"><span class="attribute">Math</span>.min.apply(null, arr) //    <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="判断数据的类型"><a href="#判断数据的类型" class="headerlink" title="判断数据的类型"></a>判断数据的类型</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(null) <span class="comment">// &quot;[Object Null]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(<span class="number">1</span>) <span class="comment">// &quot;[Object Number]&quot;</span></span><br><span class="line">Object<span class="selector-class">.prototype</span><span class="selector-class">.toString</span><span class="selector-class">.call</span>(&#123;&#125;) <span class="comment">// &quot;[Object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> arr1 = <span class="selector-attr">[1, 2, 3]</span></span><br><span class="line"><span class="selector-tag">var</span> arr2 = <span class="selector-attr">[4, 5, 6]</span></span><br><span class="line"><span class="selector-attr">[]</span><span class="selector-class">.push</span><span class="selector-class">.apply</span>(arr1, arr2)</span><br></pre></td></tr></table></figure>
<h3 id="将伪数组转化为数组"><a href="#将伪数组转化为数组" class="headerlink" title="将伪数组转化为数组"></a>将伪数组转化为数组</h3><h4 id="函数内的arguments"><a href="#函数内的arguments" class="headerlink" title="函数内的arguments"></a>函数内的arguments</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="title">fun</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span></span>);   <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h4 id="含有length属性的对象"><a href="#含有length属性的对象" class="headerlink" title="含有length属性的对象"></a>含有length属性的对象</h4><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">let obj4 = &#123;</span><br><span class="line">	0: 1,</span><br><span class="line">	1: <span class="string">&#x27;thomas&#x27;</span>,</span><br><span class="line">	2: 13,</span><br><span class="line">	<span class="meta">length</span>: 3 // 一定要有<span class="meta">length</span>属性</span><br><span class="line">&#125;;</span><br><span class="line">console<span class="meta">.log(</span><span class="meta">Array</span>.prototype.slice.<span class="meta">call</span>(obj4)); // [1, <span class="string">&quot;thomas&quot;</span>, 13]</span><br></pre></td></tr></table></figure>
<h3 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line">dog.showName()  <span class="comment">// 小明</span></span><br></pre></td></tr></table></figure>
<h2 id="手动实现call-apply-bind"><a href="#手动实现call-apply-bind" class="headerlink" title="手动实现call,apply, bind"></a>手动实现call,apply, bind</h2><h3 id="call的实现"><a href="#call的实现" class="headerlink" title="call的实现"></a>call的实现</h3><p>思路：</p>
<ul>
<li>将函数设置为对象的属性</li>
<li>执行该方法</li>
<li>删除该方法</li>
</ul>
<p>注意：</p>
<ul>
<li>this的参数可能为null或者是undefined，此时，this指向window</li>
<li>this的类型可能为基本类型，原生的call会将其转为对象</li>
<li>函数是有返回值的<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Function.prototype._call = <span class="keyword">function</span> (<span class="keyword">context</span>) &#123;</span><br><span class="line">    <span class="keyword">context</span> = <span class="keyword">context</span> ? Object(<span class="keyword">context</span>) : <span class="keyword">window</span></span><br><span class="line">    <span class="keyword">context</span>.fn = this</span><br><span class="line">    <span class="keyword">let</span> arg = [], result</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arguments.length;i++) &#123;</span><br><span class="line">        arg.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    result = eval(<span class="string">&#x27;context.fn(&#x27;</span> + arg +<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">context</span>.fn;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype._call = <span class="keyword">function</span> (<span class="keyword">context</span>) &#123;</span><br><span class="line">    <span class="keyword">context</span> = <span class="keyword">context</span> ? Object(<span class="keyword">context</span>) : <span class="keyword">window</span></span><br><span class="line">    <span class="keyword">context</span>.fn = this</span><br><span class="line">    <span class="keyword">let</span> arg = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">context</span>.fn(...arg)</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">context</span>.fn</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="apply的实现"><a href="#apply的实现" class="headerlink" title="apply的实现"></a>apply的实现</h3>写过了call,再来实现apply应该不是什么问题，因为apply和call的不同之处只是在于第二个参数，代码如下：<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Function.prototype._apply = <span class="keyword">function</span> (<span class="keyword">context</span>, arr) &#123;</span><br><span class="line">    <span class="keyword">context</span> = <span class="keyword">context</span> ? Object(<span class="keyword">context</span>) : <span class="keyword">window</span></span><br><span class="line">    <span class="keyword">context</span>.fn = this</span><br><span class="line">    var result</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = <span class="keyword">context</span>.fn()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arg = []</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; argument.length;i++) &#123;</span><br><span class="line">            arg.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(<span class="string">&#x27;context.fn(&#x27;</span> + arg + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">context</span>.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype._apply = <span class="keyword">function</span> (<span class="keyword">context</span>, arr) &#123;</span><br><span class="line">    <span class="keyword">context</span> = <span class="keyword">context</span> ? Object(<span class="keyword">context</span>) : <span class="keyword">window</span></span><br><span class="line">    <span class="keyword">context</span>.fn = this</span><br><span class="line">    <span class="keyword">let</span> arg = [...agruments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (Array.isArray(arr) &amp;&amp; arr.length) &#123;</span><br><span class="line">        result = <span class="keyword">context</span>.fn(...arg)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">context</span>.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">context</span>.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bind的实现"><a href="#bind的实现" class="headerlink" title="bind的实现"></a>bind的实现</h3>bind方法的实现主要有以下四点：</li>
<li>bind方法接受参数</li>
<li>bind方法返回一个新函数</li>
<li>bind方法可以指定this</li>
<li>颗粒化<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请正确使用bind&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">var</span> arg = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> obind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArg = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> _this.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> obind ? <span class="built_in">this</span> : context, arg.concat(bindArg))</span><br><span class="line">    &#125;</span><br><span class="line">    obind.prototype = <span class="built_in">this</span>.prototype</span><br><span class="line">    bind.prototype = <span class="keyword">new</span> obind()</span><br><span class="line">    <span class="keyword">return</span> bind</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavasScript--this绑定的原则可不仅仅是谁调用指向谁</title>
    <url>/javascript/6/</url>
    <content><![CDATA[<p>说到this的绑定这绝对是让许多程序员非常头疼的一件事儿，所以经过多年的经验总结出一句被广大程序员认为是标杆的经典：<code>this的指向取决于谁调用，谁调用就取决于谁，否则就指向window</code>.由此可见是函数调用的位置决定了this的指向，这句话看似简单，容易理解，可却并不那么简单，所以还是有必要总结一下this绑定的那些事儿。</p>
<h3 id="this的绑定规则是什么？"><a href="#this的绑定规则是什么？" class="headerlink" title="this的绑定规则是什么？"></a>this的绑定规则是什么？</h3><h4 id="（一）默认规则"><a href="#（一）默认规则" class="headerlink" title="（一）默认规则"></a>（一）默认规则</h4><p>我们先来看一段代码：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">function bar () &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(this.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="title">bar</span><span class="params">()</span></span> <span class="comment">//    2</span></span><br></pre></td></tr></table></figure>
<p>通过上面的代码，我们可以到变量a是声明在全局的变量，当在调用bar的时候，发现this的指向是window全局变量，这时this指向的是全局变量。bar() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用 默认绑定，无法应用其他规则。</p>
<p><code>注意，这里我们使用的是非严格模式，如果是使用严格模式，那么this将会指向的是undefined，并且在严格模式下，this的指向和函数的调用位置无关。</code></p>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>我们先来看一段代码：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">    console.log(this.a)</span></span></span><br><span class="line"><span class="comment"><span class="function">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">obj</span> = <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">    a: 2,</span></span></span><br><span class="line"><span class="comment"><span class="function">    bar: bar</span></span></span><br><span class="line"><span class="comment"><span class="function">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">obj</span>.<span class="title">bar</span><span class="params">()</span> <span class="comment">//    2</span></span></span><br></pre></td></tr></table></figure>
<p>看这段代码，我们声明了一个函数bar，和一个对象obj,他们俩毫无关系，只不过是对象obj有个属性叫bar引用了函数bar，这样以来，在调用到obj.bar()的时候就会使用obj的上下文来引用函数，因此，可以说函数被调用时 obj 对象“拥 有”或者“包含”它。所以当bar被调用的时候，他的落脚点就是指向了obj，当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 bar() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p>
<h5 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h5><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。看下面的代码：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">function bar () &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> obj = &#123;</span><br><span class="line">    <span class="selector-tag">a</span>: <span class="number">2</span>,</span><br><span class="line">    bar: bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="string">&#x27;this is window&#x27;</span></span><br><span class="line"><span class="selector-tag">var</span> foo = obj<span class="selector-class">.bar</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span> <span class="comment">//    this is window</span></span><br></pre></td></tr></table></figure>
<p>可以看到，与上面的代码基本相同，只是多了foo = obj.bar 这一行foo是obj.bar 的一个引用，那么此时foo就是一个不带任何修饰符的函数，那么此时的this就是指向了全局，因此输出的结果是this is window.使用了默认绑定。</p>
<p><code>这里需要注意的是，回调函数也同样使用该规则</code></p>
<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>我们先来描述一个场景，隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。 那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢?</p>
<p>是的，你想的没有错，call和apply,在javascript中的绝大多数函数，以及自己创造的函数都可以通过这俩个函数来实现这一功能。<code>它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定</code>。</p>
<ul>
<li>硬绑定<br>来看下面的代码：<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">function bar () &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(this.a)</span><br><span class="line">&#125;</span><br><span class="line">function foo () &#123;</span><br><span class="line">    bar<span class="selector-class">.call</span>(obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> obj = &#123;</span><br><span class="line">    <span class="selector-tag">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span>   <span class="comment">//  1</span></span><br><span class="line"><span class="function"><span class="title">setTimeout</span><span class="params">(foo)</span></span> <span class="comment">//  1</span></span><br><span class="line">foo<span class="selector-class">.call</span>(window)</span><br></pre></td></tr></table></figure>
我们可以看到，在foo函数中将bar函数的this和obj对象绑定在一起。无论之后如何调用函数foo，它总会手动在 obj 上调用bar。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。而硬绑定的使用场景就:<br>(1)<code>创建一个包裹函数，传入所有的参数并返回接收到的所有值</code>:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a, item)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + item</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>)  <span class="comment">//  2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
(2)<code>创建一个 i 可以重复使用的辅助函数</code>:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">this</span>.a, something );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单的辅助绑定函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(obj, argements)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = bind( foo, obj );</span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3 </span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<code>注意,由于硬绑定是非常常用的方式，所以ES5提供了内置方法来实现：Function.prototype.bind(),返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</code></li>
<li>API调用的‘上下文’<br>确保你的回调 函数使用指定的 this。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( el, <span class="built_in">this</span>.id );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;awesome&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用 foo(..) 时把 this 绑定到 obj </span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj );</span><br><span class="line"><span class="comment">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure>
这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些 代码。<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4>new操作符对我们来说，再熟悉不过了，所以这里说的new绑定主要就说，在执行new操作符，调用构造函数的时候，绑定的this。</li>
</ul>
<ol>
<li>创建(或者说构造)一个全新的对象。</li>
<li>这个新对象会被执行[[原型]]连接。</li>
<li>这个新对象会绑定到函数调用的this。</li>
<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p>
<h3 id="this绑定优先级的判断"><a href="#this绑定优先级的判断" class="headerlink" title="this绑定优先级的判断"></a>this绑定优先级的判断</h3><ol>
<li>函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。<br> var bar = new foo()</li>
<li>函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是指定的对象。<br> var bar = foo.call(obj2)</li>
<li>函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上下文对象。<br> var bar = obj1.foo()</li>
<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。<br> var bar = foo()</li>
</ol>
<h3 id="this绑定的例外"><a href="#this绑定的例外" class="headerlink" title="this绑定的例外"></a>this绑定的例外</h3><p>万物并非全部都在三界之内，有四种猴子却是在这三届之外，那么this绑定四项规则之外也还是有特例存在的。</p>
<h4 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h4><p>如果把null, undefined传入call，apply, bind作为this绑定的对象，那么这些值是会被忽略的，实际应用的是默认绑定。<br>一般情况下，通过apply来展开一个数组，并且当作是参数传入到一个函数中，同样，bind对参数进行颗粒化的时候，也会有同样的操作：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">function foo (<span class="selector-tag">a</span>, b) &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(<span class="string">&#x27;a:&#x27;</span> + <span class="selector-tag">a</span>, <span class="string">&#x27;b:&#x27;</span> + b)</span><br><span class="line">&#125;</span><br><span class="line">foo<span class="selector-class">.apply</span>(null, <span class="selector-attr">[1, 2]</span>)</span><br><span class="line"><span class="selector-tag">var</span> bar = foo<span class="selector-class">.bind</span>(null, <span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="title">bar</span><span class="params">(<span class="number">3</span>)</span></span> <span class="comment">//    a:2, b:3</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，其实函数并不关心this的指向问题，所以，我们需要传入一个null作为站位符。当然了传入null,也是会有副作用的。如果使用了this，那么此操作就将this绑定到了window.</p>
<h4 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h4><p>不知道你还记得吗，又一个这样的方法，Object.create(null)，这个方法就是创建了一个空对象，这个空要比’{}’更为纯粹，因为他连prototype都没有。<br>所以，在call,apply,bind中用var obj = Object.create(null)的obj来做占位符将不会有任何的副作用，那么this就会更加的安全。</p>
<h4 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">    console.log( this.a );</span></span></span><br><span class="line"><span class="comment"><span class="function">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">a</span> = 2;</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    a: 3,</span></span><br><span class="line"><span class="comment">    foo: foo</span></span><br><span class="line"><span class="comment">&#125;</span>; </span><br><span class="line"><span class="keyword">var</span> p = <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    a: 4</span></span><br><span class="line"><span class="comment">&#125;</span>;</span><br><span class="line">o.foo(); <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>注意:对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会被绑定到 undefined，否则 this会被绑定到全局对象。</p>
<h4 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h4><p>软绑定肯定是相对于硬绑定而言，硬绑定这种方式可以把 this 强制绑定到指定的对象，这导致绑定this的灵活性大大降低。如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。那么就是我们说的软绑定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// 捕获所有 curried 参数</span></span><br><span class="line">        <span class="keyword">var</span> curried = [].slice.call( <span class="built_in">arguments</span>, <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(</span><br><span class="line">                (!<span class="built_in">this</span> || <span class="built_in">this</span> === (<span class="built_in">window</span> || <span class="built_in">global</span>)) ?</span><br><span class="line">                    obj : <span class="built_in">this</span></span><br><span class="line">                curried.concat.apply( curried, <span class="built_in">arguments</span> );</span><br><span class="line">        &#125;;</span><br><span class="line">        bound.prototype = <span class="built_in">Object</span>.create( fn.prototype );</span><br><span class="line">        <span class="keyword">return</span> bound;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;name: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    obj2 = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    obj3 = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;obj3&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">var</span> fooOBJ = foo.softBind( obj );</span><br><span class="line">fooOBJ(); <span class="comment">// name: obj</span></span><br><span class="line">obj2.foo = foo.softBind(obj);</span><br><span class="line">obj2.foo(); <span class="comment">// name: obj2 &lt;---- 看!!!</span></span><br><span class="line">fooOBJ.call( obj3 ); <span class="comment">// name: obj3 &lt;---- 看! </span></span><br><span class="line"><span class="built_in">setTimeout</span>( obj2.foo, <span class="number">10</span> );</span><br><span class="line"><span class="comment">// name: obj &lt;---- 应用了软绑定</span></span><br></pre></td></tr></table></figure>
<p>与内置的bind方法相似，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。</p>
<h3 id="箭头函数的this词法"><a href="#箭头函数的this词法" class="headerlink" title="箭头函数的this词法"></a>箭头函数的this词法</h3><p>ES6中出现的箭头函数，又是一个奇葩，它对于this的判断对于上面的规则并不是适用。在箭头函数中this的指向问题应该是<code>根据外层(函数或者全局)作用域来决定this。</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1)</span><br><span class="line">foo.call(obj2)  <span class="comment">//  2并不是3</span></span><br></pre></td></tr></table></figure>
<p>所以，我们可以看到，foo的内部返回的函数中捕获的是foo的this,而且箭头函数绑定的this是无法被修改的。<br>事实上，箭头函数最被常用的地方在于回调函数中，且看下面的几段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">foo()   <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.b)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">bar()   <span class="comment">//  undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(self.c)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fun()   <span class="comment">//  3</span></span><br></pre></td></tr></table></figure>
<p>看上面的三段代码，区别就在于setTimeout的回调函数。</p>
<ul>
<li>第一段回调中如果是箭头函数，那么箭头函数中this的指向取决于外层函数，很明显外层函数的this指向window，所以结果是1</li>
<li>第二段回调函数是一个匿名函数，所以this的只想取决于他自己，所以他的this指向的是函数本身</li>
<li>通过var self = this, this的指向取决与fun函数，所以结果是3，self取代了this的机制</li>
</ul>
<p>所以，一般情况下，我们都会使用self = this 这样的方式来否定this机制，那么，</p>
<ol>
<li>只使用词法作用域并完全抛弃错误this风格的代码;</li>
<li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。</li>
</ol>
<p>（完）</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--关于Set, WeakSet, Map, WeakMap的不同</title>
    <url>/javascript/9/</url>
    <content><![CDATA[<p>Set, WeakSet, Map, WeakMap都是ES2015提供的新的数据结构。</p>
<h3 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h3><p>Set类似于数组，但是成员是唯一的，要求没有重复的成员值。Set本身是一种构造函数。用来生成Set数据结构。可以接受一个数组为参数作为初始化。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let</span> set = new Set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>])<span class="meta"></span></span><br><span class="line"><span class="meta">[...set] // [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>所以，为数组去重是set结构的一个重要用途。同理，那么也可以为字符串去重。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[...<span class="keyword">new</span> <span class="keyword">Set</span>(<span class="string">&#x27;aaccdd&#x27;</span>)].<span class="keyword">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>  <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>
<p>向set结构中不会发生类型转化，所以5和’5’是俩个完全不同的值。这是因为set内部对于值的判断类似于精确元算符号(===)但是，也有例外，<code>NaN被认为是相等的俩个值，俩个对象总是不相等的俩个值</code>。</p>
<p>set的属性和方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span>prototype.constructor <span class="comment">//    构造函数，默认就是Set函数</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span>prototype.size  <span class="comment">//  返回Set成员的数量</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span>prototype.add(value) <span class="comment">// 向Set中添加成员</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span>prototype.has(value) <span class="comment">// 表示是否为Set成员</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span>prototype.delete(value) <span class="comment">//  删除Set成员中的成员，返回是否删除成功true[false]</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Set</span>.</span></span>prototype.clear<span class="literal">()</span>   <span class="comment">//  清空Set所有成员</span></span><br></pre></td></tr></table></figure>
<p>set结构的四种遍历方法:<br>（1）keys()，values()，entries()<br>keys方法、values方法、entries方法返回的都是遍历器对象,由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。<br>（2）forEach()<br>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>(1)区别1:<code>WeakSet的成员只能是对象，而不能是其他类型的值。</code><br>(2)区别2:<code>WeakSet中的对象是弱引用对象，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。</code><br>(3)区别2:<code>WeakMap是不可以遍历的。</code><br>因为WeakMap方法的以上的特点。WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的。所以，WeakMap只有以下三个方法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span>.prototype.<span class="keyword">add</span>(<span class="keyword">value</span>) // 向<span class="keyword">Set</span>中添加成员</span><br><span class="line"><span class="keyword">Set</span>.prototype.has(<span class="keyword">value</span>) // 表示是否为<span class="keyword">Set</span>成员</span><br><span class="line"><span class="keyword">Set</span>.prototype.<span class="keyword">delete</span>(<span class="keyword">value</span>) //  删除<span class="keyword">Set</span>成员中的成员，返回是否删除成功<span class="keyword">true</span>[<span class="keyword">false</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map类似于对象，也是键值的集合。对象是’字符串-值’的对应。Map结构是’值-值’的对应关系，也就是说Map结构的键不仅仅可以是字符串，可以是任意类型的值。是一种更加完善的hash结构。<br>Map本身就是一个构造函数，可以通过new字段来创建Map,接受一个表示键值对的数组作为参数。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>(<span class="meta">[</span></span><br><span class="line">    <span class="meta">[</span><span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span><span class="meta">]</span></span><br><span class="line">    <span class="meta">[</span><span class="string">&#x27;age&#x27;</span>, <span class="number">21</span><span class="meta">]</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>Map结构的属性和方法</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">map<span class="selector-class">.size</span>()  <span class="comment">//  返回map结构成员的总数</span></span><br><span class="line">Map<span class="selector-class">.prototype</span><span class="selector-class">.set</span>(key, value)   <span class="comment">//  为Map添加成员</span></span><br><span class="line">Map<span class="selector-class">.prototype</span><span class="selector-class">.get</span>(key)   <span class="comment">//  为Map成员</span></span><br><span class="line">Map<span class="selector-class">.prototype</span><span class="selector-class">.has</span>(key)   <span class="comment">//  判断是否为Map成员</span></span><br><span class="line">Map<span class="selector-class">.prototype</span><span class="selector-class">.delete</span>(key)   <span class="comment">//  删除Map成员</span></span><br><span class="line">Map<span class="selector-class">.prototype</span><span class="selector-class">.clear</span>(key)   <span class="comment">//  清空Map成员</span></span><br></pre></td></tr></table></figure>
<p>Map结构的遍历同Set一样，也是有四种方法：<br>（1）keys()，values()，entries()<br>keys方法、values方法、entries方法返回的都是遍历器对象,由于 Map 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。<br>（2）forEach()<br>Map 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。<br>Map结构可以同其他数据结构进行相互转化：<br>（1）Map转为数组：扩展运算符[…map]<br>（2）数组转为Map: new Map([[‘name’, ‘张三’], [‘age’, 23]])<br>（3）对象转map：可以通过Object.entries()参照数组转Map,因为Object.entries()返回的是键值对数组<br>（4）map转对象：通过遍历的方式<br>（5）map转JSON，</p>
<ul>
<li>键名是字符串：直接通过JSON.stringify()转化为JSON</li>
<li>键名是非字符串：选择转为数组 JSON，先将map结构转化为数组，再将数组转化为JSON<br>（6）JSON转map同上，只不过是调用JSON.parse()</li>
</ul>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。但是有俩点区别：<br>（1）WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。<br>（2）WeakMap的键名所指向的对象，不计入垃圾回收机制。WeakMap作为临时存储非常方便。WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>常说的单点登陆是如何实现的</title>
    <url>/experience/1/</url>
    <content><![CDATA[<p>编写中，敬请期待。。。</p>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>实战案例</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实现Promise.all()方法</title>
    <url>/coding/2/</url>
    <content><![CDATA[<p>手动实现Promise.all()函数是面试中常做的现场coding考察，那么如何实现呢？我们先来看看Promise.all()的用法。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Promise<span class="selector-class">.all</span>(<span class="selector-attr">[p1, p2, p3]</span>)<span class="selector-class">.then</span>(result =&gt; &#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise.all()方法接受一个数组为参数，数组中是promise，如果数组中的promise都是resolve状态，那么Promise.all()正常返回resolve,返回的数据为一个数组，就是参数中每个promise的结果组成的数组。如果promise.all()中任何一个是reject，那么promise.all()直接reject。<br>所以Promise.all()的特点可以总结为：</p>
<ul>
<li><p>1、接收一个 Promise 实例的数组或具有 Iterator 接口的对象，</p>
</li>
<li><p>2、如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</p>
</li>
<li><p>3、如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</p>
</li>
<li><p>4、只要有一个失败，状态就变为 rejected，返回值将直接传递给回调all() 的返回值也是新的 Promise 对象</p>
</li>
</ul>
<p>来看具体代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  假设我们已经实现了_Promise</span></span><br><span class="line">_Promise.prototype.all = <span class="function">(<span class="params">promiseList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promiseList)) &#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;参数错误！&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> valueList = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseList.length)</span><br><span class="line">        promiseList.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            _Promise.resolve(promise).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">                count++</span><br><span class="line">                valueList[index] = result  <span class="comment">//  将每次返回的结果搜集起来</span></span><br><span class="line">                <span class="keyword">if</span> (count === promiseList.length) &#123;</span><br><span class="line">                    <span class="comment">//  表示所有的promise都有结果，最终将所有的结果都resolve出去</span></span><br><span class="line">                    resolve(valueList)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function"><span class="params">err</span> =&gt;</span> reject(err))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看，其实很简单。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--词法作用域是什么？</title>
    <url>/javascript/4/</url>
    <content><![CDATA[<p>我们知道，作用域是用来查找变量的一套规则，JavaScript引擎在执行代码的时候，会经历三个阶段：词法分析，语法分析，生成代码这三个阶段，我们所说的词法作用域就是发生在词法分析阶段。</p>
<p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。</p>
<p><code>作用域查找会在找到第一个匹配的标识符时停止</code>。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p>
<p>全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a</span><br></pre></td></tr></table></figure>
<p>通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量 如果被遮蔽了，无论如何都无法被访问到。</p>
<p><code>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定。</code>词法作用域查找只会查找一级标识符.</p>
<p>这里比较坑的地方就是欺骗词法。那么什么是欺骗词法呢？如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”(也可以说欺骗)词法作用域呢，这就是所谓的欺骗词法。通常会有俩中机制来实现，但是，<code>欺骗词法作用域会导致性能下降</code>。</p>
<h5 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h5><p>JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书 写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。根据这个原理来理解 eval(..)，它是如何通过代码欺骗和假装成书写时(也就是词法期) 代码就在那，来实现修改词法作用域环境的，这个原理就变得清晰易懂了。在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插 入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>( str ); <span class="comment">// 欺骗!</span></span><br><span class="line">    <span class="built_in">console</span>.log( a, b );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">foo( <span class="string">&quot;var b = 3;&quot;</span>, <span class="number">1</span> ); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明(无论是变量还是函数)，就会对 eval(..) 所处的词法作用域进行修改。技术上，通过一些技巧(已经超出我 们的讨论范围)可以间接调用 eval(..) 来使其运行在全局作用域中，并对全局作用域进行 修改。但无论何种情况，eval(..) 都可以在运行期修改书写期的词法作用域。<br>在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123; <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>( str );</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError: a is not defined &#125;</span></span><br><span class="line">foo( <span class="string">&quot;var a = 2&quot;</span> );</span><br></pre></td></tr></table></figure>
<h5 id="with"><a href="#with" class="headerlink" title="with"></a>with</h5><p>JavaScript 中另一个难以掌握(并且现在也不推荐使用)的用来欺骗词法作用域的功能是 with 关键字。with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。看下面的俩段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 单调乏味的重复 &quot;obj&quot; </span></span><br><span class="line">    obj.a = <span class="number">2</span>;</span><br><span class="line">    obj.b = <span class="number">3</span>;</span><br><span class="line">    obj.c = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 简单的快捷方式 </span></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    c = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但实际上这不仅仅是为了方便地访问对象属性。考虑如下代码:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">foo( o1 );</span><br><span class="line"><span class="built_in">console</span>.log( o1.a ); <span class="comment">// 2</span></span><br><span class="line">foo( o2 );</span><br><span class="line"><span class="built_in">console</span>.log( o2.a ); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2——不好，a 被泄漏到全局作用域上了!</span></span><br></pre></td></tr></table></figure>
<p>with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对 象的属性也会被处理为定义在这个作用域中的词法标识符。尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作 用域中。<br>eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。</p>
<p><code>另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响(限 制)。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。</code></p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。这对性能造成了很大的影响，JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的 词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到 标识符。</p>
<p>但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。</p>
<p>最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简 单的做法就是完全不做任何优化。如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪 明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代 码会运行得更慢这个事实。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实现Promise.then()的链式调用</title>
    <url>/coding/3/</url>
    <content><![CDATA[<p>Promise.then()方法的链式调用的使用，自不必多说，我们再熟悉不过，那么他是如何实现的呢？话不多说直接上代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;PENDING&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULLFILLED = <span class="string">&#x27;FULLFILLED&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;REJECTED&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="comment">//立即调用函数</span></span><br><span class="line">        executor(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    status = PENDING</span><br><span class="line">    <span class="comment">//初始化成功之后的值</span></span><br><span class="line">    success = undefined</span><br><span class="line">    <span class="comment">//初始化失败之后的值</span></span><br><span class="line">    error = undefined</span><br><span class="line">    <span class="comment">//用于保存成功回调，成功回调的默认值需要改成数组，因为只有数组可以存储多个回调函数</span></span><br><span class="line">    successCallback = []</span><br><span class="line">    <span class="comment">//用于保存失败回调，失败回调的默认值需要改成数组，因为只有数组可以存储多个回调函数</span></span><br><span class="line">    failCallback = []</span><br><span class="line">    resolve = (success) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果状态不是等待 则阻止程序执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">this</span>.state = FULLFILLED</span><br><span class="line">        <span class="comment">//保存成功之后的值</span></span><br><span class="line">        <span class="keyword">this</span>.success = success</span><br><span class="line">        <span class="comment">//如果有这个回调，那么要执行这个回调，并且把成功的值传递进去</span></span><br><span class="line">        <span class="comment">//this.successCallback &amp;&amp; this.successCallback(this.success);</span></span><br><span class="line">        <span class="comment">//现在呢数组中存储了多个回调函数，所以遍历数组的每个函数并让其执行,上面的代码已经不符合要求</span></span><br><span class="line">        <span class="comment">//重新编写逻辑</span></span><br><span class="line">        <span class="comment">//这里使用while语句用successCallback.length作为循环条件，如果数组中有值，拿到数组中的第一个回调函数传值并执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.successCallback.length) <span class="keyword">this</span>.successCallback.shift()(<span class="keyword">this</span>.success);</span><br><span class="line">    &#125;</span><br><span class="line">    reject = (rejected) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果状态不是等待 则阻止程序执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state !== PENDING) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">//把promise状态改为失败</span></span><br><span class="line">        <span class="keyword">this</span>.state = REJECTED</span><br><span class="line">        <span class="comment">//保存失败之后的值</span></span><br><span class="line">        <span class="keyword">this</span>.error = rejected</span><br><span class="line">        <span class="comment">//如果有这个回调,那么要执行这个回调，并且把失败的原因传递进去   </span></span><br><span class="line">        <span class="comment">//this.failCallback &amp;&amp; this.failCallback(this.error);</span></span><br><span class="line">        <span class="comment">//现在呢数组中存储了多个回调函数，所以遍历数组的每个函数并让其执行,上面的代码已经不符合要求</span></span><br><span class="line">        <span class="comment">//重新编写逻辑</span></span><br><span class="line">        <span class="comment">//这里使用while语句用failCallback.length作为循环条件，拿到数组中的第一个回调函数传值并执行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.failCallback.length) <span class="keyword">this</span>.failCallback.shift()(<span class="keyword">this</span>.error);</span><br><span class="line">    &#125;</span><br><span class="line">    then(successCallback, failCallback) &#123;</span><br><span class="line">        <span class="comment">//要实现then方法的链式调用必须创建一promise对象</span></span><br><span class="line">        <span class="comment">//新建一个promise对象</span></span><br><span class="line">        <span class="keyword">return</span> new _Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">            <span class="comment">//逻辑判断如果当前状态为成功 则执行成功的回调并且把保存成功的值传递进去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">                <span class="comment">//保存上一个函数的返回值</span></span><br><span class="line">                let x = successCallback(<span class="keyword">this</span>.success)</span><br><span class="line">                <span class="comment">//并且把返回值传递给下一个then方法</span></span><br><span class="line">                resolve(x);</span><br><span class="line">                <span class="comment">//逻辑判断如果当前状态为成功 则执行失败的回调并且把失败的原因传递进去</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">                failCallback(<span class="keyword">this</span>.error)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当前状态为等待，也就是promise状态为pending，</span></span><br><span class="line">                <span class="comment">//如果是等待的话那应该调用成功回调还是失败回调呢</span></span><br><span class="line">                <span class="comment">//那当然是两个回调都无法调用，应为不知道到底是成功了还是还是失败了</span></span><br><span class="line">                <span class="comment">//在这种情况下应该将成功回调和失败回调进行保存</span></span><br><span class="line">                <span class="comment">//保存成功回调函数</span></span><br><span class="line">                <span class="comment">//在这里有一个问题  this.successCallback一次只能存储一个函数这样的不符合要求</span></span><br><span class="line">                <span class="comment">//所以在上面定义successCallback的时候将其定义为数组，这样就可以存储多个回调 ，将回调push进去</span></span><br><span class="line">                <span class="keyword">this</span>.successCallback.push(successCallback);</span><br><span class="line">                <span class="comment">//保存失败回调函数</span></span><br><span class="line">                <span class="keyword">this</span>.failCallback.push(failCallback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = _Promise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);   <span class="comment">//  success</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);   <span class="comment">//  1000</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>完美实现Promise.then()的链式调用。</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实现Javascript中new操作符</title>
    <url>/coding/1/</url>
    <content><![CDATA[<p>想要实现new操作符，首先要知道new操作符都干了什么事儿？</p>
<ul>
<li>创建了一个空，将this指向这个对象</li>
<li>将创建的空对象的<code>__proto__</code>属性继承自构造函数的<code>prototype</code>属性，也就是说是继承构造函数的原型对象上的方法和属性</li>
<li>调用构造函数，将构造函数中的this替换为空对象的this，继承构造函数中的属性</li>
<li>返回函数内部的这个新对象</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function _new (<span class="function"><span class="keyword">fun</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> function () &#123;</span><br><span class="line">        let obj = &#123;&#125;</span><br><span class="line">        obj.__proto__ = <span class="keyword">fun</span>.prototype</span><br><span class="line">        <span class="keyword">fun</span>.call(obj, ...arguments)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Person <span class="built_in">(name</span>, age) &#123;</span><br><span class="line">    this<span class="built_in">.name</span> =<span class="built_in"> name</span></span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = _new(Person)(<span class="string">&#x27;小明&#x27;</span>, <span class="number">3</span>) //=&gt; <span class="built_in">&#123;name</span>: <span class="string">&#x27;小明&#x27;</span>, age: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript--关于对象你不知道的哪些事儿</title>
    <url>/javascript/8/</url>
    <content><![CDATA[<p>学习Javascript，对象是我们再熟悉不过的一种数据结构了，也是一个永远绕不过的话题，但是总有那么些知识，是我们既陌生又熟悉，所以关于对象你不知道的哪些事儿做个归纳总结，还是很有必要的。</p>
<p>创建对象的俩中方式：</p>
<ul>
<li><p>构造形式： <code>var obj = new Object()</code></p>
</li>
<li><p>文字形式：<code>var obj = &#123;&#125;</code></p>
</li>
</ul>
<p>二者的区别：<code>文字形式可以添加多个key/value,而构造形式必须逐个添加key/value</code></p>
<p>数据类型：</p>
<ul>
<li>基本类型：string, number, boolean, undefined, null</li>
<li>引用类型：除了基本类型，其他都是引用类型。</li>
</ul>
<p>typeof [‘引用类型’] ===&gt; Object<br>typeof null ===&gt; Object</p>
<p><code>注意：这些对象在底层都是表示为二进制，在JavaScript中二进制的前三位都是0，那么就会被认为是Object类型，而null的二进制表示全是0，自然前三位也是0，所以typeof null 的结果是Object</code></p>
<p>Javascript的内置对象：Number, String, Boolean, Object, Array, Function, Date, RegExp, Error</p>
<p>访问属性的方式：</p>
<ul>
<li>.操作符–&gt;属性访问</li>
<li>[]操作符–&gt;键访问</li>
</ul>
<p>区别：. 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法 可以接受任意 UTF-8/Unicode 字符串作为属性名。<br>所以，可以通过动态的方式为对象添加属性：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="built_in"> name</span> = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj<span class="built_in">[name</span> + <span class="string">&#x27;Vale&#x27;</span>] = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">obj.nameValue = <span class="string">&#x27;小明&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中数字的用法。</p>
<p>数组：<br>数组是特殊的对象。所以数组也支持[]的方式来访问，但是数组期望数组下标是整数。也仍然可以给数组添加属性：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> myArray = <span class="selector-attr">[<span class="string">&#x27;foo&#x27;</span>, 42, <span class="string">&#x27;bar&#x27;</span>]</span></span><br><span class="line">myArray<span class="selector-class">.bar</span> = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">myArray<span class="selector-class">.length</span> <span class="comment">//   3</span></span><br><span class="line">myArray<span class="selector-class">.baz</span> <span class="comment">//  &#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以看到虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，数组的 length 值并未发 生变化。</p>
<p>对象的属性描述符:<br>自从ES5之后，所有的属性都具备了属性描述符：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">OwnPropertyDescriptor(<span class="params">myObject</span>, &#x27;<span class="params">a</span>&#x27;)</span></span><br><span class="line">&#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="literal">true</span>, <span class="comment">//  可写</span></span><br><span class="line">    configable: <span class="literal">true</span>,   <span class="comment">//  可配置</span></span><br><span class="line">    enumerable: <span class="literal">true</span>    <span class="comment">//  可枚举</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性(如果它是 configurable)并对特性进行设置。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnProperty(myObject, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    writable: <span class="keyword">true</span>,</span><br><span class="line">    configable: <span class="keyword">true</span>,</span><br><span class="line">    enumerable: <span class="keyword">true</span></span><br><span class="line">&#125;)</span><br><span class="line">myObject.a  <span class="comment">//  1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>writable –&gt; 可写，如果值为false,通过myObject.a = 2对对象属性的修改，将会不起作用，在严格模式下，将会报错。</li>
<li>confinable –&gt; 可配置，如果值为false，那么对象就成为不可配置，不管是不是严格模式，尝试修改一个不可配置的属性都会报错，而且，confinable修改成false是单向的，无法撤销。而且如果属性confinable是false，我们可以把writable由true改为false，但是不能false改为true。configurable:false 还会禁止删除这个属性。</li>
<li>enumerable –&gt; 可枚举，如果值为false，比如在for…in循环中，那么该属性就是不可见的，但是依旧可以正常访问。</li>
</ul>
<p>对象的不可变性：</p>
<ul>
<li><p>对象常量–&gt; 结合writable: false 和confinable: false就可以创建一个真正憝常量属性（不可修改，重新定义，删除）</p>
</li>
<li><p>禁止扩展–&gt; Object.preventExtensions(myObject)不允许在myObject对象上扩展新属性</p>
</li>
<li><p>密封对象–&gt; 会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以 修改属性的值)。</p>
</li>
<li><p>冻结对象 –&gt; 会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。</p>
</li>
</ul>
<p>对象的Get和Put:</p>
<ul>
<li>我们知道访问对象属性的方式，应该是先从对象上找某个属性，如果有，那么就返回其属性值，如果没有要查找的属性，那么就回去其原型链找，这个过程就是其内部定义的get方法执行的操作。但是当找不到属性和属性的值是undefined返回的值都是undefined。<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span> myObject = &#123;</span><br><span class="line">    <span class="selector-tag">a</span>: undefined</span><br><span class="line">&#125;</span><br><span class="line">myObject<span class="selector-class">.a</span>  <span class="comment">//  undefined</span></span><br><span class="line">myObject<span class="selector-class">.b</span>  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
<li>Put操作与Get操作有点不同。<ol>
<li>属性是否是访问描述符(参见3.3.9节)?如果是并且存在setter就调用setter。</li>
<li>属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在<br>严格模式下抛出 TypeError 异常。</li>
<li>如果都不是，将该值设置为属性的值。<br>如果对象中不存在这个属性，Put操作会更加复杂。</li>
</ol>
</li>
</ul>
<p>Getter和Setter:<br>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法 应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用。通常来说getter和setter是成对出现的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line"><span class="comment">// 给 a 定义一个 getter </span></span><br><span class="line">    <span class="keyword">get</span> a() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._a_;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">// 给 a 定义一个 setter </span></span><br><span class="line">    <span class="keyword">set</span> a(<span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._a_ = <span class="keyword">val</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.a = <span class="number">2</span>; myObject.a; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>存在性：<br>上面说，当访问一个对象的属性的时候会返回的是undefined，那么到底是不错在这个属性呢，还是属性值是undefeated？这是个问题。</p>
<ul>
<li>in –&gt; 可以通过in操作符来检查属性是否会在这个对象上，而且in操作符会检查原型链上的属性。</li>
<li>hasOwnProperty(…)–&gt;可以检查属性是否会在这个对象，而且不会检查原型链。</li>
<li>Object.prototype.hasOwnProperty. call(myObject,”a”)有的对象可能没有连接到Object.prototype( 通 过 Object. create(null) ）创建。那么hasOwnProperty就会失败。</li>
</ul>
<p>检查可枚举：myObject.propertyIsEnumerable()检查属性是不是存在对象上，且是enumerable:true，不会检查原型链。<br>Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举。并不会检查原型链。</p>
<p>遍历：<br>for…in…通过遍历对象的key来得到属性值，而且遍历的<code>顺序是不可信的</code>。<br>for…of…循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。for..of 循环每次调用 myObject 迭代器对象的 next() 方法时，内部的指针都会向前移动并 返回对象属性列表的下一个值.知道返回done:true遍历结束。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>手动实现一个Promise</title>
    <url>/coding/4/</url>
    <content><![CDATA[<p>手写一个Promise是面试中常考的重点，所以想要手写一个Promise，我们必须先知道Promise是什么，有那些特点。在其原型上有那些方法，需要哪些参数等等相关信息。。。。下面我们就先来总结一下：</p>
<p><code>Promise 是一个对象，代表了未来将要发生的事件，用来传递异步操作的消息。</code></p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li>Promise有三种状态：pending(进行中)、fullfilled(成功)、rejected(失败)；</li>
<li>Promise对象接受一个回掉函数作为参数，该回掉函数接受俩个参数，resolve(成功回调)和reject(失败回调)，resolve的参数除了正常值外，还可以是一个Promise对象的实例，reject的参数通常则是一个Error的实例；</li>
<li>then方法返回一个Promise实例，并接受俩个参数，即resolve和reject函数；</li>
<li>catch方法返回一个新的Promise实例；</li>
<li>finally方法不管是Promise是处于fullfilled状态还是rejected状态，都会执行，而且不接受任何参数；</li>
<li>Promise.all()方法是将多个Promise对象包装成一个新的Promise对象。该方法的参数可以不是一个数组，但是必须是具有iterator接口的数据类型，其返回值是每个每个Promise的实例。其中只要有一个是rejected状态，整个Promise.all()就会进入到catch中，而要想正常返回值，就必须是所有的Promise都是fullfilled状态。</li>
<li>Promise.race()是和Promise.all()相类似，接受同样的参数，但是不同的是，Promise.race()中，只要有一个实例正常返回，该实例就会返回到Promise.race()中；</li>
<li>Promise.resolve()方法是将现有参数转化为Promise对象。如果该方法的参数是一个Promise，那么将不会做任何处理，如果参数是个thenable，那么Promise.resolve()会将该对象转化为Promise对象，并且立即执行then方法。如果参数是一个原始值，或者是一个不具备then方法的对象，则Promise.resolve()方法会返回一个新的Promise，状态为fullfilled,其参数作为then方法中resolve的参数。如果Promise.resolve()不带任何参数，会直接返回一个fullfilled状态的Promise对象。是本轮‘事件循环’的结束时执行。而不是下一轮‘事件循环’的开始；</li>
<li>Promise.reject()同样是返回一个Promise对象。状态为rejected,无聊参数如何，都将会作为reject的参数返回。</li>
</ul>
<h3 id="Promise的优点"><a href="#Promise的优点" class="headerlink" title="Promise的优点"></a>Promise的优点</h3><ol>
<li>统一的异步API：逐步统一各种不同浏览器中异步API,以及不兼容的模式和手法；</li>
<li>与事件相比：Promise更适合处理一次性的结果，在结果计算出来之前，或者之后，注册回调函数都是可以的，都是可以拿到正确的值。但是Promise不能处理多次触发的事件，链式调用是Promise的另一个优点，而事件却不能链式调用；</li>
<li>与回调相比：解决了回调地狱的问题。将异步操作以同步的方式表达出来。</li>
<li>Promise的额外好处是更好的错误处理，写起来更轻松，可以重用一些同步工具等。</li>
</ol>
<h3 id="Promise的缺点"><a href="#Promise的缺点" class="headerlink" title="Promise的缺点"></a>Promise的缺点</h3><ol>
<li>Promise一旦创建，就会立即执行，并且无法终止；</li>
<li>Promise内部抛出的错误，不会暴露到Promise的外部，只有通过错误的回调来检测错误；</li>
<li>当Promise的状态是pending状态的时候，并不能明确Promise进行到什么阶段；</li>
<li>当Promise开始执行到回调的时候，实际Promise部分已经执行完成，但是其中抛出的错误对上下文并不友好。</li>
</ol>
<h3 id="Promise代码"><a href="#Promise代码" class="headerlink" title="Promise代码"></a>Promise代码</h3><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="number">_P</span>romise (fn) &#123;</span><br><span class="line">    const <span class="number">_</span><span class="keyword">this</span> = <span class="keyword">this</span></span><br><span class="line">    <span class="number">_</span><span class="keyword">this</span>.state = <span class="string">&#x27;pending&#x27;</span>     <span class="comment">//  保存Promise的状态</span></span><br><span class="line">    <span class="number">_</span><span class="keyword">this</span>.<span class="keyword">value</span> = <span class="string">&#x27;&#x27;</span>    <span class="comment">//  保存Promise的值 </span></span><br><span class="line">    <span class="number">_</span><span class="keyword">this</span>.reason = <span class="string">&#x27;&#x27;</span>   <span class="comment">//  保存Promise的reason</span></span><br><span class="line">    <span class="number">_</span><span class="keyword">this</span>.onFullfiledCb = []    <span class="comment">//  存储then方法中注册的成功回调函数参数</span></span><br><span class="line">    <span class="number">_</span><span class="keyword">this</span>.onRejectedCb = []     <span class="comment">//  存储then方法中注册的失败回调函数参数</span></span><br><span class="line">    <span class="keyword">function</span> resolve (<span class="keyword">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">_</span><span class="keyword">this</span>.state === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            <span class="number">_</span><span class="keyword">this</span>.state = <span class="string">&#x27;fullfilled&#x27;</span></span><br><span class="line">            <span class="number">_</span><span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span></span><br><span class="line">            setTimeout(<span class="keyword">function</span>() &#123;</span><br><span class="line">                <span class="number">_</span><span class="keyword">this</span>.onFullfiledCb.map(item =&gt; item(<span class="number">_</span><span class="keyword">this</span>.<span class="keyword">value</span>))</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> reject (reason) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">_</span><span class="keyword">this</span>.state === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            <span class="number">_</span><span class="keyword">this</span>.state = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">            <span class="number">_</span><span class="keyword">this</span>.reason = reason</span><br><span class="line">            setTimeout(<span class="keyword">function</span> () &#123;</span><br><span class="line">                <span class="number">_</span><span class="keyword">this</span>.onRejectedCb.map(item =&gt; item(<span class="keyword">this</span>.reason))</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">_P</span>romise.prototype.<span class="keyword">then</span> = <span class="keyword">function</span> (onFullfiled, onRejected) &#123;</span><br><span class="line">    const <span class="number">_</span>self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;fullfilled&#x27;</span>:</span><br><span class="line">            onFullfiled(self.<span class="keyword">value</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;rejected&#x27;</span>:</span><br><span class="line">            onRejected(self.<span class="keyword">value</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            onRejected(self.<span class="keyword">value</span>)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  测试</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="number">_P</span>romise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;我的世界&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="keyword">then</span>(res =&gt; console.log(res)) <span class="comment">//  我的世界</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>函数防抖是什么，手动实现一个防抖函数</title>
    <url>/coding/5/</url>
    <content><![CDATA[<h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><ul>
<li>原理：在事件出发n秒之后再执行回调，如果在这n秒内再次触发，则重新开始计时。</li>
<li>应用场景：<ul>
<li>按钮提交场景：防止多次点击按钮提交。只执行最后一次；</li>
<li>搜索框连续输入场景：防止连续发送请求，只发送最后一次。</li>
</ul>
</li>
</ul>
<h3 id="简易版："><a href="#简易版：" class="headerlink" title="简易版："></a>简易版：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> debounce = <span class="function">(<span class="params">fun, wait</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fun.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><ul>
<li>立即触发，然后等到停止出发n秒后再次重新触发执行。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> debounce = <span class="function">(<span class="params">fun, wait, immediate</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">const</span> callNow = !timer</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">                fun.apply(context, args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                fun.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有返回值"><a href="#有返回值" class="headerlink" title="有返回值"></a>有返回值</h3><ul>
<li>某些情况下，fun可能会有返回值，所以需要返回函数的结果，但是当immediate为false的时候，因为使用了setTimeout,我们将fun.apply(context, args)的返回值赋值给变量，然后再return的时候，值将会一直undefined，所以只有immediate值为true的时候返回函数的执行结果。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> debounce = <span class="function">(<span class="params">fun, wait, immediate</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer, result</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">const</span> callNow = !timer</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">                result = fun.apply(context, args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                fun.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>that’s all!</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>函数截流是什么，手动实现一个截流函数</title>
    <url>/coding/6/</url>
    <content><![CDATA[<h2 id="防抖截流"><a href="#防抖截流" class="headerlink" title="防抖截流"></a>防抖截流</h2><ul>
<li>原理：规定在单位时间内只能触发一次的函数。如果这个单位时间内触发多次函数，但是只执行一次。</li>
<li>应用场景：<ul>
<li>拖拽场景：固定时间内只执行一次，防止高频触发位置变动；</li>
<li>缩放场景：监控浏览器resize；</li>
</ul>
</li>
</ul>
<h3 id="时间戳实现方式"><a href="#时间戳实现方式" class="headerlink" title="时间戳实现方式"></a>时间戳实现方式</h3><ul>
<li>用当前执行的时间戳减去上一次执行时候的时间戳，如果大于设置的等待时间，就执行，反之，就不执行。</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> throttle = (fun, wait) =&gt; &#123;</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">context</span>, <span class="built_in">args</span>, previous = <span class="number">0</span></span><br><span class="line">    <span class="built_in">return</span> () &#123;</span><br><span class="line">        <span class="built_in">let</span> now = +<span class="built_in">new</span> Date()</span><br><span class="line">        <span class="built_in">context</span> = this</span><br><span class="line">        <span class="built_in">args</span> = arguments</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            fun.<span class="built_in">apply</span>(<span class="built_in">context</span>, <span class="built_in">args</span>)</span><br><span class="line">            previous = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用定时器方式"><a href="#使用定时器方式" class="headerlink" title="使用定时器方式"></a>使用定时器方式</h3><ul>
<li>可以通过出发定时器来实现，如果定时器存在就不执行，反之，就执行。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> throttle = (fun, wait) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">            fun.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>that’s all!</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯理化是什么，手动实现一个柯理化函数</title>
    <url>/coding/7/</url>
    <content><![CDATA[<h2 id="函数柯理化"><a href="#函数柯理化" class="headerlink" title="函数柯理化"></a>函数柯理化</h2><ul>
<li>原理：函数柯理化的本质就是将函数接受的多个参数单一化，并且返回接受余下的参数且返回结果的新函数的一种技术。</li>
</ul>
<h3 id="简单版求和"><a href="#简单版求和" class="headerlink" title="简单版求和"></a>简单版求和</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">add</span> (a) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">function</span> (b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title"></span>(c) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">a</span> + b + c</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))   //  <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="函数柯理化-1"><a href="#函数柯理化-1" class="headerlink" title="函数柯理化"></a>函数柯理化</h3><ul>
<li>参数长度固定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span></span><br><span class="line">(judge = <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    args.length === fn.length</span><br><span class="line">    ? fn(...args)</span><br><span class="line">    : <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg));</span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c;</span><br><span class="line"><span class="keyword">const</span> curryAdd = curry(add);</span><br><span class="line"><span class="built_in">console</span>.log(curryAdd(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curryAdd(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curryAdd(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数长度不固定</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">    args.reduce((a, b) =&gt; a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span> <span class="params">(fn)</span> </span>&#123;</span><br><span class="line">    let args = []</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">temp</span> <span class="params">(<span class="rest_arg">...newArgs</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newArgs.length) &#123;</span><br><span class="line">            args = [</span><br><span class="line">                ...args,</span><br><span class="line">                ...newArgs</span><br><span class="line">            ]</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            let val = fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">            args = []</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let addCurry = currying(add)</span><br><span class="line">console.log(addCurry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>))  <span class="comment">//  6</span></span><br></pre></td></tr></table></figure>

<p>that’s all!</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>微信系列--微信小程序授权登陆流程</title>
    <url>/wechat/1/</url>
    <content><![CDATA[<p>小程序开发了这么久。无论是工作还是面试，总会遇到一些问题，需要去总结。登陆问题一直以来都是面试考察的重点，所以我来总结一下小程序登陆的流程。<br>首先，我们需要搞明白，登陆是为了什么？<br>这么说其实有点蠢，但是我们又不得不这么说，因为很多人不知道登陆是干什么,其实从页面效果来看呢，就是要拿到用户信息展示在页面上，从技术角度来说呢，就是要拿到登陆的凭证–token。仅此而已，OK，知道了这俩点呢。我们就可以开干了。</p>
<h3 id="手动授权登陆"><a href="#手动授权登陆" class="headerlink" title="手动授权登陆"></a>手动授权登陆</h3><p>在手动授权之前，我们可以先公共微信提供的API来检查用户是不是已经授权过：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.getSetting</span>()</span><br></pre></td></tr></table></figure>
<p>如果没有授权，那么在新版本的小程序登陆中，微信做了限制，要求用户必须手动，所以我们需要在页面中写点代码：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;button <span class="attribute">class</span>=<span class="string">&#x27;bottom&#x27;</span> <span class="attribute">type</span>=<span class="string">&#x27;primary&#x27;</span> <span class="attribute">open-type</span>=<span class="string">&quot;getUserInfo&quot;</span> <span class="attribute">lang</span>=<span class="string">&quot;zh_CN&quot;</span> <span class="attribute">bindgetuserinfo</span>=<span class="string">&quot;bindGetUserInfo&quot;</span>&gt;授权登录&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里要求必须设置open-type=”getUserInfo”<br>这样点击按钮：<br><img src="/wechat/1/1.png" alt="登陆按钮"><br>就可以调起授权弹窗了。<br><img src="/wechat/1/2.png" alt="手动授权弹窗"><br>点允许，那么授权成功，这时会拿到用户的一些信息，<br><img src="/wechat/1/3.png" alt="用户信息"><br>这样我们再调用：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.login</span>()</span><br></pre></td></tr></table></figure>
<p>用来获取微信的临时凭证，将获取到的信息和appid(小程序管理后台获取)一并发给我们自己的服务端，我们的服务端会拿着这些东西去微信服务器换取openid和session_key,这样我们自己的服务端就可以生成自己自定义的登陆态（token）,r然后返回给前端，前端存储在localStorage.就可以发起业务请求了。<br><img src="/wechat/1/login.png" alt="alt 属性文本"></p>
</li>
<li><p>某些业务场景可能会需要手机号，因为获取手机号。所以需要调用，这里也必须要用户自己触发，且必须设置open-type=”getPhoneNumber”：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;button <span class="keyword">open</span>-type=<span class="string">&quot;getPhoneNumber&quot;</span> bindgetphonenumber=<span class="string">&quot;getPhoneNumber&quot;</span>&gt;获取手机号&lt;/button&gt;</span><br><span class="line">getPhoneNumber(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (e.detail.errMsg !== <span class="string">&#x27;getPhoneNumber:ok&#x27;</span>) &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">            title: <span class="string">&#x27;获取手机号失败&#x27;</span>,</span><br><span class="line">            icon: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>微信授权登陆，大致就是这样！！！！！！！！！！！！！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>微信系列--Android机微信小程序手写输入不能获取完整字符</title>
    <url>/wechat/2/</url>
    <content><![CDATA[<p>问题描述：<br>微信小程序表单输入使用手写输入法，当输入完成后，点击空白处键盘收起，这时，绑定的input事件或者是change事件并不能获取到完整的输入内容。原因在于，<code>当输入的文字有下划线的时候，手机不认为输入完成</code>。</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">van-field</span> <span class="attr">label</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span> <span class="attr">bind:change</span>=<span class="string">&quot;getUsername&quot;</span> <span class="attr">border</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">false</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">value</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">form.userName</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">isReadonly</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">van-field</span>&gt;</span></span></span><br><span class="line"><span class="xml">getUsername (value) &#123;</span></span><br><span class="line"><span class="xml">    this.setData(&#123;&#x27;form.userName&#x27;: value.detail&#125;)</span></span><br><span class="line"><span class="xml">&#125;,</span></span><br></pre></td></tr></table></figure>
<p>解决兼容性问题的方法是添加blur事件。</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">van-field</span> <span class="attr">label</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入姓名&quot;</span> <span class="attr">bind:blur</span>=<span class="string">&quot;getUsernames&quot;</span> <span class="attr">bind:change</span>=<span class="string">&quot;getUsername&quot;</span> <span class="attr">border</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">false</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">value</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">form.userName</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123;&#123;<span class="name">isReadonly</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">van-field</span>&gt;</span></span></span><br><span class="line"><span class="xml">getUsername (value) &#123;</span></span><br><span class="line"><span class="xml">    this.setData(&#123;&#x27;form.userName&#x27;: value.detail&#125;)</span></span><br><span class="line"><span class="xml">&#125;,</span></span><br><span class="line"><span class="xml">getUsernames (value) &#123;</span></span><br><span class="line"><span class="xml">    this.setData(&#123;&#x27;form.userName&#x27;: value.detail.value&#125;)</span></span><br><span class="line"><span class="xml">&#125;,</span></span><br></pre></td></tr></table></figure>
<p>这样可以保证在失去焦点的时候，能获取到全部的输入值。</p>
]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>实战案例</tag>
        <tag>微信小程序</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>微信系列--微信小程序的性能优化分包管理</title>
    <url>/wechat/3/</url>
    <content><![CDATA[<p>小程序开发，累代码，打页面容易，但是当小程序越来越大的时候，性能是一个非常严峻的问题。所以，我们来讲讲小程序的性能优化–分包管理。</p>
<h3 id="微信小程序的加载顺序"><a href="#微信小程序的加载顺序" class="headerlink" title="微信小程序的加载顺序"></a>微信小程序的加载顺序</h3><p><img src="/wechat/3/3.png" alt="小程序加载顺序"><br>小程序的加载流程主要是分三个步骤：</p>
<ul>
<li>资源准备，小程序在准备下载资源包；</li>
<li>业务代码注入和渲染，就是说小程序开始将业务代码注入到视图层和逻辑层，然后开始渲染页面；</li>
<li>异步数据请求，就是当进入首页如果有数据请求，那么现在开始异步数据加载。</li>
</ul>
<p>那么，我们优化应该重点从这三步中开始。</p>
<h3 id="代码包大小的优化"><a href="#代码包大小的优化" class="headerlink" title="代码包大小的优化"></a>代码包大小的优化</h3><p>代码包的大小直接影响到小程序的启动速度，代码包体积越大，下载资源的速度就越慢，代码注入的时间，所以控制代码包的大小就会非常的有必要。<br>（1）控制包的大小</p>
<ul>
<li>开发完成之后，通过开发者工具上传代码，可以打开代码自动压缩的配置，这样可以将包的体积变小，另外也可以通过webpack,gulp等第三方工具压缩代码；</li>
<li>将没有用的代码，文件等及时删除，清理，也可以减少包的体积；</li>
<li>要尽量将图片等资源文件放到CDN上，因为小程序对于资源文件的压缩非常有限。</li>
</ul>
<p>（2）分包加载<br>若果不做分包加载，那么当我们第一次打开小程序的时候，就要将小程序的所有包都下载下来，这时候，那些暂时用不到的包就会导致包下载耗时，所以，我们可以将资源做分包处理，例如将tab页面的包作为主包先下载下来，其他包作为分包，按需加载，这样打开小程序的就能稍微快一点。这样做的优势有：</p>
<ul>
<li>承载更多功能：小程序单个代码包的体积上限为 2M，使用分包可以提升小程序代码包总体积上限，承载更多的功能与服务。</li>
<li>降低代码包下载耗时：使用分包后可以显著启动时需要下载的代码包大小，在不影响功能正常使用的前提下明显提升启动耗时。</li>
<li>降低开发者代码注入耗时：小程序启动时会一次性注入全部的开发者代码，使用分包后可以降低注入的代码量，从而降低注入耗时。</li>
<li>降低页面渲染耗时<br>但是，分包加载也有局限性，那就是用户首次打开分包的页面的时候，需要先进行代码包的下载和注入，这样就会出现一定的延时。<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  app.json中配置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;pages&quot;</span>:[</span><br><span class="line">        <span class="string">&quot;pages/index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pages/logs&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;subpackages&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;packageA&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;pages&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;pages/cat&quot;</span>,</span><br><span class="line">                <span class="string">&quot;pages/dog&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;packageB&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;pack2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;pages&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;pages/apple&quot;</span>,</span><br><span class="line">                <span class="string">&quot;pages/banana&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
分包主要是将分包的页面放到subpackages配置项中。</li>
</ul>
<p>（3）分包预加载<br>因为分包加载的局限性。所以可以预加载小程序的分包。也就是说，在主包加载完成之后，静默开启分包的加载和注入。这是个无感的过程。<code>分包预加载需要注意的是：同一个分包中的页面享有共同的预下载大小限额2M，限额会在工具中打包时校验，因此不能把所有的分包页面都配置到分包预加载的配置中，只配置主包页面会跳转的页面即可。</code></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">//  app.js中配置</span><br><span class="line">&#123;</span><br><span class="line">    &quot;pages&quot;: [&quot;pages/<span class="keyword">index</span><span class="string">&quot;],</span></span><br><span class="line"><span class="string">    &quot;</span>subpackages<span class="string">&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>root<span class="string">&quot;: &quot;</span>important<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>pages<span class="string">&quot;: [&quot;</span><span class="keyword">index</span><span class="string">&quot;],</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>root<span class="string">&quot;: &quot;</span>sub1<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>pages<span class="string">&quot;: [&quot;</span><span class="keyword">index</span><span class="string">&quot;],</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>name<span class="string">&quot;: &quot;</span>hello<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>root<span class="string">&quot;: &quot;</span><span class="keyword">path</span>/<span class="keyword">to</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>pages<span class="string">&quot;: [&quot;</span><span class="keyword">index</span><span class="string">&quot;]</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>root<span class="string">&quot;: &quot;</span>sub3<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>pages<span class="string">&quot;: [&quot;</span><span class="keyword">index</span><span class="string">&quot;]</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>root<span class="string">&quot;: &quot;</span>indep<span class="string">&quot;,</span></span><br><span class="line"><span class="string">            &quot;</span>pages<span class="string">&quot;: [&quot;</span><span class="keyword">index</span><span class="string">&quot;],</span></span><br><span class="line"><span class="string">            &quot;</span>independent<span class="string">&quot;: true</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &quot;</span>preloadRule<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;</span>pages/<span class="keyword">index</span><span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">            &quot;</span>network<span class="string">&quot;: &quot;</span><span class="keyword">all</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">                &quot;</span>packages<span class="string">&quot;: [&quot;</span>important<span class="string">&quot;]</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            &quot;</span>sub1/<span class="keyword">index</span><span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">                &quot;</span>packages<span class="string">&quot;: [&quot;</span>hello<span class="string">&quot;, &quot;</span>sub3<span class="string">&quot;]</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            &quot;</span>sub3/<span class="keyword">index</span><span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">                &quot;</span>packages<span class="string">&quot;: [&quot;</span><span class="keyword">path</span>/<span class="keyword">to</span><span class="string">&quot;]</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            &quot;</span>indep/<span class="keyword">index</span><span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">                &quot;</span>packages<span class="string">&quot;: [&quot;</span>__APP__<span class="string">&quot;]</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>分包预加载主要是preloadRule中，key 是页面路径，value 是进入此页面的预下载配置。</p>
<p>（4）独立分包<br>从分包页面启动时，必须依赖于主包的下载和注入，启动所以就会收到主包大小的限制，因此，我们就需要独立分包，这样在启动页面的时候，就可以不依赖于主包，减少了主包的下载和注入时间，通常会将广告，活动等具有独立逻辑的代码做独立分包。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  app.json中配置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;pages&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;pages/index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pages/logs&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;subpackages&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;moduleA&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;pages&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;pages/rabbit&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pages/squirrel&quot;</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">        <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;moduleB&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;pages&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;pages/pear&quot;</span>,</span><br><span class="line">            <span class="string">&quot;pages/pineapple&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;independent&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>独立分包通过在app.json的subpackages字段中对应的分包配置项中定义independent字段声明对应分包为独立分包。</p>
<h3 id="代码注入的优化"><a href="#代码注入的优化" class="headerlink" title="代码注入的优化"></a>代码注入的优化</h3><p>（1）减少启动过程中的同步调用<br>在小程序的启动过程中，会依次调用App.onLaunch, App.onShow, Page.onLoad, Page.onShow生命周期函数。应避免执行复杂的计算逻辑或过度使用Sync结尾的同步API。对于 getSystemInfo, getSystemInfoSync 的结果应进行缓存，避免重复调用。</p>
<p>（2）使用依赖注入<br>通常情况下，在小程序启动时，启动页面所在分包和主包（独立分包除外）的所有JS代码会全部合并注入，包括其他未访问的页面以及未用到自定义组件，造成很多没有使用的代码注入到小程序运行环境中，影响注入耗时和内存占用。<br>自基础库版本 2.11.1 起，小程序支持仅注入当前页面需要的自定义组件和当前页面代码，以降低小程序的启动时间和运行时内存。开发者可以在 app.json配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  app.json配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;lazyCodeLoading&quot;</span>: <span class="string">&quot;requiredComponents&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>注意：添加这项配置后，未使用到的代码文件将不被执行。</code></p>
<h3 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h3><p>（1）提高首屏渲染速度<br>大部分小程序在渲染首页时，需要依赖服务端的接口数据，小程序为开发者提供了提前发起数据请求的能力：</p>
<ul>
<li>数据预拉取：能够在小程序冷启动的时候通过微信后台提前向第三方服务器拉取业务数据，当代码包加载完时可以更快地渲染页面，减少用户等待时间，从而提升小程序的打开速度。</li>
<li>周期性更新：在用户未打开小程序的情况下，也能从服务器提前拉取数据，当用户打开小程序时可以更快地渲染页面，减少用户等待时间。</li>
</ul>
<p>（2）骨架屏<br>页面数据未准备好之前，避免长时间白屏，可以使用骨架屏来显示页面结构。提升用户等待的意愿。</p>
<p>（3）缓存数据<br>小程序提供了wx.setStorage、wx.getStorage等读写本地缓存的能力，数据存储在本地，返回的会比网络请求快。如果开发者基于某些原因无法采用数据预拉取与周期性更新，我们推荐优先从缓存中获取数据来渲染视图，等待网络请求返回后进行更新。</p>
<p>（4）精简首屏数据<br>我们推荐开发者延迟请求非关键渲染数据，与视图层渲染无关的数据尽量不要放在 data 中，加快页面渲染完成时间。</p>
<h3 id="运行时性能优化"><a href="#运行时性能优化" class="headerlink" title="运行时性能优化"></a>运行时性能优化</h3><h4 id="setData"><a href="#setData" class="headerlink" title="setData"></a>setData</h4><p>小程序中setData的调用是最为频繁的。也是最容易引起性能问题的接口。</p>
<h5 id="setData的工作原理"><a href="#setData的工作原理" class="headerlink" title="setData的工作原理"></a>setData的工作原理</h5><p><code>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。</code></p>
<h5 id="setData的错误使用"><a href="#setData的错误使用" class="headerlink" title="setData的错误使用"></a>setData的错误使用</h5><ol>
<li>频繁调用setData</li>
</ol>
<ul>
<li>Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；</li>
<li>渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；</li>
</ul>
<ol start="2">
<li><p>每次 setData 都传递大量新数据<br>由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程.</p>
</li>
<li><p>后台态页面进行 setData<br>当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。</p>
</li>
</ol>
<h4 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h4><p>目前图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面。在 iOS 上，小程序的页面是由多个 WKWebView 组成的，在系统内存紧张时，会回收掉一部分 WKWebView。从过去我们分析的案例来看，大图片和长列表图片的使用会引起 WKWebView 的回收。除了内存问题外，大图片也会造成页面切换的卡顿。我们分析过的案例中，有一部分小程序会在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况。当前我们建议开发者尽量减少使用大图片资源。</p>
]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>实战案例</tag>
        <tag>微信小程序</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>微信系列--微信小程序路由跳转问题</title>
    <url>/wechat/4/</url>
    <content><![CDATA[<p>最近在开发微信小程序，因为业务需要，页面跳转比较多，总是会出现连续跳转多次后，不能再跳转，或者是屏幕向右滑动回退不能到想要的页面等问题，这都是因为小程序路由栈管理的问题。在微信的官方文档中有五个方法,我们就来总结一下这五个方法的用法，以及遇到的一些坑：</p>
<ul>
<li>wx.switchTab(Object object)：switchTab这个方法比较好理解，它主要是用来tab页面的跳转，并且此时会关闭其他非tab的页面；</li>
<li>wx.reLaunch(Object object)：可以跳转到任意的页面；</li>
<li>wx.navigateTo(Object object)：正常的页面跳转，上一个页面会保留；</li>
<li>wx.redirectTo(Object object)：页面重定向，上一个页面会被关闭，不能返回；</li>
<li>wx.navigateBack(Object object)：页面回退到上一个页面，关闭当前页面。</li>
</ul>
<p>下面介绍小程序的栈情况：<br>小程序的想要管理小程序的页面，小程序是通过本身创立的一个小程序栈来管理的。如图：<br><img src="/wechat/4/z-1.png" alt="小程序页面栈示意图"><br>我们知道，栈是遵循先进先出的规则，所以小程序官方提供了getCurrentPages()的方法来获取小程序的栈结构，第一个元素为首页，最后一个元素为当前页面，下程序规定栈中最多存放5个页面。<br><img src="/wechat/4/z-2.png" alt="小程序页面栈示意图"><br>当页面中的栈大于5之后，使用wx.navigateTo()就不会再跳转页面。我们需要明白的一个重要问题就是，当客户按返回按钮的时候究竟会跳转到那个界面，这是我们分析页面栈变化的的意义。首先我们在页面中调用两次navigateTO，页面栈情况如下。<br><img src="/wechat/4/z-3.png" alt="小程序页面栈示意图"><br>这时显示的界面是pageC ，如果客户在此时返回则会一切正常，回退的第一个界面是pageB，然后是pageA。但是如果在pageC 界面调用  wx.redirectTo({url:’pageD’}) 则情况就会不一样了，我们先看一下跳转到pageD后页面栈的情况如何。<br><img src="/wechat/4/z-4.png" alt="小程序页面栈示意图"><br>根据栈的情况，我们可以分析出。如果使用 wx.redirectTo跳转到pageD页面，然后在回退的时候是不能再次回退到pageC的，而会直接回退到pageB。<br>通过上面对页面栈的分析，我们可以看到栈的变化是会影响客户回退页面的顺序的，所以根据自己的需要合理的使用不同的跳转方法是非常重要的。如果使用不当就会导致跳转混乱让人摸不清头脑。<br>下面分析一种调转重复页面的情况。如果我们的pageB页面是一个数据列表页面，比如商品列表，pageC是一个商品的编辑界面，一般我们会通过pageB然后进如pageC对商品进行修改，修改后返回pageB。这是很常见的一个场景，但是如果使用不当机会出现如下情况：<br><img src="/wechat/4/z-5.png" alt="小程序页面栈示意图"><br>如图所示栈中出现了两个相同的pageB界面，这个时候如果用户按退出键就会出现一个页面出现2次的情况，而且有一个界面的数据也是旧的数据。因此为了避免这个问题，我们应该在 PageC 页面避免将 PageB重复压入栈中，所以在pageC页面 使用wx.navigateBack({delta:1}); 进行页面回退。而数据刷新的问题则在页面的onShow函数中进行即可。<br><img src="/wechat/4/z-6.png" alt="小程序页面栈示意图"></p>
<p>Tips:</p>
<ul>
<li>navigateTo, redirectTo 只能打开非 tabBar 页面。</li>
<li>switchTab 只能打开 tabBar 页面。</li>
<li>reLaunch 可以打开任意页面。</li>
<li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li>
<li>调用页面路由带的参数可以在目标页面的onLoad中获取。</li>
</ul>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html">更多详情。。。。</a></p>
]]></content>
      <categories>
        <category>wechat</category>
      </categories>
      <tags>
        <tag>实战案例</tag>
        <tag>微信小程序</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript--数据类型</title>
    <url>/ts/1/</url>
    <content><![CDATA[<p>Typescript是Javascript的超集，所以大多数的数据类型和Javascript相同。下面是Typescript的数据类型：</p>
<ul>
<li>字符串类型(String)</li>
<li>数字类型(Number)</li>
<li>布尔类型(Boolean)</li>
<li>数组类型(Array)</li>
<li>元组类型(tuple)</li>
<li>枚举类型(enum)</li>
<li>任意类型(any)</li>
<li>null 和 undifined</li>
<li>void类型</li>
<li>never类型</li>
</ul>
<p>在typescript中大概有这么十种数据类型。</p>
<h6 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h6><p>字符串类型的生明必须声明类型，<code>一旦声明类型，不能再赋值其他类型的数据</code>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1:<span class="keyword">string</span> = &#x27;<span class="keyword">this</span> is a <span class="keyword">string</span>!&#x27;</span><br><span class="line"><span class="keyword">var</span> str2:<span class="keyword">string</span> = <span class="number">345</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="number">&#x27;he</span>llo world&#x27;</span><br><span class="line">str2 = <span class="number">123</span>    <span class="comment">//  报错</span></span><br></pre></td></tr></table></figure>

<h6 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h6><p>数字类型的生明必须声明类型，<code>一旦声明类型，不能再赋值其他类型的数据</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1:<span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> num2:<span class="built_in">number</span> = <span class="number">345</span></span><br><span class="line"></span><br><span class="line">num1 = <span class="number">543</span></span><br><span class="line">num2 = <span class="string">&#x27;num&#x27;</span>    <span class="comment">//  报错</span></span><br></pre></td></tr></table></figure>

<h6 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h6><p>布尔类型的值只有俩个：true和false，而且声明的时候，必须声明类型，<code>一旦声明类型，不能再赋值其他类型的数据</code>。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> bol1:<span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="built_in">var</span> bol2:<span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">bol1 = <span class="literal">false</span></span><br><span class="line">bol2 = <span class="number">123</span> <span class="comment">//   报错</span></span><br></pre></td></tr></table></figure>

<h6 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h6><p>定义数组的方式有俩种：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">let arr:number<span class="comment">[]</span> = <span class="comment">[1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>上面是俩种定义数组的方式，但是<code>在数组中只能是number类型，不能有其他类型的值</code></p>
<h6 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h6><p>元组类型属于数组的一种，元组可以指定数组中每个元素的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr:[<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>] = [<span class="number">123</span>, <span class="string">&#x27;hello world&#x27;</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以看到，数组中的每一个元素必须要与之前的类型一一对应。</p>
<h6 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h6><p>事先考虑到某一变量可能取到的值，尽量用自然语言中的含义清楚的词来表示他的每一个值，这种方法称为枚举方法，用这种方法定义的类型称为枚举类型。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">enum <span class="built_in">Flag</span> = &#123;success = <span class="number">1</span>, error = -<span class="number">1</span>&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">Flag</span>.success)   <span class="comment">//  1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; <span class="built_in">red</span>, <span class="built_in">blue</span>, white &#125;</span><br><span class="line">var c:Color = Color.<span class="built_in">red</span> <span class="comment">//  0 返回的是索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color &#123; <span class="built_in">red</span>, <span class="built_in">blue</span> = <span class="number">5</span>, white &#125;</span><br><span class="line">var c:Color = Color.<span class="built_in">red</span> <span class="comment">//  0 返回的是索引</span></span><br><span class="line">var c:Color = Color.<span class="built_in">blue</span> <span class="comment">//  5 返回的是索引</span></span><br><span class="line">var c:Color = Color.white <span class="comment">//  6 返回的是索引,会以上一个为基准返回</span></span><br></pre></td></tr></table></figure>

<h6 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h6><p>任意类型用any来表示，实际和js中不指定类型有点相似。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">var s:<span class="attr">any</span> = <span class="number">123</span></span><br><span class="line"><span class="attr">s</span> = &#x27;hello&#x27;</span><br><span class="line"><span class="attr">s</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>以上的这些操作的都是被允许的。<br><code>因为在ts中没有Object这个类型，那么当数据是对象的时候，可以指定其为any类型</code>。</p>
<h6 id="null-和-undifined"><a href="#null-和-undifined" class="headerlink" title="null 和 undifined"></a>null 和 undifined</h6><p>null和undefined是其他类型的子类型。null和undefined用来定义不同的数据类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num:<span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<h6 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h6><p>void类型表示没有任何类型，一半用于定义方法的时候没有任何返回值。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run1</span> <span class="params">()</span>: void </span>&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;2134566&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">run1()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run2</span> <span class="params">()</span>: number </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">111</span></span><br><span class="line">&#125;</span><br><span class="line">run2()</span><br></pre></td></tr></table></figure>

<h6 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h6><p>never类型是其他类型，包含undefined 和 null,代表从不出现的值，这就意味着never类型的变量只能被never类型赋值。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">var a:never</span><br><span class="line"><span class="function"><span class="title">a</span> = (<span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;throw&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>never类型基本用不到！</p>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript--接口的使用</title>
    <url>/ts/4/</url>
    <content><![CDATA[<h6 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h6><p>在面向对象的编程中，接口是一种规范的定义，它定义了行为和动作的规范。在程序设计里，接口起到了限制和规范的作用。接口定义了某一批类所需要遵守的规范，接口不关心类内部的状态数据。也不关心这些类的内部方法实现的具体细节。他只关心这些类必须提供某些方法。提供这些方法的类就可以满足实际需求。typescript中的类有点类似于java，同时还增加了更加灵活的接口类型。包括属性，方法，可索引和类等。</p>
<h5 id="属性接口"><a href="#属性接口" class="headerlink" title="属性接口"></a>属性接口</h5>]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝是什么，如何手动实现深拷贝</title>
    <url>/coding/8/</url>
    <content><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>对于字符串等简单类型的数据来说，浅拷贝就是赋值运算，而对于对象等引用类型的数据来说浅拷贝是对他们的地址的复制。</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝主要是对引用类型的数据说的，深拷贝的主要目的是重新开辟一个栈，俩个数据结构对应俩个不同的地址，修改其中之一，对另一个完全没有影响。</p>
<h3 id="实现深拷贝的方式"><a href="#实现深拷贝的方式" class="headerlink" title="实现深拷贝的方式"></a>实现深拷贝的方式</h3><h4 id="JSON-Stringfy"><a href="#JSON-Stringfy" class="headerlink" title="JSON.Stringfy"></a>JSON.Stringfy</h4><p>JSON.Stringfy是实现数据拷贝的一种方式，但是该方法也是有坑的：</p>
<ul>
<li>当对象中存在NaN，Infinity，-Infinity的时候，将会被转为null;</li>
<li>当对象中存在时间对象，JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串;</li>
<li>当对象中存在RegExp、Error对象，则序列化的结果将只得到空对象;</li>
<li>当对象中存在函数，undefined，则序列化的结果会把函数， undefined丢失;</li>
</ul>
<h4 id="不考虑循环引用"><a href="#不考虑循环引用" class="headerlink" title="不考虑循环引用"></a>不考虑循环引用</h4><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">var deepClone = (<span class="type">item</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof <span class="type">item</span> !== <span class="string">&#x27;object&#x27;</span> || <span class="type">item</span> === null) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">item</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = Array.isArray(<span class="type">item</span>) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span><span class="built_in"> key</span> <span class="keyword">in</span> <span class="type">item</span>) &#123;</span><br><span class="line">        result<span class="built_in">[key</span>] = deepClone(<span class="type">item</span><span class="built_in">[key</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有循环引用"><a href="#有循环引用" class="headerlink" title="有循环引用"></a>有循环引用</h4><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: obj</span><br><span class="line">&#125;</span><br><span class="line">var deepClone = (item) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">copy</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">set</span> = <span class="keyword">new</span> Set()</span><br><span class="line">    <span class="keyword">for</span> (let [<span class="built_in">key</span>, value] of <span class="keyword">Object</span>.entries(item)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">Object</span>(value) !== value) &#123;</span><br><span class="line">            <span class="built_in">copy</span>[<span class="built_in">key</span>] = value</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>.has(value)) &#123;</span><br><span class="line">                <span class="built_in">copy</span> = &#123;...value&#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">set</span>.<span class="built_in">add</span>(value)</span><br><span class="line">                <span class="built_in">copy</span>[<span class="built_in">key</span>] = deepClone(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript--类的使用</title>
    <url>/ts/3/</url>
    <content><![CDATA[<h6 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h6><p>在ts中类的定义是通过class来定义的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span> <span class="comment">//  属性，省略了public字段</span></span><br><span class="line">    <span class="title">constructor</span> (<span class="params">name:<span class="built_in">string</span></span>) &#123;    <span class="comment">//  构造函数，实例化类时，触发的方法</span></span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    run ():<span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">p.run() <span class="comment">//  张三</span></span><br></pre></td></tr></table></figure>

<h6 id="ts中实现继承"><a href="#ts中实现继承" class="headerlink" title="ts中实现继承"></a>ts中实现继承</h6><p>在ts中实现继承的方式是通过<code>extends</code>、<code>super</code>字符来实现的。父类和子类的方法一至。子类可以扩展自己的方法。如果子类和父类有同名方法的时候，调用子类方法，那么优先执行子类方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    name: string</span><br><span class="line">    constructor (name: string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    run ():string &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">children</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    constructor (name: string) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name) <span class="comment">//  初始化父类的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="类中的修饰符"><a href="#类中的修饰符" class="headerlink" title="类中的修饰符"></a>类中的修饰符</h6><p>在ts的类中定义属性的时候提供了三种修饰符。<br>public      公有属性，在类，子类，以及类外都可以被访问<br>protected   保护属性，在类，子类，中可以被访问，在类之外不能被访问<br>private     私有属性，在类中可以被访问，在子类，以及类外是不能被访问的</p>
<p>如果属性不加任何修饰符，那么默认是public,表示公有属性。</p>
<h6 id="静态方法和静态属性"><a href="#静态方法和静态属性" class="headerlink" title="静态方法和静态属性"></a>静态方法和静态属性</h6><p>ts中静态方法和属性通过static字符来定义，并且通过类名来调用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name:<span class="built_in">string</span> = <span class="string">&#x27;小明&#x27;</span>  <span class="comment">//  这是定义的静态属性</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  静态方法</span></span><br><span class="line">    <span class="keyword">static</span> getName ():<span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  实例方法</span></span><br><span class="line">    run ():<span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  调用静态方法</span></span><br><span class="line">Person.getName()    <span class="comment">//  小明</span></span><br><span class="line"><span class="comment">//  调用实例方法，必须先创建实例，通过实例来调用</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;小刚&#x27;</span>)</span><br><span class="line">p.run() <span class="comment">//  小刚</span></span><br></pre></td></tr></table></figure>

<h6 id="继承多态"><a href="#继承多态" class="headerlink" title="继承多态"></a>继承多态</h6><p>父类定义一个方法不去实现，让子类来实现，并且在子类中可以有不同的表现形式。多态也是继承的一种表现。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public name:string</span><br><span class="line">    constructor(name:string) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    eat ():void &#123;</span><br><span class="line">        console.log(`$&#123;<span class="keyword">this</span>.name&#125;爱吃肉！`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    eat ():void &#123;</span><br><span class="line">        <span class="comment">//  do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    eat ():void &#123;</span><br><span class="line">        <span class="comment">//  do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h6><p>ts中的抽象类是提供其他类继承的基类，不能直接实例化。用abstract关键字来实现抽象类和抽象方法。抽象类中的抽象方法不包含具体的实现并且必须在派生类中实现。abstruct字段只能放到抽象类中。要求子类中必须包含抽象类中的方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">abstruct <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    abstruct eat():any</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  let p = new Person()    错误写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    constructor(name:string) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    eat():any &#123;</span><br><span class="line">        <span class="comment">//  do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript--函数方法</title>
    <url>/ts/2/</url>
    <content><![CDATA[<h6 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a>函数的定义方式</h6><p>函数的定义方式有俩种，即function定义方式和匿名函数方式，但是要求指定返回值类型。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span> <span class="params">()</span>:number </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span> <span class="params">()</span>:void </span>&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>function方式定义的的函数，并且要求返回值是一个数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fun3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>):<span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fun4 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="typescript中的传参方式"><a href="#typescript中的传参方式" class="headerlink" title="typescript中的传参方式"></a>typescript中的传参方式</h6><ul>
<li><p>ts中的参数需要指定参数的类型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span> <span class="params">(a:<span class="type">number</span>)</span></span>:number &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求传入的参数a是一个number类型，并且该函数返回一个number类型的返回值。</p>
</li>
<li><p>ts中可以用<code>?</code>来表示某个参数是可选参数，但是<code>必须要放到所有参数的最后面</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span> <span class="params">(name:<span class="type">string</span>, age?:<span class="type">number</span>)</span></span>:string &#123;</span><br><span class="line">    <span class="keyword">return</span> `我是$&#123;name&#125;,我的年龄是$&#123;age&#125;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我门可以看到，其中参数age为可选参数，可以不传。</p>
</li>
<li><p>ts中的默认参数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span> <span class="params">(name:<span class="type">string</span>, age?:<span class="type">number</span> = <span class="number">30</span>)</span></span>: string &#123;</span><br><span class="line">    <span class="keyword">return</span> `我叫$&#123;name&#125;,我今年$&#123;age&#125;岁`</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="title">fun</span><span class="params">(<span class="string">&#x27;章三&#x27;</span>)</span></span>)</span><br><span class="line"><span class="comment">//  我叫章三,我今年30岁</span></span><br><span class="line">console.log(<span class="function"><span class="title">fun</span><span class="params">(<span class="string">&#x27;李四&#x27;</span>, <span class="number">90</span>)</span></span>)</span><br><span class="line"><span class="comment">//  我叫李四,问今年90岁</span></span><br></pre></td></tr></table></figure></li>
<li><p>ts中剩余参数，剩余参数可以用拓展符<code>...</code>来表示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span> <span class="params">(a:<span class="type">number</span>, b:<span class="type">number</span>, c:<span class="type">number</span>, d:<span class="type">number</span>, e:<span class="type">number</span>)</span></span>:number &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d + e</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="function"><span class="title">fun</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span></span>) <span class="comment">//  15</span></span><br></pre></td></tr></table></figure>
<p>这样的参数会很繁琐。那么我们来用…缩减一下参数。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> <span class="params">(<span class="rest_arg">...res</span>:number[])</span>:number </span>&#123;</span><br><span class="line">    let sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>;i &lt; res.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        sum += res[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">console.log(fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)) <span class="comment">//  15</span></span><br></pre></td></tr></table></figure>
<h6 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h6><p>为同一个函数提供多个函数类型定义来进行函数重载。多个函数函数名相同，函数的参数类型,顺序,个数不同。注意函数重载与返回值类型无关。ts的函数重载比较鸡肋，最终函数逻辑的实现还是在一个函数体内去判断它的参数类型，然后做相应的操作。ts重载的作用，感觉只是多了一个参数校验的功能。也就是说在进行函数调用的时候，会对参数进行检查，只有传入的参数类型，顺序，个数与定义的重载函数的参数相同，才能调用成功，否则报错。返回值类型不会进行校验（函数重载与返回值类型无关）。</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span> (<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span> (<span class="params">age:<span class="built_in">number</span></span>):<span class="title">number</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span> (<span class="params">str:<span class="built_in">string</span></span>):<span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> str === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`我叫<span class="subst">$&#123;str&#125;</span>`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`我的年龄是<span class="subst">$&#123;str&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getUser(<span class="string">&#x27;张三&#x27;</span>))    <span class="comment">//  我叫张三</span></span><br><span class="line"><span class="built_in">console</span>.log(getUser(<span class="number">30</span>))    <span class="comment">//  我的年龄是30</span></span><br><span class="line"><span class="built_in">console</span>.log(getUser(<span class="literal">true</span>))  <span class="comment">//  报错</span></span><br></pre></td></tr></table></figure>
<h6 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h6><p>箭头函数和js中一样，但是需要注意的this的指向问题。</p>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构--手动用数组实现栈及其相关方法</title>
    <url>/algorithm/structures/1/</url>
    <content><![CDATA[<p>栈的定义：栈是一种特殊的列表,栈内的元素只能通过栈的一端去访问，就是栈顶，所以栈就有了<code>先进后出</code>的特点。也就是说除了栈顶可以访问栈内元素，其他都不可以。一般操作栈的方法有以下三个：</p>
<ul>
<li>push(): 将元素押入到栈内；</li>
<li>pop(): 从栈顶删除一个元素，<code>永久性从栈顶删除</code>；</li>
<li>peek(): 返回栈顶元素，不删除栈顶元素；</li>
<li>clear(): 清除栈；</li>
<li>top：保存栈顶元素。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function Stack () &#123;</span><br><span class="line">    <span class="comment">//  存储数据的数组</span></span><br><span class="line">    <span class="keyword">this</span>.dataStore = []</span><br><span class="line">    <span class="comment">//  栈顶元素</span></span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0</span></span><br><span class="line">    <span class="comment">//  押入栈的方法</span></span><br><span class="line">    <span class="keyword">this</span>.push = push</span><br><span class="line">    <span class="comment">//  删除栈顶元素的方法</span></span><br><span class="line">    <span class="keyword">this</span>.pop = pop</span><br><span class="line">    <span class="comment">//  返回栈顶元素的方法</span></span><br><span class="line">    <span class="keyword">this</span>.peek = peek</span><br><span class="line">    <span class="comment">//  清楚栈的方法</span></span><br><span class="line">    <span class="keyword">this</span>.clear = clear</span><br><span class="line">    <span class="comment">//  保存栈的长度</span></span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">&#125;</span><br><span class="line">function push (item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top++] = item</span><br><span class="line">&#125;</span><br><span class="line">function pop (item) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top--] = item</span><br><span class="line">&#125;</span><br><span class="line">function peek (item) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">function clear () &#123;</span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">function length () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.top</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  测试</span></span><br><span class="line">let stack = new Stack()</span><br></pre></td></tr></table></figure>
注：栈的运用还是有多种，最为典型的如，判断字符串回文，递归计算某个数的阶乘，将一个数制转换成另一种数制。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构--手动实现队列及其相关方法</title>
    <url>/algorithm/structures/3/</url>
    <content><![CDATA[<p>队列的定义：队列其实应该是属于列表的一种，又像是俩个栈拼接形成一样来存储有序数据。队列是一种先进先出的数据结构，就像是公交车一样，前门上车后门下车.所以对于队列的操作最主要的就是俩种：对列尾部插入，队列头部删除。既入队和出对。</p>
<p>队列实现的属性有：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function Queue () &#123;</span><br><span class="line">    <span class="comment">//  存储数据</span></span><br><span class="line">    <span class="keyword">this</span>.dataStore = []</span><br><span class="line">    <span class="comment">//  向队尾push数据</span></span><br><span class="line">    <span class="keyword">this</span>.enqueue = enqueue</span><br><span class="line">    <span class="comment">//  从队头删除数据</span></span><br><span class="line">    <span class="keyword">this</span>.dequeue = dequeue</span><br><span class="line">    <span class="comment">//  获取对首元素</span></span><br><span class="line">    <span class="keyword">this</span>.front = front</span><br><span class="line">    <span class="comment">//  获取队尾元素</span></span><br><span class="line">    <span class="keyword">this</span>.back = back</span><br><span class="line">    <span class="comment">//  判断对列是不是空</span></span><br><span class="line">    <span class="keyword">this</span>.empty = empty</span><br><span class="line">    <span class="comment">//  显示队列中的所有元素</span></span><br><span class="line">    <span class="keyword">this</span>.toString = toString</span><br><span class="line">&#125;</span><br><span class="line">function enqueue (item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.push(item)</span><br><span class="line">&#125;</span><br><span class="line">function dequeue () &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.shift()</span><br><span class="line">&#125;</span><br><span class="line">function empty () &#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="keyword">this</span>.dataStore.length</span><br><span class="line">&#125;</span><br><span class="line">function front () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">function back () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.dataStore.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">function toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.reduce((total, curr) =&gt; &#123;</span><br><span class="line">        total += curr</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  测试</span></span><br><span class="line"><span class="keyword">var</span> queue = new Queue()</span><br></pre></td></tr></table></figure>
<p>注：队列是一种比较重要的数据结构，诸如，排队，排序问题，利用队列将是非常好的解决方式。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构--手动实现列表及其相关方法</title>
    <url>/algorithm/structures/2/</url>
    <content><![CDATA[<p>列表的定义：列表是一组有序的数据。其中的元素可以是任意类型。列表一般有的属性为：</p>
<ul>
<li>listSize: 保存列表中元素的个数；</li>
<li>pos: 列表中当前元素的位置；</li>
<li>length(): 列表中元素的个数；</li>
<li>clear(): 清空列表；</li>
<li>toString(): 返回列表中的元素；</li>
<li>getElement(): 返回当前位置的元素；</li>
<li>insert(): 在现有元素的前后插入某个元素；</li>
<li>append(): 在列表的末尾添加元素；</li>
<li>find(): 查找列表中的指定元素；</li>
<li>remove(): 删除列表中的指定元素；</li>
<li>front(): 将当前元素移动到列表的第一个元素；</li>
<li>end(): 将当前元素移动到列表的最后一个元素；</li>
<li>pre(): 将当前元素前移一位；</li>
<li>next(): 将当前元素后移一位；</li>
<li>hasNext(): 判断后一位元素；</li>
<li>hasPre(): 判断前一位元素；</li>
<li>currPos(): 返回列表的当前位置；</li>
<li>moveTo(): 将当前元素移动到指定位置；</li>
<li>contains(): 判断给定的元素是不是包含在列表中。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function List () &#123;</span><br><span class="line">    <span class="comment">//  保存在列表中的数据</span></span><br><span class="line">    <span class="keyword">this</span>.dataStore = []</span><br><span class="line">    <span class="comment">//  列表的当前位置</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span></span><br><span class="line">    <span class="comment">//  列表的元素个数</span></span><br><span class="line">    <span class="keyword">this</span>.listSize = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.append = append</span><br><span class="line">    <span class="keyword">this</span>.</span><br><span class="line">&#125;</span><br><span class="line">function append (item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.listSize++] = item</span><br><span class="line">&#125;</span><br><span class="line">function find (item) &#123;</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i] === item) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">function remove (item) &#123;</span><br><span class="line">    <span class="comment">//  先查找到要删除元素的位置</span></span><br><span class="line">    let index = find(item)</span><br><span class="line">    <span class="comment">//  判断是否找到了该元素</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//  splice方法删除找到的元素</span></span><br><span class="line">        <span class="keyword">this</span>.dataStore.splice(index, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">//  整个列表的长度减1</span></span><br><span class="line">        --<span class="keyword">this</span>.listSize</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">function toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  item 要插入的元素</span></span><br><span class="line"><span class="comment">//  after在那个元素后插入</span></span><br><span class="line">function insert (item, after) &#123;</span><br><span class="line">    let index = find(after)</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore.splice(index + <span class="number">1</span>, <span class="number">0</span>, item)</span><br><span class="line">        ++<span class="keyword">this</span>.listSize</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">function clear () &#123;</span><br><span class="line">    delete <span class="keyword">this</span>.dataStore</span><br><span class="line">    <span class="keyword">this</span>.listSize = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">function contains (item) &#123;</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i] === item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">function length () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listSize</span><br><span class="line">&#125;</span><br><span class="line">function front () &#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">function end () &#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.listSize - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">function currPos () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pos</span><br><span class="line">&#125;</span><br><span class="line">function moveTo (pos) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = pos</span><br><span class="line">&#125;</span><br><span class="line">function getElement () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listStore[<span class="keyword">this</span>.pos]</span><br><span class="line">&#125;</span><br><span class="line">function pre () &#123;</span><br><span class="line">    --<span class="keyword">this</span>.pos</span><br><span class="line">&#125;</span><br><span class="line">function next () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pos &lt; <span class="keyword">this</span>.listSize) &#123;</span><br><span class="line">        ++<span class="keyword">this</span>.pos</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function hasNext () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pos &lt; <span class="keyword">this</span>.listSize</span><br><span class="line">&#125;</span><br><span class="line">function hasPre () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pos &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  测试</span></span><br><span class="line">let list = new List()</span><br></pre></td></tr></table></figure>
注：列表的运用看起来和数组区别不是很大，但是这里重要的是运用到像列表中插入元素的方法。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构--手动实现字典及其相关方法</title>
    <url>/algorithm/structures/5/</url>
    <content><![CDATA[<p>字典的定义：字典是一种以键–值来存储数据的数据结构。但是他的基础是Array,而不是Object.但是字典也是无序的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  像字典中添加健--值</span></span><br><span class="line">    <span class="built_in">this</span>.add = add</span><br><span class="line">    <span class="comment">//  保存数据</span></span><br><span class="line">    <span class="built_in">this</span>.dataStore = <span class="keyword">new</span> <span class="built_in">Array</span></span><br><span class="line">    <span class="comment">//  查找键值</span></span><br><span class="line">    <span class="built_in">this</span>.find = find</span><br><span class="line">    <span class="comment">//  删除某一项</span></span><br><span class="line">    <span class="built_in">this</span>.remove = remove</span><br><span class="line">    <span class="comment">//  统计字典中的属性个数</span></span><br><span class="line">    <span class="built_in">this</span>.count = <span class="built_in">this</span>.count</span><br><span class="line">    <span class="comment">//  清空字典</span></span><br><span class="line">    <span class="built_in">this</span>.clear = clear</span><br><span class="line">    <span class="comment">//  显示字典中所有的项</span></span><br><span class="line">    <span class="built_in">this</span>.showAll = showAll</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.dataStore[key] = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.dataStore[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.dataStore[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.dataStore)) &#123;</span><br><span class="line">        ++n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.dataStore).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.dataStore[key]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAll</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.dataStore).sort()) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.dataStore[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：字典的实现还是相对比较简单的。但是字典和对象一样，是无序的，需要自己排序。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构--手动实现链表及其相关方法</title>
    <url>/algorithm/structures/4/</url>
    <content><![CDATA[<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>链表的定义：链表是由一组节点组合而成的集合，每个节点都使用一个对象的引用指向他的后继。指向另一个节点的引用叫做链。链表靠他们相互之间的关系进行引用。所以对于链表的操作也很简单，既，查找，删除，插入等。只是改变元素的指向关系即可。<br>实现链表：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span> </span>(item) &#123;</span><br><span class="line">    <span class="comment">//  element保存节点上的数据</span></span><br><span class="line">    <span class="built_in">this</span>.element = item</span><br><span class="line">    <span class="comment">//  next表示指向下一个节点的链</span></span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Llist</span> </span>() &#123;</span><br><span class="line">    <span class="comment">//  链表的头</span></span><br><span class="line">    <span class="built_in">this</span>.header = <span class="keyword">new</span> <span class="type">Node</span>(<span class="string">&#x27;head&#x27;</span>)</span><br><span class="line">    <span class="comment">//  查找链表元素</span></span><br><span class="line">    <span class="built_in">this</span>.find = find</span><br><span class="line">    <span class="comment">//  向链表中插入元素</span></span><br><span class="line">    <span class="built_in">this</span>.insert = insert</span><br><span class="line">    <span class="comment">//  删除链表的某一个元素</span></span><br><span class="line">    <span class="built_in">this</span>.remove = remove</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span> </span>(item) &#123;</span><br><span class="line">    <span class="comment">//  拿到列表的头节点</span></span><br><span class="line">    let currNode = <span class="built_in">this</span>.header</span><br><span class="line">    <span class="keyword">while</span>(currNode !== item) &#123;</span><br><span class="line">        <span class="comment">//  如果当前节点不是要找的节点</span></span><br><span class="line">        <span class="comment">//  就指向下一个节点</span></span><br><span class="line">        currNode = currNode.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> </span>(<span class="keyword">new</span><span class="type">Item</span>, oldItem) &#123;</span><br><span class="line">    <span class="comment">//  先找到要在插入元素的前一个元素</span></span><br><span class="line">    let currNode = <span class="built_in">this</span>.find(oldItem)</span><br><span class="line">    const <span class="keyword">new</span><span class="type">Node</span> = Node(<span class="keyword">new</span><span class="type">Item</span>)</span><br><span class="line">    <span class="comment">//  前一个元素指向新节点</span></span><br><span class="line">    currNode.next = <span class="keyword">new</span><span class="type">Node</span></span><br><span class="line">    <span class="comment">//  新元素指向之前元素的下一个</span></span><br><span class="line">    <span class="keyword">new</span><span class="type">Node</span>.next = currNode.next</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span> </span>(item) &#123;</span><br><span class="line">    <span class="comment">//  首先要找到前一个元素</span></span><br><span class="line">    <span class="keyword">var</span> currNode = <span class="built_in">this</span>.header</span><br><span class="line">    <span class="keyword">while</span> (!(currNode ===  <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">        currNode.next.element !== item) &#123;</span><br><span class="line">            currNode = currNode.next</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(currNode.next === <span class="literal">null</span>)) &#123;</span><br><span class="line">        currNode.next = currNode.next.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向了链表较单项链表而言，双向链表比单向链表要多一个属性，就是前驱。这样在删除元素的时候，就不需要再查找前一个元素了。也就是说，每个元素总有一个属性，指向了他的前一个元素。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Node (<span class="type">item</span>) &#123;</span><br><span class="line">    this.<span class="type">element</span> = <span class="type">item</span></span><br><span class="line">    this.<span class="keyword">next</span> = null</span><br><span class="line">    this.<span class="keyword">previous</span> = null</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> Llist () &#123;</span><br><span class="line">    this.header = new Node(<span class="string">&#x27;head&#x27;</span>)</span><br><span class="line">    this.find = find</span><br><span class="line">    this<span class="built_in">.remove</span> =<span class="built_in"> remove</span></span><br><span class="line">    this.<span class="keyword">insert</span> = <span class="keyword">insert</span></span><br><span class="line">    //  查找最后一个元素</span><br><span class="line">    this.findLast = findList</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> find (<span class="type">item</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currNode = this.header</span><br><span class="line">    while (!(currNode.<span class="type">element</span> === <span class="type">item</span>)) &#123;</span><br><span class="line">        currNode = currNode.<span class="keyword">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">insert</span> (newElement, <span class="type">item</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curr = this.find(<span class="type">item</span>)</span><br><span class="line">    <span class="keyword">let</span> newNode = new Node(newElement)</span><br><span class="line">    curr.<span class="keyword">next</span> = newNode</span><br><span class="line">    newNode.<span class="keyword">next</span> = curr.<span class="keyword">next</span></span><br><span class="line">    newNode.<span class="keyword">previous</span> = curr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span><span class="built_in"> remove</span> (<span class="type">item</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curr = this.find(<span class="type">item</span>)</span><br><span class="line">    <span class="keyword">if</span> (!(curr.<span class="keyword">next</span> === <span class="type">item</span>)) &#123;</span><br><span class="line">        curr.<span class="keyword">previous</span>.<span class="keyword">next</span> = curr.<span class="keyword">next</span></span><br><span class="line">        curr.<span class="keyword">next</span>.<span class="keyword">previous</span> = curr.<span class="keyword">previous</span></span><br><span class="line">        curr.<span class="keyword">next</span> = null</span><br><span class="line">        curr.<span class="keyword">previous</span> = null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> findLast (<span class="type">item</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curr = this.header</span><br><span class="line">    while (!(curr.<span class="keyword">next</span> === <span class="type">item</span>)) &#123;</span><br><span class="line">        curr = curr.<span class="keyword">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表和单向链表很相似，唯一的区别就是循环链表的头节点的next属性指向自己。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Llist</span> <span class="params">(item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.header = <span class="keyword">new</span> Node(item)</span><br><span class="line">    <span class="keyword">this</span>.header.next = <span class="keyword">this</span>.header</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That’s all!</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构--手动实现集合及其相关方法</title>
    <url>/algorithm/structures/6/</url>
    <content><![CDATA[<p>集合(set)是一种包含不同元素的数据结构。每个元素只能存在一次，不能有重复元素出现。<br>• 不包含任何成员的集合称为空集，全集则是包含一切可能成员的集合。<br>• 如果两个集合的成员完全相同，则称两个集合相等。<br>• 如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集。</p>
<p>对集合的几种常见的操作：</p>
<p>• 并集 将两个集合中的成员进行合并，得到一个新集合。<br>• 交集 两个集合中共同存在的成员组成一个新的集合。<br>• 补集 属于一个集合而不属于另一个集合的成员组成的集合。</p>
<h4 id="Set类的实现"><a href="#Set类的实现" class="headerlink" title="Set类的实现"></a>Set类的实现</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function Set () &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = []</span><br><span class="line">    <span class="comment">//  添加</span></span><br><span class="line">    <span class="keyword">this</span>.add = add</span><br><span class="line">    <span class="comment">//  删除</span></span><br><span class="line">    <span class="keyword">this</span>.remove = remove</span><br><span class="line">    <span class="comment">//  长度</span></span><br><span class="line">    <span class="keyword">this</span>.size = size</span><br><span class="line">    <span class="comment">//  展示</span></span><br><span class="line">    <span class="keyword">this</span>.show = show</span><br><span class="line">    <span class="comment">//  并集</span></span><br><span class="line">    <span class="keyword">this</span>.union = union</span><br><span class="line">    <span class="comment">//  交集</span></span><br><span class="line">    <span class="keyword">this</span>.intersect = intersect</span><br><span class="line">    <span class="comment">//  子集</span></span><br><span class="line">    <span class="keyword">this</span>.subset = subset</span><br><span class="line">    <span class="comment">// 属于第一个集合但是不属于第二个集合</span></span><br><span class="line">    <span class="keyword">this</span>.difference = difference</span><br><span class="line">&#125;</span><br><span class="line">function add (<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore.indexOf(<span class="keyword">data</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore.push(<span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">function remove (<span class="keyword">data</span>) &#123;</span><br><span class="line">    let pos = <span class="keyword">this</span>.dataStore.indexOf(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore.splice(pos, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">function size () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length</span><br><span class="line">&#125;</span><br><span class="line">function show () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore</span><br><span class="line">&#125;</span><br><span class="line">function union (<span class="keyword">set</span>) &#123;</span><br><span class="line">    let temp = new Set()</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>;i &lt; <span class="keyword">this</span>.dataStore.length;i++) &#123;</span><br><span class="line">        temp.add(<span class="keyword">this</span>.dataStore[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>;i &lt; <span class="keyword">set</span>.dataStore.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!temp.contains(<span class="keyword">set</span>.dataStore[i])) &#123;</span><br><span class="line">            temp.dataStore.push(<span class="keyword">set</span>.dataStore[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line">function intersect (<span class="keyword">set</span>) &#123;</span><br><span class="line">    let temp = new Set()</span><br><span class="line">    <span class="keyword">for</span>(let i = <span class="number">0</span>;i &lt; <span class="keyword">this</span>.dataStore.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">set</span>.contains(<span class="keyword">this</span>.dataStore[i])) &#123;</span><br><span class="line">            temp.add(<span class="keyword">this</span>.dataStore[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line">function subSet (<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size() &lt; <span class="keyword">set</span>.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(let key of <span class="keyword">this</span>.dataStore) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">set</span>.contains(<span class="keyword">this</span>.dataStore[key])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">function contains (<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.indexOf(<span class="keyword">data</span>) &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：集合的实现相对比较简单。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构--手动实现二叉查找树及其相关方法</title>
    <url>/algorithm/structures/7/</url>
    <content><![CDATA[<h3 id="二叉树和二叉查找树"><a href="#二叉树和二叉查找树" class="headerlink" title="二叉树和二叉查找树"></a>二叉树和二叉查找树</h3><ul>
<li>二叉树是一种特殊的保存数据的数据结构。二叉树每个节点的子节点不允许超过两个。可以写出高效的程序在树中插入、查找和删除数据。</li>
<li>二叉查找树是一种特殊的二叉树。相对较小的值保存在左节点中，较大的值保存在右节点中。</li>
</ul>
<h3 id="实现二叉查找树"><a href="#实现二叉查找树" class="headerlink" title="实现二叉查找树"></a>实现二叉查找树</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  先创建一个节点对象</span></span><br><span class="line">function Node (<span class="keyword">data</span>, left, right) &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span></span><br><span class="line">    <span class="keyword">this</span>.left = left</span><br><span class="line">    <span class="keyword">this</span>.right = right</span><br><span class="line">    <span class="keyword">this</span>.show = show</span><br><span class="line">    <span class="comment">//  记数</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">function show () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  创建二叉查找树</span></span><br><span class="line">function BST () &#123;</span><br><span class="line">    <span class="comment">//  初始化根节点为null</span></span><br><span class="line">    <span class="keyword">this</span>.root = nul</span><br><span class="line">    <span class="comment">//  插入节点</span></span><br><span class="line">    <span class="keyword">this</span>.insert = insert</span><br><span class="line">    <span class="comment">//  遍历二叉树</span></span><br><span class="line">    <span class="keyword">this</span>.inOrder = inOrder</span><br><span class="line">    <span class="comment">//  查找指定元素</span></span><br><span class="line">    <span class="keyword">this</span>.find = find</span><br><span class="line">    <span class="comment">//  查找最小值</span></span><br><span class="line">    <span class="keyword">this</span>.getMin = getMin</span><br><span class="line">    <span class="comment">//  查找最大值</span></span><br><span class="line">    <span class="keyword">this</span>.getMax = getMax</span><br><span class="line">    <span class="comment">//  删除节点</span></span><br><span class="line">    <span class="keyword">this</span>.remove = remove</span><br><span class="line">    <span class="comment">//  更新记数</span></span><br><span class="line">    <span class="keyword">this</span>.update = update</span><br><span class="line">&#125;</span><br><span class="line">function insert (<span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="comment">//  创建一个节点</span></span><br><span class="line">    <span class="keyword">var</span> n = new Node(<span class="keyword">data</span>, <span class="literal">null</span> , <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">//  如果根节点不存在，就把当前节点当作根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.root) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = n</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  否则将根节点设为当前节点</span></span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span>.root</span><br><span class="line">        <span class="keyword">var</span> parent</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            parent = current</span><br><span class="line">            <span class="comment">//  如果，插入的数据小于当前节点数据</span></span><br><span class="line">            <span class="comment">//  将插入的数据放到左节点，否则放到右节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">data</span> &lt; current.<span class="keyword">data</span>) &#123;</span><br><span class="line">                current = current.left</span><br><span class="line">                <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">                    parent.left = n</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.right</span><br><span class="line">                <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">                    parent.right = n</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  遍历二叉查找树的方式有三种：</span></span><br><span class="line"><span class="comment">//  中序：中序遍历按照节点上的键值，以升序访问 BST 上的所有节点。</span></span><br><span class="line"><span class="comment">//  先序：先序遍历先访问根节点，然后以同样方式访问左子树和右子树。</span></span><br><span class="line"><span class="comment">//  后序：后序 遍历先访问叶子节点，从左子树到右子树，再到根节点。</span></span><br><span class="line">function inOrder (node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(node === <span class="literal">null</span>)) &#123;</span><br><span class="line">        inOrder(node.left)</span><br><span class="line">        inOrder(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉查找树上查找</span></span><br><span class="line"><span class="comment">// (1)给定值：需要比较该值和当前节点上的值的大小。通过比较，就能确定如果给定值不在当前节点时，该向左遍历还是向右遍历。</span></span><br><span class="line"><span class="comment">// (2)最小值：最小值总在左子节点上，只需要遍历左子节点即可</span></span><br><span class="line"><span class="comment">// (3)最大值：最小值总在右边子节点上，只需要遍历右子节点即可</span></span><br><span class="line">function find (<span class="keyword">data</span>) &#123;</span><br><span class="line">    let current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span>(current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.<span class="keyword">data</span> === <span class="keyword">data</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> current</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.<span class="keyword">data</span> &gt; <span class="keyword">data</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> current.left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> current.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">function getMin () &#123;</span><br><span class="line">    let current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (!(current.left === <span class="literal">null</span>)) &#123;</span><br><span class="line">        current = current.left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line">function getMax () &#123;</span><br><span class="line">    let current = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">while</span> (!(current.right === <span class="literal">null</span>)) &#123;</span><br><span class="line">        current = current.right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  删除节点，要先找到要删除的节点</span></span><br><span class="line">function remove (<span class="keyword">data</span>) &#123;</span><br><span class="line">    root = removeNode(<span class="keyword">this</span>.root, <span class="keyword">data</span>)</span><br><span class="line">&#125;</span><br><span class="line">function removeNode (node, <span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="keyword">data</span> === <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有子节点的节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有左子节点的节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有右子节点的节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  如果有俩个子节点，要么查找待删除节点左子树上的最大值，要么查找其右子树上的最小值</span></span><br><span class="line">        <span class="keyword">var</span> tempNode = getSmallest(node.right)</span><br><span class="line">        node.<span class="keyword">data</span> = tempNode.<span class="keyword">data</span></span><br><span class="line">        node.right = removeNode(node.right, tempNode.<span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="keyword">data</span> &lt; <span class="keyword">data</span>) &#123;</span><br><span class="line">        node.left = removeNode(node.left, <span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = removeNode(node.right, <span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function getSmallest (node) &#123;</span><br><span class="line">    let current = node</span><br><span class="line">    <span class="keyword">while</span> (!(current.left === <span class="literal">null</span>)) &#123;</span><br><span class="line">        current = current.left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br><span class="line">function update () &#123;</span><br><span class="line">    <span class="keyword">var</span> grade = <span class="keyword">this</span>.find(<span class="keyword">data</span>)</span><br><span class="line">    grade.count++</span><br><span class="line">    <span class="keyword">return</span> grade</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树和二叉查找树的基本不是很复杂，但是想要用好二叉树，会很不容易。且行且珍惜。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil API手册--&lt;RecoilRoot /&gt;</title>
    <url>/recoil/api/recoilroot/</url>
    <content><![CDATA[<h4 id="lt-RecoilRoot-…props-gt"><a href="#lt-RecoilRoot-…props-gt" class="headerlink" title="&lt;RecoilRoot …props /&gt;"></a>&lt;RecoilRoot …props /&gt;</h4><p>Provides the context in which atoms have values. Must be an ancestor of any component that uses any Recoil hooks. Multiple roots may co-exist; atoms will have distinct values within each root. If they are nested, the innermost root will completely mask any outer roots.<br>为atoms提供上下文。必须是所有是使用Recoil hooks组建的根组建，多个根组建也许可以共存，atoms需要对不同的根组建进行区别。如果它们是嵌套的，最里面的根将完全掩盖任何外部根。<br>Props:<br>    <code>initializeState?: (MutableSnapshot =&gt; void)</code><br>    An optional function that takes a <a href="https://recoiljs.org/docs/api-reference/core/Snapshot#transforming-snapshots">MutableSnapshot to</a> <a href="https://recoiljs.org/docs/api-reference/core/Snapshot#state-initialization">initialize</a> the <RecoilRoot> atom state. This sets up the state for the initial render and is not intended for subsequent state changes or async initialization. Use hooks such as <a href="https://recoiljs.org/docs/api-reference/core/useSetRecoilState">useSetRecoilState()</a> or <a href="https://recoiljs.org/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a> for async state changes.<br>    通过一个可选函数来初始化根RecoilRoot组建的atom状态。这将设置初始呈现的状态，而不是用于后续状态更改或异步初始化。利用hooks函数如useSetRecoilState()或者useRecoilCallback()实现异步更新状态。</RecoilRoot></p>
<p><code>&lt;RecoilRoot&gt;&#39;s</code> represent independent providers/stores of atom state. Note that caches, such as selector caches, may be shared across roots. Selector evaluations must be idempotent except for caching or logging, so this should not be a problem, but may be observable or may cause redundant queries to be cached across roots.<br><RecoilRoot>组建是atom状态的独立的Provider/store.请注意，缓存（如选择器缓存）可以跨根共享。选择器求值必须是幂等的（除了缓存或日志记录），所以这应该不是问题，但可能是可观察的，或者可能导致在根之间缓存冗余查询。</RecoilRoot></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;RecoilRoot&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AppRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ComponentThatUsesRecoil</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil简介</title>
    <url>/recoil/introduce/introduce/</url>
    <content><![CDATA[<h3 id="Recoil"><a href="#Recoil" class="headerlink" title="Recoil"></a>Recoil</h3><p>A state management library for React。<br>recoil是react的状态管理库，他具备三大特点。</p>
<h3 id="Minimal-and-Reactish-简练并保持与-React-一致"><a href="#Minimal-and-Reactish-简练并保持与-React-一致" class="headerlink" title="Minimal and Reactish 简练并保持与 React 一致"></a>Minimal and Reactish 简练并保持与 React 一致</h3><p>Recoil works and thinks like React. Add some to your app and get fast and flexible shared state.<br>Recoil 的工作方式和原理与 React 完全一致，在React应用中添加Recoil能够快速，灵活的共享状态。</p>
<h3 id="Data-Flow-Graph-数据流"><a href="#Data-Flow-Graph-数据流" class="headerlink" title="Data-Flow Graph  数据流"></a>Data-Flow Graph  数据流</h3><p>Derived data and asynchronous queries are tamed with pure functions and efficient subscriptions.<br>纯函数和高效订阅为派生数据和异步查询提供支持。</p>
<h3 id="Cross-App-Observation-跨应用监听"><a href="#Cross-App-Observation-跨应用监听" class="headerlink" title="Cross-App Observation 跨应用监听"></a>Cross-App Observation 跨应用监听</h3><p>Implement persistence, routing, time-travel debugging, or undo by observing all state changes across your app, without impairing code-splitting.<br>不分割代码，通过对全局应用数据对监听，实现数据，路由，调试的持久化，或者是更改成为可能。</p>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil简介--开始应用</title>
    <url>/recoil/introduce/start/</url>
    <content><![CDATA[<h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><h3 id="Create-React-App-创建应用"><a href="#Create-React-App-创建应用" class="headerlink" title="Create React App 创建应用"></a>Create React App 创建应用</h3><p>Recoil is a state management library for React, so you need to have React installed and running to use Recoil. The easiest and recommended way for bootstrapping a React application is to use <a href="https://github.com/facebook/create-react-app#creating-an-app">Create React App</a>:<br>Recoil是一个为Reactk开发的状态管理库，所以运行Recoil的先安装React,推荐最简单的安装React应用方式就是用如下命令：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">npx</span> <span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href>npx</a> is a package runner tool that comes with npm 5.2+ and higher, see instructions for older npm versions.<br>npx是一个npm5.2或更高版本的运行工具包，<a href>点击查看低版本的npm说明</a>。</p>
</blockquote>
<p>For more ways to install Create React App, see the <a href="https://github.com/facebook/create-react-app#creating-an-app">official documentation</a>.<br>更多安装应用方式请查看<a href="https://github.com/facebook/create-react-app#creating-an-app">官方文档</a>。</p>
<h3 id="Installation-安装"><a href="#Installation-安装" class="headerlink" title="Installation 安装"></a>Installation 安装</h3><p>The Recoil package lives in npm. To install the latest stable version, run the following command:<br>Recoil包已经发布到npm上，安装最新最稳定的版本只要运行以下命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> recoil</span><br></pre></td></tr></table></figure>
<p>Or if you’re using yarn:<br>或者使用yarn:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">yarn <span class="builtin-name">add</span> recoil</span><br></pre></td></tr></table></figure>
<h3 id="RecoilRoot"><a href="#RecoilRoot" class="headerlink" title="RecoilRoot"></a>RecoilRoot</h3><p>Components that use recoil state need <code>RecoilRoot</code> to appear somewhere in the parent tree. A good place to put this is in your root component:<br>组件中使用Recoil状态需要在父级中使用<code>RecoilRoot</code>,组件中最好的方式就是将<code>RecoilRoot</code>放到根组件中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    RecoilRoot,</span><br><span class="line">    atom,</span><br><span class="line">    selector,</span><br><span class="line">    useRecoilState,</span><br><span class="line">    useRecoilValue,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">CharacterCounter</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’ll implement the <code>CharacterCounter</code> component in the following section.<br>接下来我们会开发一个<code>CharacterCounter</code>的组件。</p>
<h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p>An <strong>atom</strong> represents a piece of <strong>state</strong>. Atoms can be read from and written to from any component. Components that read the value of an atom are implicitly <strong>subscribed</strong> to that atom, so any atom updates will result in a re-render of all components subscribed to that atom:<br>一个Atom就代表一个state,Atom可以被任何一个组件读取，更新。组件读取 Atom 数据将会隐式订阅它，任何更新都会导致订阅它的组件进行重新渲染。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> textState = atom(&#123;</span><br><span class="line">    key: <span class="string">&#x27;textState&#x27;</span>, // unique ID (<span class="keyword">with</span> respect <span class="keyword">to</span> other atoms/selectors)</span><br><span class="line">    <span class="literal">default</span>: <span class="string">&#x27;&#x27;</span>, // <span class="literal">default</span> value (aka initial value)</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>Components that need to read from and write to an atom should use useRecoilState() as shown below:<br>在组件中使用 useRecoilState() 读写 Atom 数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CharacterCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TextInput</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">CharacterCount</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInput</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useRecoilState(textState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setText(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;text&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        Echo: &#123;text&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>A <strong>selector</strong> represents a piece of <strong>derived state</strong>. Derived state is a <strong>transformation</strong> of state. You can think of derived state as the output of passing state to a pure function that modifies the given state in some way:<br>selectore代表派生状态。Derived state是状态的一种转化，在某种意义上你可以认为derived state是纯函数输出的某种state.</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> charCountState = selector(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;charCountState&#x27;</span>, <span class="comment">// unique ID (with respect to other atoms/selectors)</span></span><br><span class="line">    <span class="built_in">get</span>: (&#123;<span class="built_in">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">text</span> = <span class="built_in">get</span>(textState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>.length;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>We can use the <code>useRecoilValue()</code> hook to read the value of <code>charCountState</code>:<br>我们可以用<code>useRecoilValue()</code>钩子来读取<code>charCountState</code>的值：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> CharacterCount() &#123;</span><br><span class="line">    const <span class="built_in">count</span> = useRecoilValue(charCountState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;&gt;<span class="keyword">Character</span> <span class="built_in">Count</span>: &#123;<span class="built_in">count</span>&#125;&lt;/&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>略</p>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil基础--基础介绍</title>
    <url>/recoil/tutorial/introduce/</url>
    <content><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>This section assumes you have installed Recoil and React. See the <a href="https://recoiljs.org/docs/introduction/getting-started">Getting Started</a> page for how to get started with Recoil and React from scratch. Components in the following sections are assumed to have a <code>&lt;RecoilRoot /&gt;</code> in the parent tree.<br>这一章节主要是安装Recoil和React,可以查看<a href="https://recoiljs.org/docs/introduction/getting-started">开始</a>页如何安装Recoil和React,在下面的章节中，根组件中都会使用<code>&lt;RecoilRoot /&gt;</code>组件。<br>In this tutorial, we’ll be building a simple todo-list application. Our app will be able to do the following:<br>我们会创建一个简单的todo-list的应用。我们的应用会做到以下几点：</p>
<ul>
<li>Add todo items 添加todo项</li>
<li>Edit todo items 开发todo项</li>
<li>Delete todo items 删除todo项</li>
<li>Filter todo items 过滤todo项</li>
<li>Display useful stats 展示state<br>Along the way, we’ll cover atoms, selectors, atom families, and the hooks exposed by the Recoil API. We’ll also cover optimization<br>这样，我们会很好的覆盖到Atoms,selectors,atom全家桶，以及Recoil API 暴露的hooks。</li>
</ul>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil简介--设计初衷</title>
    <url>/recoil/introduce/motivation/</url>
    <content><![CDATA[<h3 id="Motivation-初衷"><a href="#Motivation-初衷" class="headerlink" title="Motivation 初衷"></a>Motivation 初衷</h3><p>For reasons of compatibility and simplicity, it’s best to use React’s built-in state management capabilities rather than external global state. But React has certain limitations:<br>秉承简单与兼容性至上的原则，最好的状态管理方式当然是直接使用 React 内置能力而不是外部全部状态。然而 React 确实存在着一些问题：</p>
<ul>
<li>Component state can only be shared by pushing it up to the common ancestor, but this might include a huge tree that then needs to re-render.<br>组件状态只能与其祖先组件进行共享，这可能会带来组件树中大量的重绘开销。</li>
<li>Context can only store a single value, not an indefinite set of values each with its own consumers.<br>Context 只能保存一个特定值而不是与其 Consumer 共享一组不确定的值。</li>
<li>Both of these make it difficult to code-split the top of the tree (where the state has to live) from the leaves of the tree (where the state is used).<br>以上两点导致组件树顶部组件（状态生产者）与组件树底部组件（状态消费者）之间的代码拆分变得非常困难。</li>
</ul>
<p>We want to improve this while keeping both the API and the semantics and behavior as Reactish as possible.<br>我们希望在尽可能保持 React 代码风格和语义化的前提下解决以上问题。</p>
<p>Recoil defines a directed graph orthogonal to but also intrinsic and attached to your React tree. State changes flow from the roots of this graph (which we call atoms) through pure functions (which we call selectors) and into components. With this approach:<br>Recoil 在组件树中定义了一个正交且内聚的单向图谱。状态变更通过以下方法从图谱的底部（atoms）通过纯函数（selectors）进入组件：</p>
<ul>
<li>We get a boilerplate-free API where shared state has the same simple get/set interface as React local state (yet can be encapsulated with reducers etc. if needed).<br>我们提供了一些无依赖的方法，这些方法像 React 局部状态一样暴露相同的 get/set 接口（简单理解为 reducers 之类的概念亦可）。</li>
<li>We have the possibility of compatibility with Concurrent Mode and other new React features as they become available.<br>我们能够与一些 React 新功能（比如并发模式）兼容。</li>
<li>The state definition is incremental and distributed, making code-splitting possible.<br>状态定义是可伸缩和分布式的，代码拆分成为可能。</li>
<li>State can be replaced with derived data without modifying the components that use it.<br>不用修改组件即可派生数据状态。</li>
<li>Derived data can move between being synchronous and asynchronous without modifying the components that use it.<br>派生数据状态支持同步和异步。</li>
<li>We can treat navigation as a first-class concept, even encoding state transitions in links.<br>我们把跳转看作一级概念，甚至可以对链接中的状态流转进行编码。</li>
<li>It’s easy to persist the entire application state in a way that is backwards-compatible, so persisted states can survive application changes.<br>所以可以简单地使用向后兼容的方式来持久化整个应用的状态，应用变更时持久化状态也可以因此得以保留。</li>
</ul>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil基础--Atoms共享状态</title>
    <url>/recoil/tutorial/atoms/</url>
    <content><![CDATA[<h1 id="Atoms共享状态"><a href="#Atoms共享状态" class="headerlink" title="Atoms共享状态"></a>Atoms共享状态</h1><p>Atoms contain the source of truth for our application state. In our todo-list, the source of truth will be an array of objects, with each object representing a todo item.<br>Atoms包含了应用的状态资源，在我们的todo-list的例子里，数据来源是一个包含了多个对象的数组，每一个对象就是一个todo item项.<br>We’ll call our list atom <code>todoListState</code> and create it using the <code>atom()</code> function:<br>用 <code>atom()</code>方法创建列表的Atom，并调用<code>todoListState</code>:</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todoListState = atom(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;todoListState&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: [],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>We give our atom a unique <code>key</code> and set the <code>default</code> value to an empty array. To read the contents of this atom, we can use the <code>useRecoilValue()</code> hook in our TodoList component:<br>给atom添加一个唯一的<code>标示</code>，设置一个空数组作为<code>默认值</code>。我们可以在组件中使用用<code>useRecoilValue()</code>钩子函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> todoList = useRecoilValue(todoListState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;/* <span class="tag">&lt;<span class="name">TodoListStats</span> /&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml">                &#123;/* <span class="tag">&lt;<span class="name">TodoListFilters</span> /&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">TodoItemCreator</span> /&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">                &#123;todoList.map((todoItem) =&gt; (</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">TodoItem</span> <span class="attr">key</span>=<span class="string">&#123;todoItem.id&#125;</span> <span class="attr">item</span>=<span class="string">&#123;todoItem&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                ))&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The commented-out components will be implemented in the sections that follow.<br>注释部分的组件将会在接下来的部分讲解。<br>To create new todo items, we need to access a setter function that will update the contents of the <code>todoListState</code>. We can use the <code>useSetRecoilState()</code> hook to get a setter function in our <code>TodoItemCreator</code> component:<br>创建新的todo items项，需要创建一个新的setter函数来更新<code>todoListState</code>的内容。那么在<code>TodoItemCreator</code>组件中，我们可以通过<code>useSetRecoilState()</code>钩子函数来创建这个setter函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoItemCreator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [inputValue, setInputValue] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> setTodoList = useSetRecoilState(todoListState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> addItem = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setTodoList(<span class="function">(<span class="params">oldTodoList</span>) =&gt;</span> [</span><br><span class="line">        ...oldTodoList,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">id</span>: getId(),</span><br><span class="line">            <span class="attr">text</span>: inputValue,</span><br><span class="line">            <span class="attr">isComplete</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        ]);</span><br><span class="line">        setInputValue(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onChange = <span class="function">(<span class="params">&#123;target: &#123;value&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        setInputValue(value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addItem&#125;</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utility for creating unique Id</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice we use the <strong>updater</strong> form of the setter function so that we can create a new todo list based on the old todo list.<br>注意我们使用了setter函数中新的更新器，以至于我们能基于之前的todo list来创建新的todo list.<br>The <code>TodoItem</code> component will display the value of the todo item while allowing you to change its text and delete the item. We use <code>useRecoilState()</code> to read <code>todoListState</code> and to get a setter function that we use to update the item text, mark it as completed, and delete it:<br>当更改<code>TodoItem</code>组件的内容或者删除其中一个item的时候，<code>TodoItem</code>组件就展示todo item项的内容。我们通过使用<code>useRecoilState()</code>来读取<code>todoListState</code>并且通过setter函数得到更新的item内容，这意味着更新的完成，并且已经删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoItem</span>(<span class="params">&#123;item&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [todoList, setTodoList] = useRecoilState(todoListState);</span><br><span class="line">  <span class="keyword">const</span> index = todoList.findIndex(<span class="function">(<span class="params">listItem</span>) =&gt;</span> listItem === item);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> editItemText = <span class="function">(<span class="params">&#123;target: &#123;value&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newList = replaceItemAtIndex(todoList, index, &#123;</span><br><span class="line">            ...item,</span><br><span class="line">            <span class="attr">text</span>: value,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setTodoList(newList);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> toggleItemCompletion = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newList = replaceItemAtIndex(todoList, index, &#123;</span><br><span class="line">            ...item,</span><br><span class="line">            <span class="attr">isComplete</span>: !item.isComplete,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setTodoList(newList);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> deleteItem = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newList = removeItemAtIndex(todoList, index);</span><br><span class="line"></span><br><span class="line">        setTodoList(newList);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;item.text&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;editItemText&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">checked</span>=<span class="string">&#123;item.isComplete&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">onChange</span>=<span class="string">&#123;toggleItemCompletion&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;deleteItem&#125;</span>&gt;</span>X<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceItemAtIndex</span>(<span class="params">arr, index, newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...arr.slice(<span class="number">0</span>, index), newValue, ...arr.slice(index + <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeItemAtIndex</span>(<span class="params">arr, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...arr.slice(<span class="number">0</span>, index), ...arr.slice(index + <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And with that we’ve got a fully functional todo list! In the next section we’ll see how we can use selectors to take our list to the next level.<br>这样我们就得到了完整的todolist 组件。在下一个章节，我们将看看selectors是如何将我们的组件提升到一个新的高度的。</p>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil简介--安装教程</title>
    <url>/recoil/introduce/installation/</url>
    <content><![CDATA[<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>The Recoil package lives in npm. To install the latest stable version, run the following command:<br>Recoil包已经发不到npm,可以通过下列命令安装最新的最稳定的版本：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> recoil</span><br></pre></td></tr></table></figure>
<p>或者是用yarn</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">yarn <span class="builtin-name">add</span> recoil</span><br></pre></td></tr></table></figure>
<h3 id="Bundler"><a href="#Bundler" class="headerlink" title="Bundler"></a>Bundler</h3><p>Recoil installed via NPM pairs nicely with module bundlers such as Webpack or Rollup.<br>就像webpack或者Rollup一样，Recoil可以搭配模块坏bundlers通过npm安装。</p>
<h3 id="ES5-support-ES5支持"><a href="#ES5-support-ES5支持" class="headerlink" title="ES5 support ES5支持"></a>ES5 support ES5支持</h3><p>Recoil builds are not transpiled to ES5, and we do not support the use of Recoil with ES5. If you need to support browsers that do not provide ES6 features natively, you can do so by compiling your code with Babel and using preset @babel/preset-env. However, we do not support this and you may run into problems.<br>Recoil的构建不能转化支持ES5，所以我们并不建议使用ES5。如果你需要兼容不支持ES6的本地浏览器。你也可以通过安装@babel/preset-env插件的方式通过babel转译来实现，但是我们并不支持这么做，这可能会出现问题。</p>
<p>In particular, just like React, Recoil depends on the Map and Set types and other features of ES6. Emulation of these features using polyfills may result in far worse performance.<br>就像React一样，Recoil依赖于Map或者Set类型的ES6语法，但是如果通过使用polyfills来达到这一目的也许会得到事倍功半的效果。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>Since version 0.0.11, Recoil offers a UMD build that can be directly used in a <code>&lt;script&gt;</code> tag and exposes the symbol Recoil to the global namespace. We recommend linking to a specific version number and build to avoid unexpected breakage from newer versions:<br>从0.0.11版本开始，Recoil提供了UMD的构建方式，可以直接使用<code>&lt;script&gt;</code>标签,将Recoil暴露到全局。我们推荐引入一个具体版本，以免被收到新版本的影响。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/recoil@0.0.11/umd/recoil.production.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>You can browse all Recoil files on the CDN at <a href="https://www.jsdelivr.com/package/npm/recoi">jsdelivr</a>.<br>可以 通过CDN下载所有有关<a href="https://www.jsdelivr.com/package/npm/recoil">Recoil的资料</a>。</p>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>If you are using <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> in your project. For example, with an eslint config like this:<br>如果你在你的项目里使用了<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a>插件，例如，eslint的配置是这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// previous .eslint config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;react-hooks&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;react-hooks/exhaustive-deps&quot;</span>: <span class="string">&quot;warn&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is recommended to add <a href="https://recoiljs.org/docs/api-reference/core/useRecoilCallback">‘useRecoilCallback’</a> to the list of additionalHooks. With this change, ESLint will warn when the dependencies passed to useRecoilCallback() are specified incorrectly and suggests a fix. The format of additionalHooks is a regex string.<br>推荐在运用hooks的列表中添加<a href="https://recoiljs.org/docs/api-reference/core/useRecoilCallback"><code>useRecoilCallback</code></a>，有了这个操作，eslint就会在有参数传入<code>useRecoilCallback()</code>函数后执行检查是否正确，并提示修复。hooks的格式是一个正则表达式。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modified .eslint config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;react-hooks&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;react-hooks/exhaustive-deps&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;warn&quot;</span>, &#123;</span><br><span class="line">                <span class="attr">&quot;additionalHooks&quot;</span>: <span class="string">&quot;useRecoilCallback&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Nightly-Builds-Nightly构建"><a href="#Nightly-Builds-Nightly构建" class="headerlink" title="Nightly Builds Nightly构建"></a>Nightly Builds Nightly构建</h3><p>We build a package once every day based on the current master branch and publish it as the nightly branch on GitHub. You can use this branch via npm:<br>我们每天会依赖最新的master分支构建一次，并且以nightly分支发布到Github上，可以通过这个分支使用npm安装：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">npm install https:<span class="regexp">//gi</span>thub.com<span class="regexp">/facebookexperimental/</span>Recoil.git<span class="comment">#nightly</span></span><br></pre></td></tr></table></figure>
<p>yarn：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">yarn add https:<span class="regexp">//gi</span>thub.com<span class="regexp">/facebookexperimental/</span>Recoil.git<span class="comment">#nightly</span></span><br></pre></td></tr></table></figure>
<p>or add a dependency in package.json and run npm install or yarn:</p>
<p>或者是在package.json中添加依赖，并且通过命令<code>npm install</code> 或者<code>yarn</code>安装：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;recoil&quot;</span>: <span class="string">&quot;facebookexperimental/Recoil.git<span class="subst">#nightly</span>&quot;</span>,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil简介--核心概念</title>
    <url>/recoil/introduce/concepts/</url>
    <content><![CDATA[<h3 id="OverViews-概览"><a href="#OverViews-概览" class="headerlink" title="OverViews 概览"></a>OverViews 概览</h3><p>Recoil lets you create a data-flow graph that flows from atoms (shared state) through selectors (pure functions) and down into your React components. Atoms are units of state that components can subscribe to. Selectors transform this state either synchronously or asynchronously.<br>Recoil可以通过Selector(纯函数)和Atoms(共享状态)来创建组件之间共享数据的数据流图。Atoms是组件可以订阅到的状态单元。Selector可以是同步也可以是异步。</p>
<h3 id="Atoms-共享状态"><a href="#Atoms-共享状态" class="headerlink" title="Atoms 共享状态"></a>Atoms 共享状态</h3><p>Atoms are units of state. They’re updateable and subscribable: when an atom is updated, each subscribed component is re-rendered with the new value. They can be created at runtime, too. Atoms can be used in place of React local component state. If the same atom is used from multiple components, all those components share their state.Atoms are created using the atom function:<br>Atoms就是状态单元，他们是可更新和可订阅的。一但某一个Atom更新，那么订阅他的组件就会得到新值重新渲染。这些Atoms可以在运行时被创建，也可在局部组件中使用。如果同一个Atom被多个组件使用，那么这些组件就会共享这个Atom.Atom可以通过Atom函数来创建：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fontSizeState = atom(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;fontSizeState&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">14</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Atoms need a unique key, which is used for debugging, persistence, and for certain advanced APIs that let you see a map of all atoms. It is an error for two atoms to have the same key, so make sure they’re globally unique. Like React component state, they also have a default value.<br>Atoms需要一个唯一的标示key,用于调试、数据持久化、和确保整个Atom整个系统高阶API正常运行。一旦有俩个Atoms有了相同的key就会报错，所以要确保这个标示全局唯一，就像React组件的状态一样，他们也有自己的默认值。</p>
<p>To read and write an atom from a component, we use a hook called <code>useRecoilState</code>. It’s just like React’s <code>useState</code>, but now the state can be shared between components:<br>在组件中开发Atom，会用到useRecoilState这个hooks函数。他就像React中的useState一样，但是运用Atom的hooks函数可以让状态在组件之间共享：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FontButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [fontSize, setFontSize] = useRecoilState(fontSizeState);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setFontSize((size) =&gt; size + 1)&#125; style=&#123;&#123;fontSize&#125;&#125;&gt;</span></span><br><span class="line"><span class="xml">                Click to Enlarge</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Clicking on the button will increase the font size of the button by one. But now some other component can also use the same font size:<br>点击按钮就会增加按钮中字体的大小，但是这样在其他组件中用到同样字体大小的时候，其他组件的字体大小也会变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Text</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [fontSize, setFontSize] = useRecoilState(fontSizeState);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize&#125;&#125;</span>&gt;</span>This text will increase in size too.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Selectors-纯函数"><a href="#Selectors-纯函数" class="headerlink" title="Selectors 纯函数"></a>Selectors 纯函数</h3><p>A selector is a pure function that accepts atoms or other selectors as input. When these upstream atoms or selectors are updated, the selector function will be re-evaluated. Components can subscribe to selectors just like atoms, and will then be re-rendered when the selectors change.<br>Selector是一个以Atom和其他的Selector为参数的纯函数。当这些上游的Atoms和Selector更新的时候。该Selecotor就会重新计算。组件也可以像Atom一样订阅Selector.当Selector发生变化的时候，组件也会被重新渲染。<br>Selectors are used to calculate derived data that is based on state. This lets us avoid redundant state, usually obviating the need for reducers to keep state in sync and valid. Instead, a minimal set of state is stored in atoms, while everything else is efficiently computed as a function of that minimal state. Since selectors keep track of what components need them and what state they depend on, they make this functional approach more efficient.<br>Selector被用来基于原始State的派生数据的计算。因为不需要使用 reducer 来保证数据的一致性和有效性，所以可以避免冗余数据。而是数据都是通过基于存储在Atom上的原始数据计算得到的。由于 Selector 会追踪使用它们的组件以及它们依赖的数据状态，所以函数式编程会比较高效。<br>From the point of view of components, selectors and atoms have the same interface and can therefore be substituted for one another.<br>因为 Seletor 和 Atom 给组件提供相同的方法，所以它们可以相互替代。<br>Selectors are defined using the selector function:<br>Selector可以通过Selector函数创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fontSizeLabelState = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;fontSizeLabelState&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fontSize = get(fontSizeState);</span><br><span class="line">        <span class="keyword">const</span> unit = <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;fontSize&#125;</span><span class="subst">$&#123;unit&#125;</span>`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>The <code>get</code> property is the function that is to be computed. It can access the value of atoms and other selectors using the <code>get</code> argument passed to it. Whenever it accesses another atom or selector, a dependency relationship is created such that updating the other atom or selector will cause this one to be recomputed.<br><code>get</code>属性是一个用于计算的函数。它可以使用入参 <code>get</code> 字段来访问输入的 Atom 和 Selector。当它访问其他 Atom 和 Selector 时，这层依赖关系会保证更新状态的同步。<br>In this fontSizeLabelState example, the selector has one dependency: the fontSizeState atom. Conceptually, the fontSizeLabelState selector behaves like a pure function that takes a fontSizeState as input and returns a formatted font size label as output.<br>In this <code>fontSizeLabelState</code> example, the selector has one dependency: the <code>fontSizeState</code> atom. Conceptually, the <code>fontSizeLabelState</code> selector behaves like a pure function that takes a <code>fontSizeLabelState</code> as input and returns a formatted font size label as output.<br>参考上述 <code>fontSizeLabelState</code> 示例，它依赖于 <code>fontSizeLabelState</code>使用 <code>fontSizeLabelState</code> 作为入参，并返回格式化之后的字号文本。<br>Selectors can be read using <code>useRecoilValue()</code>, which takes an atom or selector as an argument and returns the corresponding value. We don’t use the <code>useRecoilState()</code> as the <code>fontSizeLabelState</code> selector is not writeable see the <a href="https://recoiljs.org/docs/api-reference/core/selector">selector API reference</a> for more information on writeable selectors):<br>我们可以通过在 <code>useRecoilValue()</code> 方法中输入 Atom 或者 Selector 来获取对应的数据。这里不用 <code>useRecoilState()</code> 是因为 <code>fontSizeLabelState</code> 是一个不可写 Selector，更多细节参考 <a href="https://recoiljs.org/docs/api-reference/core/selector">Selector</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FontButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [fontSize, setFontSize] = useRecoilState(fontSizeState);</span><br><span class="line">    <span class="keyword">const</span> fontSizeLabel = useRecoilValue(fontSizeLabelState);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>Current font size: $&#123;fontSizeLabel&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setFontSize(fontSize + 1)&#125; style=&#123;&#123;fontSize&#125;&#125;&gt;</span></span><br><span class="line"><span class="xml">                Click to Enlarge</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Clicking on the button now does two things: it increases the font size of the button while also updating the font size label to reflect the current font size.<br>点击按钮可以看到按钮和文本的字号同时在更新。</p>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil指南--Dev Tools 开发工具</title>
    <url>/recoil/guides/dev-tools/</url>
    <content><![CDATA[<h4 id="Dev-Tools-开发工具"><a href="#Dev-Tools-开发工具" class="headerlink" title="Dev Tools 开发工具"></a>Dev Tools 开发工具</h4><p>Recoil has functionality to allow you to observe and update state changes.<br>Recoil可以允许您监听并且更新状态变化。</p>
<hr>
<h4 id="IMPORTANT-NOTE-重点关注"><a href="#IMPORTANT-NOTE-重点关注" class="headerlink" title="IMPORTANT NOTE 重点关注"></a>IMPORTANT NOTE 重点关注</h4><p>This API is currently under development and will change. Please stay tuned…<br>这个API当前还在开发中，并且会有变化，请稍等…</p>
<hr>
<h4 id="Observing-All-State-Changes-监听所有的状态变化"><a href="#Observing-All-State-Changes-监听所有的状态变化" class="headerlink" title="Observing All State Changes 监听所有的状态变化"></a>Observing All State Changes 监听所有的状态变化</h4><p>You can use a hook such as <a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilSnapshot">useRecoilSnapshot()</a> or <a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilTransactionObserver">useRecoilTransactionObserver_UNSTABLE()</a> to subscribe to state changes and obtain a <a href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a> of the new state.<br>可以使用诸如<a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilSnapshot">useRecoilSnapshot()</a>或者<a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilTransactionObserver">useRecoilTransactionObserver_UNSTABLE()</a>的钩子函数来订阅状态的变化，或者是添加一个<a href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a>的新状态。</p>
<p>Once you have a <code>Snapshot</code>, you can use methods such as <code>getLoadable()</code>, <code>getPromise()</code>, and <code>getInfo()</code> to inspect the state and use <code>getNodes()</code> to iterate over the set of known atoms.<br>一旦使用Snapshot,你就可以用类似于<code>getLoadable()</code>, <code>getPromise()</code>, 和 <code>getInfo()</code>方法去检查state,用<code>getNodes()</code>方法来迭代atoms.</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> DebugObserver(): React.Node &#123;</span><br><span class="line">    const<span class="built_in"> snapshot</span> = useRecoilSnapshot();</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        console.debug(<span class="string">&#x27;The following atoms were modified:&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (const <span class="type">node</span> <span class="keyword">of</span><span class="built_in"> snapshot</span>.getNodes(&#123;modified:<span class="built_in"> true</span>&#125;)) &#123;</span><br><span class="line">        console.debug(<span class="type">node</span><span class="built_in">.key</span>,<span class="built_in"> snapshot</span>.getLoadable(<span class="type">node</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="built_in">[snapshot</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">DebugObserver</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            ...</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Observing-State-Changes-On-Demand-按需监听state的变化"><a href="#Observing-State-Changes-On-Demand-按需监听state的变化" class="headerlink" title="Observing State Changes On-Demand 按需监听state的变化"></a>Observing State Changes On-Demand 按需监听state的变化</h4><p>Or, you can use the <a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a> hook to obtain a <a href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a> on-demand.<br>可以使用使用<a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a>hook函数来获取按需<a href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DebugButton</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> onClick = useRecoilCallback(<span class="function">(<span class="params">&#123;snapshot&#125;</span>) =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.debug(<span class="string">&#x27;Atom values:&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> snapshot.getNodes()) &#123;</span><br><span class="line">            <span class="keyword">const</span> value = <span class="keyword">await</span> snapshot.getPromise(node);</span><br><span class="line">            <span class="built_in">console</span>.debug(node.key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>Dump State<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Time-Travel"><a href="#Time-Travel" class="headerlink" title="Time Travel"></a>Time Travel</h4><p>The <a href="https://www.recoiljs.cn/docs/api-reference/core/useGotoRecoilSnapshot">useGotoRecoilSnapshot()</a> hook can be used to update the entire Recoil state to match the provided <code>Snapshot</code>. This example maintains a history of state changes with the ability to go back and restore previous global state.<br><a href="https://www.recoiljs.cn/docs/api-reference/core/useGotoRecoilSnapshot">useGotoRecoilSnapshot()</a> 钩子函数可以用来更新全部的Recoil状态来匹配所提供的<code>Snapshot</code>,此示例维护了状态更改的历史，并能够返回和恢复以前的全局状态。<br><code>Snapshot&#39;s</code> also provide a <code>getID()</code> method. That can be used, for example, to help determine if you are reverting to a previous known state to avoid updating your snapshot history.<br>Snapshot同样提供了<code>getID()</code>的方法。例如，可以使用它来帮助确定您是否正在恢复到以前的已知状态，以避免更新快照历史记录。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeTravelObserver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [snapshots, setSnapshots] = useState([]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> snapshot = useRecoilSnapshot();</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (snapshots.every(<span class="function"><span class="params">s</span> =&gt;</span> s.getID() !== snapshot.getID())) &#123;</span><br><span class="line">            setSnapshots([...snapshots, snapshot]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [snapshot]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gotoSnapshot = useGotoRecoilSnapshot();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;snapshots.map((snapshot, i) =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                Snapshot &#123;i&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> gotoSnapshot(snapshot)&#125;&gt;</span></span><br><span class="line"><span class="xml">                    Restore</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil基础--Selector纯函数</title>
    <url>/recoil/tutorial/selectors/</url>
    <content><![CDATA[<h1 id="Selectors-纯函数"><a href="#Selectors-纯函数" class="headerlink" title="Selectors 纯函数"></a>Selectors 纯函数</h1><p>A <strong>selector</strong> represents a piece of <strong>derived state</strong>. You can think of derived state as the output of passing state to a pure function that modifies the given state in some way.<br><strong>selecttor</strong>就是一种派生状态。你可以认为<strong>派生状态</strong>是一种高阶函数的返回值。<br>Derived state is a powerful concept because it lets us build dynamic data that depends on other data. In the context of our todo list application, the following are considered derived state:<br>派生状态是一个非常有意义的概念，因为他们能让我们创建依赖于其他数据的动态数据。在我们todo list的例子中，下面的数据被视作为派生状态：</p>
<ul>
<li><strong>Filtered todo list</strong>: derived from the complete todo list by creating a new list that has certain items filtered out based on some criteria (such as filtering out items that are already completed).<br>过滤todo List：</li>
<li><strong>Todo list statistics</strong>: derived from the complete todo list by calculating useful attributes of the list, such as the total number of items in the list, the number of completed items, and the percentage of items that are completed.<br>To implement a filtered todo list, we need to choose a set of filter criteria whose value can be saved in an atom. The filter options we’ll use are: “Show All”, “Show Completed”, and “Show Uncompleted”. The default value will be “Show All”:<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todoListFilterState = atom(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;todoListFilterState&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">&#x27;Show All&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
Using <code>todoListFilterState</code> and <code>todoListState</code>, we can build a <code>filteredTodoListState</code> selector which derives a filtered list:<br>我们可以使用<code>todoListFilterState</code>和<code>todoListState</code>来创建一个<code>filteredTodoListState</code>Slector来获取过滤的列表：<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> filteredTodoListState = selector(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;filteredTodoListState&#x27;</span>,</span><br><span class="line">    <span class="built_in">get</span>: (&#123;<span class="built_in">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">filter</span> = <span class="built_in">get</span>(todoListFilterState);</span><br><span class="line">        <span class="keyword">const</span> list = <span class="built_in">get</span>(todoListState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">filter</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Show Completed&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> list.<span class="built_in">filter</span>((item) =&gt; item.isComplete);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Show Uncompleted&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> list.<span class="built_in">filter</span>((item) =&gt; !item.isComplete);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
The <code>filteredTodoListState</code> internally keeps track of two dependencies: <code>todoListFilterState</code> and <code>todoListState</code> so that it re-runs if either of those change.<br><code>filteredTodoListState</code>与<code>todoListFilterState</code>和<code>todoListState</code>有密切关系，只要有其中一个发生变化，就会导致re-runs.<blockquote>
<p>From a component’s point of view, selectors can be read using the same hooks that are used to read atoms. However it’s important to note that certain hooks only work with writable state (i.e useRecoilState()). All atoms are writable state, but only some selectors are considered writable state (selectors that have both a get and set property). See the Core Concepts page for more information on this topic.</p>
</blockquote>
</li>
</ul>
<p>Displaying our filtered todoList is as simple as changing one line in the <code>TodoList</code> component:<br>展示过滤的todoList列表非常的简单，只需要在<code>TodoList</code>组件中修改一行代码就好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// changed from todoListState to filteredTodoListState</span></span><br><span class="line">    <span class="keyword">const</span> todoList = useRecoilValue(filteredTodoListState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TodoListStats</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TodoListFilters</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">TodoItemCreator</span> /&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        &#123;todoList.map((todoItem) =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">TodoItem</span> <span class="attr">item</span>=<span class="string">&#123;todoItem&#125;</span> <span class="attr">key</span>=<span class="string">&#123;todoItem.id&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note the UI is showing every todo because <code>todoListFilterState</code> was given a default value of “Show All”. In order to change the filter, we need to implement the <code>TodoListFilters</code> component:<br>注意，从UI层面来看，展示了所有的item,因为<code>todoListFilterState</code>被赋予了展示所有的默认值。为了过滤，我们需要一个<code>TodoListFilters</code>组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoListFilters</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [filter, setFilter] = useRecoilState(todoListFilterState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> updateFilter = <span class="function">(<span class="params">&#123;target: &#123;value&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        setFilter(value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">        Filter:</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">&#123;filter&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;updateFilter&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Show All&quot;</span>&gt;</span>All<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Show Completed&quot;</span>&gt;</span>Completed<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Show Uncompleted&quot;</span>&gt;</span>Uncompleted<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With a few lines of code we’ve managed to implement filtering! We’ll use the same concepts to implement the <code>TodoListStats</code> component.<br>写了这么几行代码，我们已经可以让过滤生效了。我们可以用同样的概念使<code>TodoListStats</code>组件生效。<br>We want to display the following stats:<br>我们希望展示以下的统计：</p>
<ul>
<li>Total number of todo items items的总数</li>
<li>Total number of completed items 完成状态的item总数</li>
<li>Total number of uncompleted items 没有完成状态的item的总数</li>
<li>Percentage of items completed 完成状态的item的占比<br>While we could create a selector for each of the stats, an easier approach would be to create one selector that returns an object containing the data we need. We’ll call this selector <code>todoListStatsState</code>:<br>这时我们可以为每一个统计创建一个Selector.一种最简单的方式就是创建一个selectorr然后返回一个包含我们需要的数据的对象。我们将把这个Selector叫做<code>todoListStatsState</code>:<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> todoListStatsState = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;todoListStatsState&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> todoList = <span class="keyword">get</span>(todoListState);</span><br><span class="line">        <span class="keyword">const</span> totalNum = todoList.length;</span><br><span class="line">        <span class="keyword">const</span> totalCompletedNum = todoList.filter((item) =&gt; item.isComplete).length;</span><br><span class="line">        <span class="keyword">const</span> totalUncompletedNum = totalNum - totalCompletedNum;</span><br><span class="line">        <span class="keyword">const</span> percentCompleted = totalNum === <span class="number">0</span> ? <span class="number">0</span> : totalCompletedNum / totalNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            totalNum,</span><br><span class="line">            totalCompletedNum,</span><br><span class="line">            totalUncompletedNum,</span><br><span class="line">            percentCompleted,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
To read the value of <code>todoListStatsState</code>, we use <code>useRecoilValue()</code> once again:<br>再用<code>useRecoilValue()</code>函数来读取<code>todoListStatsState</code>的值：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoListStats</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        totalNum,</span><br><span class="line">        totalCompletedNum,</span><br><span class="line">        totalUncompletedNum,</span><br><span class="line">        percentCompleted,</span><br><span class="line">    &#125; = useRecoilValue(todoListStatsState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> formattedPercentCompleted = <span class="built_in">Math</span>.round(percentCompleted * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Total items: &#123;totalNum&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Items completed: &#123;totalCompletedNum&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Items not completed: &#123;totalUncompletedNum&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>Percent completed: &#123;formattedPercentCompleted&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
To summarize, we’ve created a todo list app that meets all of our requirements:<br>总结，我们已经创建了满足我们以下需求的todo list应用：</li>
<li>Add todo items 增加item</li>
<li>Edit todo items 编辑item</li>
<li>Delete todo items 删除item</li>
<li>Filter todo items 过滤item</li>
<li>Display useful stats 展示统计</li>
</ul>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil指南--Testing 测试</title>
    <url>/recoil/guides/testing/</url>
    <content><![CDATA[<h4 id="Testing-Recoil-Selectors-outside-of-React-React之外测试Recoil的Selectors"><a href="#Testing-Recoil-Selectors-outside-of-React-React之外测试Recoil的Selectors" class="headerlink" title="Testing Recoil Selectors outside of React React之外测试Recoil的Selectors"></a>Testing Recoil Selectors outside of React React之外测试Recoil的Selectors</h4><p>It can be useful to manipulate and evaluate Recoil selectors outside of a React context for testing. This can be done by working with a Recoil <a href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot">Snapshot</a>. You can build a fresh snapshot using <code>snapshot_UNSTABLE()</code> and then use that <code>Snapshot</code> to evaluate selectors for testing.<br>脱离React来测试Recoil的Selectors是非常有用的。这可以通过Recolid的Snapshot来实现。可以通过<code>snapshot_UNSTABLE()</code>函数来创建一个全新的snapshot，然后用<code>Snapshot</code>来实现selector的测试。</p>
<h4 id="Example-Jest-unit-testing-selectors-Selectors的单元测试"><a href="#Example-Jest-unit-testing-selectors-Selectors的单元测试" class="headerlink" title="Example: Jest unit testing selectors Selectors的单元测试"></a>Example: Jest unit testing selectors Selectors的单元测试</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numberState = atom(&#123;key: <span class="string">&#x27;Number&#x27;</span>, <span class="keyword">default</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multipliedState = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MultipliedNumber&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; <span class="keyword">get</span>(numberState) * <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;Test multipliedState&#x27;</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> initialSnapshot = snapshot_UNSTABLE();</span><br><span class="line">    expect(mySnapshot.getLoadable(multipliedState).valueOrThrow()).toBe(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> testSnapshot = snapshot_UNSTABLE((&#123;<span class="keyword">set</span>&#125;) =&gt; <span class="keyword">set</span>(numberState, <span class="number">1</span>));</span><br><span class="line">    expect(mySnapshot.getLoadable(multipliedState).valueOrThrow()).toBe(<span class="number">100</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil指南--Asynchronous Data Queries 异步数据请求</title>
    <url>/recoil/guides/data-query/</url>
    <content><![CDATA[<p>Recoil provides a way to map state and derived state to React components via a data-flow graph. What’s really powerful is that the functions in the graph can also be asynchronous. This makes it easy to use asynchronous functions in synchronous React component render functions. Recoil allows you to seamlessly mix synchronous and asynchronous functions in your data-flow graph of selectors. Simply return a Promise to a value instead of the value itself from a selector <code>get</code> callback, the interface remains exactly the same. Because these are just selectors, other selectors can also depend on them to further transform the data.<br>Recoil通过数据流图为react提供了俩中state.更为强大的是，函数式的数据流可以是异步的。这使得在同步的react组件中使用异步函数渲染变的非常容易。在Recoil的selector数据流中可以允同步和异步方法混合使用，翻译一个Promise来获取值，而不是Selector的<code>get</code>回调中。接口也是同样的类似，因为这些仅仅是Selector,其他的Selector可以依赖于这些Selector做更多的数据转化。<br>Selectors can be used as one way to incorporate asynchronous data into the Recoil data-flow graph. Please keep in mind that selectors represent “idempotent” functions: For a given set of inputs they should always produce the same results (at least for the lifetime of the application). This is important as selector evaluations may be cached, restarted, or executed multiple times. Because of this, selectors are generally a good way to model read-only DB queries. For mutable data you can use a <a href="https://recoiljs.org/docs/guides/asynchronous-data-queries#query-refresh">Query Refresh</a> or to synchronize mutable state, persist state, or for other side-effects consider the experimental <a href="https://recoiljs.org/docs/guides/atom-effects">Atom Effects API</a>.<br>Selector可以被视作为是注册异步数据的一种方式。切记，selector代表了’幂等’函数：对于给定的一组输入，它们应该总是产生相同的结果（至少在应用程序的生命周期内），这一点非常的重要，因为selector的运算可能被缓存，重新计算，或者被执行多次。尽管如此，Selector也是一个读取数据查询非常好的方式。对于那些可变的数据，可以<a href="https://recoiljs.org/docs/guides/asynchronous-data-queries#query-refresh">刷新请求</a>或者同步可变状态，持久状态或者可以考虑其他的副作用的<a href="https://recoiljs.org/docs/guides/atom-effects">Atom Api</a>.</p>
<h3 id="Synchronous-Example-同步案例"><a href="#Synchronous-Example-同步案例" class="headerlink" title="Synchronous Example 同步案例"></a>Synchronous Example 同步案例</h3><p>For example, here is a simple synchronous <a href="https://recoiljs.org/docs/api-reference/core/atom">atom</a> and <a href="https://recoiljs.org/docs/api-reference/core/selector">selector</a> to get a user name:<br>例如，下面是一个简单的异步获取用户名的<a href="https://recoiljs.org/docs/api-reference/core/atom">Atom</a>和<a href="https://recoiljs.org/docs/api-reference/core/selector">Selector</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserNameState = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tableOfUsers[get(currentUserIDState)].name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserNameState);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Asynchronous-Example-异步案例"><a href="#Asynchronous-Example-异步案例" class="headerlink" title="Asynchronous Example 异步案例"></a>Asynchronous Example 异步案例</h3><p>If the user names were stored in some database we need to query, all we need to do is return a <code>Promise</code> or use an <code>async</code> function. If any dependencies change, the selector will be re-evaluated and execute a new query. The results are cached, so the query will only execute once per unique input.<br>如果我们需要的用户名是被存储到某个数据库，我们需要做的就是就是通过<code>async</code>方法返回一个<code>Promise</code>.如果一些依赖项发生变化，Selector也会重新计算，或者是重新发起请求。结果会被缓存，所以请求只会被执行一次。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserNameQuery = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: <span class="keyword">async</span> (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;</span><br><span class="line">            userID: <span class="keyword">get</span>(currentUserIDState),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">CurrentUserInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserNameQuery);</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;userName&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The interface of the selector is the same, so the component using this selector doesn’t need to care if it was backed with synchronous atom state, derived selector state, or asynchronous queries!<br>Selector的接口也是一样的，因此组件中用到Selector并不需要关心是否支持同步的Atom 状态，派生Selector状态，或者是异步请求。<br>But, since React render functions are synchronous, what will it render before the promise resolves? Recoil is designed to work with <a href="https://reactjs.org/docs/concurrent-mode-suspense.html">React Suspense</a> to handle pending data. Wrapping your component with a Suspense boundary will catch any descendants that are still pending and render a fallback UI:<br>但是，由于react的渲染是同步的，那么在promise reslove之前什么会被渲染？Recoil设计使用<a href="https://reactjs.org/docs/concurrent-mode-suspense.html">react Suspense</a>来处理进行中的数据。将组件以及其后代组件暂时都挂起，返回等待中的UI界面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Error-Handling-错误处理"><a href="#Error-Handling-错误处理" class="headerlink" title="Error Handling 错误处理"></a>Error Handling 错误处理</h3><p>But what if the request has an error? Recoil selectors can also throw errors which will then be thrown if a component tries to use that value. This can be caught with a React <a href="https://reactjs.org/docs/error-boundaries.html"><ErrorBoundary></ErrorBoundary></a>. For example:<br>一旦请求出现错误怎么办？Recoil Selector可以扔出一个React组件可以捕获的错误。这个错误可以被React的<a href="https://reactjs.org/docs/error-boundaries.html"><ErrorBoundary></ErrorBoundary></a>组件捕获。案例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserNameQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserName&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">async</span> (&#123;get&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;</span><br><span class="line">            <span class="attr">userID</span>: get(currentUserIDState),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(currentUserNameQuery);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Queries-with-Parameters-带参请求"><a href="#Queries-with-Parameters-带参请求" class="headerlink" title="Queries with Parameters 带参请求"></a>Queries with Parameters 带参请求</h3><p>Sometimes you want to be able to query based on parameters that aren’t just based on derived state. For example, you may want to query based on the component props. You can do that using the <a href="https://recoiljs.org/docs/api-reference/utils/selectorFamily">selectorFamily</a> helper:<br>有时候你可能想要发起一个携带参数带请求的不仅仅依赖于派生状态。例如，你的请求是基于组件的props,那么你可以使用<a href="https://recoiljs.org/docs/api-reference/utils/selectorFamily">selectorFamily</a>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userNameQuery = selectorFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserName&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="params">userID</span> =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response.name;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;userID&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userName = useRecoilValue(userNameQuery(userID));</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;1&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;2&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">UserInfo</span> <span class="attr">userID</span>=<span class="string">&#123;3&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data-Flow-Graph-数据流"><a href="#Data-Flow-Graph-数据流" class="headerlink" title="Data-Flow Graph 数据流"></a>Data-Flow Graph 数据流</h3><p>Remember, by modeling queries as selectors, we can build a data-flow graph mixing state, derived state, and queries! This graph will automatically update and re-render React components as state is updated.<br>切记，我们可以通过模块查询来创建混合状态，派生状态，以及请求的Selector。这样数据状态一旦更新React的组件会自动更新并重新渲染。<br>The following example will render the current user’s name and a list of their friends. If a friend’s name is clicked on, they will become the current user and the name and list will be automatically updated.<br>下面的例子将会渲染当前的用户名，以及朋友列表，如果某一个朋友的名字被点击。他将会变成当前的用户，并且姓名和裂变会自动更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfoQuery = selectorFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="params">userID</span> =&gt;</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserInfoQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> get(userInfoQuery(get(currentUserIDState))),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> friendsInfoQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;FriendsInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;friendList&#125; = get(currentUserInfoQuery);</span><br><span class="line">        <span class="keyword">return</span> friendList.map(<span class="function"><span class="params">friendID</span> =&gt;</span> get(userInfoQuery(friendID)));</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUser = useRecoilValue(currentUserInfoQuery);</span><br><span class="line">    <span class="keyword">const</span> friends = useRecoilValue(friendsInfoQuery);</span><br><span class="line">    <span class="keyword">const</span> setCurrentUserID = useSetRecoilState(currentUserIDState);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;currentUser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;friends.map(friend =&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;friend.id&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCurrentUserID(friend.id)&#125;&gt;</span></span><br><span class="line"><span class="xml">                    &#123;friend.name&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                )&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">CurrentUserInfo</span> /&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RecoilRoot</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Concurrent-Requests-当前请求"><a href="#Concurrent-Requests-当前请求" class="headerlink" title="Concurrent Requests 当前请求"></a>Concurrent Requests 当前请求</h3><p>If you notice in the above example, the <code>friendsInfoQuery</code> uses a query to get the info for each friend. But, by doing this in a loop they are essentially serialized. If the lookup is fast, maybe that’s ok. If it’s expensive, you can use a concurrency helper such as <a href="https://recoiljs.org/docs/api-reference/utils/waitForAll">waitForAll</a> to run them in parallel. This helper accepts both arrays and named objects of dependencies.<br>如果你注意到上面到例子。<code>friendsInfoQuery</code>发起请求来获取每一个朋友的信息。但是通过这样的循环是为了本质上的有序列化。如果查询速度够快，这没什么，要不然就，可以使用例如<a href="https://recoiljs.org/docs/api-reference/utils/waitForAll">waitForAll</a>的并发请求来处理。他既可以接受数组，也可以接受对象作为参数。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> friendsInfoQuery = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;FriendsInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;friendList&#125; = <span class="keyword">get</span>(currentUserInfoQuery);</span><br><span class="line">        <span class="keyword">const</span> friends = <span class="keyword">get</span>(waitForAll(</span><br><span class="line">            friendList.map(friendID =&gt; userInfoQuery(friendID))</span><br><span class="line">        ));</span><br><span class="line">        <span class="keyword">return</span> friends;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>You can use <a href="https://recoiljs.org/docs/api-reference/utils/waitForNone">waitForNone</a> to handle incremental updates to the UI with partial data.<br>同样也可以使用<a href="https://recoiljs.org/docs/api-reference/utils/waitForNone">waitForNone</a>部分数据来处理UI层面的更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> friendsInfoQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;FriendsInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;friendList&#125; = get(currentUserInfoQuery);</span><br><span class="line">        <span class="keyword">const</span> friendLoadables = get(waitForNone(</span><br><span class="line">                friendList.map(<span class="function"><span class="params">friendID</span> =&gt;</span> userInfoQuery(friendID))</span><br><span class="line">            ));</span><br><span class="line">        <span class="keyword">return</span> friendLoadables</span><br><span class="line">        .filter(<span class="function">(<span class="params">&#123;state&#125;</span>) =&gt;</span> state === <span class="string">&#x27;hasValue&#x27;</span>)</span><br><span class="line">        .map(<span class="function">(<span class="params">&#123;contents&#125;</span>) =&gt;</span> contents);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Pre-Fetching-预请求"><a href="#Pre-Fetching-预请求" class="headerlink" title="Pre-Fetching 预请求"></a>Pre-Fetching 预请求</h3><p>For performance reasons you may wish to kick off fetching before rendering. That way the query can be going while we start rendering. The <a href="https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early">React docs</a> give some examples. This pattern works with Recoil as well.<br>由于一些其他的原因，你可能希望能在渲染之前开启请求。这当然也是没有问题的。在开始渲染的时候，是可以发起请求的。React文档给了我们例子，这当然也适用于Recoil.<br>Let’s change the above example to initiate a fetch for the next user info as soon as the user clicks the button to change users:<br>我们来修改一下上面的例子，在用户一点击按钮改变用户的时候为下一个用户初始化一个请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUser = useRecoilValue(currentUserInfoQuery);</span><br><span class="line">    <span class="keyword">const</span> friends = useRecoilValue(friendsInfoQuery);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> changeUser = useRecoilCallback(<span class="function">(<span class="params">&#123;snapshot, set&#125;</span>) =&gt;</span> <span class="function"><span class="params">userID</span> =&gt;</span> &#123;</span><br><span class="line">        snapshot.getLoadable(userInfoQuery(userID)); <span class="comment">// pre-fetch user info</span></span><br><span class="line">        set(currentUserIDState, userID); <span class="comment">// change current user to start new render</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;currentUser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;friends.map(friend =&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;friend.id&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> changeUser(friend.id)&#125;&gt;</span></span><br><span class="line"><span class="xml">                    &#123;friend.name&#125;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">                )&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Async-Queries-Without-React-Suspense-没有React-Suspense的异步请求"><a href="#Async-Queries-Without-React-Suspense-没有React-Suspense的异步请求" class="headerlink" title="Async Queries Without React Suspense 没有React Suspense的异步请求"></a>Async Queries Without React Suspense 没有React Suspense的异步请求</h3><p>It is not necessary to use React Suspense for handling pending asynchronous selectors. You can also use the <a href="https://recoiljs.org/docs/api-reference/core/useRecoilValueLoadable">useRecoilValueLoadable()</a> hook to determine the status during rendering:<br>使用React Subspense来处理进行中的异步Selector，并不是必须的。在渲染期间，也可以使用<a href="https://recoiljs.org/docs/api-reference/core/useRecoilValueLoadable">useRecoilValueLoadable()</a>钩子函数来处理状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">&#123;userID&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> userNameLoadable = useRecoilValueLoadable(userNameQuery(userID));</span><br><span class="line">    <span class="keyword">switch</span> (userNameLoadable.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;hasValue&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;userNameLoadable.contents&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;loading&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;hasError&#x27;</span>:</span><br><span class="line">            <span class="keyword">throw</span> userNameLoadable.contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Query-Refresh请求刷新"><a href="#Query-Refresh请求刷新" class="headerlink" title="Query Refresh请求刷新"></a>Query Refresh请求刷新</h3><p>When using selectors to model data queries, it’s important to remember that selector evaluation should always provide a consistent value for a given state. Selectors represent state derived from other atom and selector states. Thus, selector evaluation functions should be idempotent for a given input, as it may be cached or executed multiple times. Practically, that means a single selector should not be used for a query where you expect the results to vary during the application’s lifetime.<br>当使用Selector来发起数据请求的时候，切记，selector运算总是会提供和给定的状态一致的值。Selector代表状态派生到其他的Atom或者是selector状态。因此，对于给定的输入，Selector函数应该是幂等的。因为他可能会被缓存，或者是执行多次。实际上，这意味着一个Selector在整个应用的生命周期中不应该被应用于你希望得到的结果总是变化的请求。</p>
<p>There are a few patterns you can use for working with mutable data:<br>下面是一些应用于修改数据的模式：</p>
<h5 id="Use-a-Request-ID-用ID请求"><a href="#Use-a-Request-ID-用ID请求" class="headerlink" title="Use a Request ID 用ID请求"></a>Use a Request ID 用ID请求</h5><p>Selector evaluation should provide a consistent value for a given state based on input (dependent state or family parameters). So, you could add a request ID as either a family parameter or a dependency to your query. For example:<br>Selector运算需要为state提供基于输入（独立的状态或者是一组参数）一致的值，所以，需要为请求添加一个请求的ID，要不是参数，要不是依赖，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfoQueryRequestIDState = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfoQueryRequestID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfoQuery = selectorFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfoQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="params">userID</span> =&gt;</span> <span class="keyword">async</span> (&#123;get&#125;) =&gt; &#123;</span><br><span class="line">        get(userInfoQueryRequestIDState(userID)); <span class="comment">// Add request ID as a dependency</span></span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> response.error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRefreshUserInfo</span>(<span class="params">userID</span>) </span>&#123;</span><br><span class="line">    setUserInfoQueryRequestID = useSetRecoilState(userInfoQueryRequestIDState(userID));</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setUserInfoQueryRequestID(<span class="function"><span class="params">requestID</span> =&gt;</span> requestID++);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CurrentUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentUserID = useRecoilValue(currentUserIDState);</span><br><span class="line">    <span class="keyword">const</span> currentUserInfo = userRecoilValue(userInfoQuery(currentUserID));</span><br><span class="line">    <span class="keyword">const</span> refreshUserInfo = useRefreshUserInfo(currentUserID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;currentUser.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;refreshUserInfo&#125;</span>&gt;</span>Refresh<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Use-an-Atom-Atom使用"><a href="#Use-an-Atom-Atom使用" class="headerlink" title="Use an Atom Atom使用"></a>Use an Atom Atom使用</h5><p>Another option is to use an atom, instead of a selector, to model the query results. You can imperatively update the atom state with the new query results based on your refresh policy.<br>另外一个方法就是使用Atom,而不是Selector来处理请求结果。可以根据刷新策略使用新的查询结果强制更新atom状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userInfoState = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="function"><span class="params">userID</span> =&gt;</span> fetch(userInfoURL(userID)),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// React component to refresh query</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RefreshUserInfo</span>(<span class="params">&#123;userID&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> refreshUserInfo = useRecoilCallback(<span class="function">(<span class="params">&#123;set&#125;</span>) =&gt;</span> <span class="keyword">async</span> id =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> userInfo = <span class="keyword">await</span> myDBQuery(&#123;userID&#125;);</span><br><span class="line">        set(userInfoState(userID), userInfo);</span><br><span class="line">    &#125;, [userID]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refresh user info every second</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> intervalID = <span class="built_in">setInterval</span>(refreshUserInfo, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(intervalID);</span><br><span class="line">    &#125;, [refreshUserInfo]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One downside to this approach is that atoms do not currently support accepting a Promise as the new value in order to automatically take advantage of React Suspense while the query refresh is pending, if that is your desired behavior. However, you could store an object which manually encodes the loading status as well as the results if desired.<br>这种方法的一个缺点是atoms当前不支持接受Promise作为新值，以便在查询刷新挂起时自动利用React-Suspense（如果这是您想要的行为）。但是，如果需要，您可以存储一个手动编码加载状态和结果的对象。</p>
<p>Also consider <a href="https://recoiljs.org/docs/guides/atom-effects">atom effects</a> for query synchronization of atoms.<br>同样需求考虑<a href="https://recoiljs.org/docs/guides/atom-effects">Atom作用</a>对atom同步请求的影响。</p>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil指南--Atom Effects Atom副作用</title>
    <url>/recoil/guides/atom-effects/</url>
    <content><![CDATA[<h3 id="Atom-Effects-Atom副作用"><a href="#Atom-Effects-Atom副作用" class="headerlink" title="Atom Effects Atom副作用"></a>Atom Effects Atom副作用</h3><p>Atom Effects are a new experimental API for managing side-effects and initializing Recoil atoms. They have a variety of useful applications such as state persistence, state synchronization, managing history, logging, &amp;c. They are defined as part of the atom definition, so each atom can specify and compose their own policies. This API is still evolving, and thus marked as <code>_UNSTABLE</code>.<br>Atom Effects是为了管理副作用和初始化Recoil Atom的实验性的API。它会有多种应用，例如：状态持久化，同步状态，历史管理，日志等。这些都被定义为Atom最初定义的一部分。所以每个部分都可以有指定或者组合自己的策略。这些API还在开发中，所以暂时就把它称作<code>_UNSTABLE</code>版本吧。</p>
<hr>
<h3 id="IMPORTANT-NOTE-重要提示"><a href="#IMPORTANT-NOTE-重要提示" class="headerlink" title="IMPORTANT NOTE 重要提示"></a>IMPORTANT NOTE 重要提示</h3><p>This API is currently under development and will change. Please stay tuned…<br>这些API还在开发中。并且会有变化，所以再等等。。。。</p>
<hr>
<p>An atom effect is a function with the following definition.<br>Atom副作用是下面定义的函数：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">type AtomEffect&lt;T&gt; = (&#123;</span><br><span class="line">    <span class="attr">node</span>: RecoilState&lt;T&gt;, <span class="comment">// A reference to the atom itself</span></span><br><span class="line">    trigger: <span class="string">&#x27;get&#x27;</span> | <span class="string">&#x27;set&#x27;</span>, <span class="comment">// The action which triggered initialization of the atom</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callbacks to set or reset the value of the atom.</span></span><br><span class="line">    <span class="comment">// This can be called from the atom effect function directly to initialize the</span></span><br><span class="line">    <span class="comment">// initial value of the atom, or asynchronously called later to change it.</span></span><br><span class="line">    setSelf: (</span><br><span class="line">        | T</span><br><span class="line">        | <span class="built_in">DefaultValue</span></span><br><span class="line">        | Promise&lt;T | <span class="built_in">DefaultValue</span>&gt; <span class="comment">// Only allowed for initialization at this time</span></span><br><span class="line">        | <span class="function">(<span class="params">(T | <span class="built_in">DefaultValue</span></span>) =&gt;</span> T | <span class="built_in">DefaultValue</span>),</span><br><span class="line">    ) =&gt; <span class="keyword">void</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">resetSelf</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subscribe to changes in the atom value.</span></span><br><span class="line">    <span class="comment">// The callback is not called due to changes from this effect&#x27;s own setSelf().</span></span><br><span class="line">    onSet: (</span><br><span class="line">        <span class="function">(<span class="params">newValue: T | <span class="built_in">DefaultValue</span>, oldValue: T | <span class="built_in">DefaultValue</span></span>) =&gt;</span> <span class="keyword">void</span>,</span><br><span class="line">    ) =&gt; <span class="keyword">void</span>,</span><br><span class="line"></span><br><span class="line">&#125;) =&gt; <span class="keyword">void</span> | <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span>; <span class="comment">// Optionally return a cleanup handler</span></span><br></pre></td></tr></table></figure>
<p>Atom effects are attached to <a href="https://www.recoiljs.cn/docs/api-reference/core/atom">atoms</a> via the <code>effects_UNSTABLE</code> option. Each atom can reference an array of these atom effect functions which are called in priority order when the atom is initialized. Atoms are initialized when they are used for the first time within a <code>&lt;RecoilRoot&gt;</code>, but may be re-initialized again if they were unused and cleaned up. The atom effect function may return an optional cleanup handler to manage cleanup side-effects.<br>Atom 副作用是通过Atom的<code>effects_UNSTABLE</code>来添加的。在Atom初始化的时候。每一个Atom都可以引用一个按照优先级调用的atom副作用函数的数组。当第一次应用于<code>&lt;RecoilRoot&gt;</code>时，Atom被初始化。但是也许他们没有被调用或者没有被清除，就会被再次初始化。Atom副作用函数会返回一个可选的处理副作用的函数。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myState = atom(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MyKey&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">null</span>,</span><br><span class="line">    effects_UNSTABLE: [</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            ...effect <span class="number">1.</span>..</span><br><span class="line">            <span class="keyword">return</span> () =&gt; ...cleanup effect <span class="number">1.</span>..;</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123; ...effect <span class="number">2.</span>.. &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://www.recoiljs.cn/docs/api-reference/utils/atomFamily">Atom families</a> also support parameterized or non-parameterized effects:<br>Atom也支持参数化或者无参化：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">const myStateFamily = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;MyKey&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: <span class="function"><span class="params">param</span> =&gt;</span> [</span><br><span class="line">        <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ...effect <span class="number">1</span> using param...</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> ...cleanup effect <span class="number">1.</span>..;</span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123; ...effect <span class="number">2</span> using param... &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Compared-to-React-Effects-与React副作用相比"><a href="#Compared-to-React-Effects-与React副作用相比" class="headerlink" title="Compared to React Effects 与React副作用相比"></a>Compared to React Effects 与React副作用相比</h4><p>Atom effects could mostly be implemented via React <code>useEffect()</code>. However, the set of atoms are created outside of a React context, and it can be difficult to manage effects from within React components, particularly for dynamically created atoms. They also cannot be used to initialize the initial atom value or be used with server-side rendering. Using atom effects also co-locates the effects with the atom definitions.<br>Atom副作用主要是通过React的<code>useEffect</code>钩子函数来生效。然后atoms是在React上下文之外被创建的。并且在React组建内部管理副作用是非常困难的。特别是动态生成的atoms.这些atoms也常常并不能被用来初始化初始的atom值，或者是用来做服务端渲染。通常atom副作是和定义atom在同一处。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myState = atom(&#123;<span class="attr">key</span>: <span class="string">&#x27;Key&#x27;</span>, <span class="attr">default</span>: <span class="literal">null</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyStateEffect</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [value, setValue] = useRecoilState(myState);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Called when the atom value changes</span></span><br><span class="line">        store.set(value);</span><br><span class="line">        store.onChange(setValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; store.onChange(<span class="literal">null</span>); &#125;; <span class="comment">// Cleanup effect</span></span><br><span class="line">    &#125;, [value]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params"></span>): <span class="title">React</span>.<span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">MyStateEffect</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            ...</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Compared-to-Snapshots"><a href="#Compared-to-Snapshots" class="headerlink" title="Compared to Snapshots"></a>Compared to Snapshots</h4><p>The <a href="https://www.recoiljs.cn/docs/api-reference/core/Snapshot#hooks">Snapshot hooks</a> API can also monitor atom state changes and the initializeState prop in <a href="https://www.recoiljs.cn/docs/api-reference/core/RecoilRoot"><RecoilRoot></RecoilRoot></a> can initialize values for initial render. However, these APIs monitor all state changes and can be awkward to manage dynamic atoms, particularly atom families. With atom effects, the side-effect can be defined per-atom alongside the atom definition and multiple policies can be easily composed.<br>Snapshot hooks钩子API可以监听Atom状态的变化并且为初次渲染初始化RecoilRoot组件的初始值。然后，这些API监听所有的状态变化，并且很难管理动态的Atom.尤其是atom系列。有了atom副作用。一些副作用，就可以通过atom提前定义，并且和多种方案组合在一起。</p>
<h4 id="Logging-Example"><a href="#Logging-Example" class="headerlink" title="Logging Example"></a>Logging Example</h4><p>A simple example of using atom effects are for logging a specific atom’s state changes.<br>一个简单的使用atom副作用来记录特定atom状态的变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        <span class="function">(<span class="params">&#123;onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        onSet(<span class="function"><span class="params">newID</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.debug(<span class="string">&quot;Current user ID:&quot;</span>, newID);</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="History-Example"><a href="#History-Example" class="headerlink" title="History Example"></a>History Example</h4><p>A more complex example of logging might maintain a history of changes. This example provides an effect which maintains a history queue of state changes with callback handlers that undo that particular change:<br>一个更复杂的例子是用来维护变化的历史记录。此示例提供了一个效果，它使用撤消特定更改的回调处理程序维护状态更改的历史队列：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> history: <span class="built_in">Array</span>&lt;&#123;</span><br><span class="line">    <span class="attr">label</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">undo</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">&#125;&gt; = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> historyEffect = <span class="function"><span class="params">name</span> =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    onSet(<span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">        history.push(&#123;</span><br><span class="line">            <span class="attr">label</span>: <span class="string">`<span class="subst">$&#123;name&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.serialize(oldValue)&#125;</span> -&gt; <span class="subst">$&#123;<span class="built_in">JSON</span>.serialize(newValue)&#125;</span>`</span>,</span><br><span class="line">            <span class="attr">undo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                setSelf(oldValue);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userInfoState = atomFamily(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: <span class="function"><span class="params">userID</span> =&gt;</span> [</span><br><span class="line">        historyEffect(<span class="string">`<span class="subst">$&#123;userID&#125;</span> user info`</span>),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="State-Synchronization-Example-状态同步案例"><a href="#State-Synchronization-Example-状态同步案例" class="headerlink" title="State Synchronization Example 状态同步案例"></a>State Synchronization Example 状态同步案例</h4><p>It can be useful to use atoms as a local cached value of some other state such as a remote database, local storage, &amp;c. You could set the <code>default</code> value of an atom using the <code>default</code> property with a selector to get the store’s value. However, that is only a one-time lookup; if the store’s value changes the atom value will not change. With effects, we can subscribe to the store and update the atom’s value whenever the store changes. Calling <code>setSelf()</code> from the effect will initialize the atom to that value and will be used for the initial render. If the atom is reset, it will revert to the default value, not the initialized value.<br>将atom作为诸如，远程数据库，本地存储等的本地缓存状态是非常有用的。可以通过selector设置默认属性给atom设置默认的值来获取存储的值。然后，这只是一次性的。如果存储中的值发生了变化，而atom的值是不会有变化的。通过副作用，无论何时，我们都可以订阅存储中的值，并且更新atom的值。从副作用中调用<code>setSelf()</code>函数来初始化atom并且初次渲染。如果atom被重置。他将会再次被设置为默认值，而不是初始值。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> syncStorageEffect = <span class="keyword">user</span>ID =&gt; (&#123;<span class="built_in">set</span>Self, trigger&#125;) =&gt; &#123;</span><br><span class="line">    // Initialize atom value <span class="keyword">to</span> the remote storage <span class="keyword">state</span></span><br><span class="line">    if (trigger === &#x27;get&#x27;) &#123; // Avoid expensive initialization</span><br><span class="line">        <span class="built_in">set</span>Self(myRemoteStorage.get(<span class="keyword">user</span>ID)); // C<span class="literal">all</span> synchronously <span class="keyword">to</span> initialize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Subscribe <span class="keyword">to</span> remote storage changes and update the atom value</span><br><span class="line">    myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, <span class="keyword">user</span>Info =&gt; &#123;</span><br><span class="line">        <span class="built_in">set</span>Self(<span class="keyword">user</span>Info); // C<span class="literal">all</span> asynchronously <span class="keyword">to</span> change value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Cleanup remote storage subscription</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, null);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">user</span>InfoState = atomFamily(&#123;</span><br><span class="line">    key: &#x27;UserInfo&#x27;,</span><br><span class="line">    <span class="keyword">default</span>: null,</span><br><span class="line">    effects_UNSTABLE: <span class="keyword">user</span>ID =&gt; [</span><br><span class="line">        historyEffect(`$&#123;<span class="keyword">user</span>ID&#125; <span class="keyword">user</span> info`),</span><br><span class="line">        syncStorageEffect(<span class="keyword">user</span>ID),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Write-Through-Cache-Example"><a href="#Write-Through-Cache-Example" class="headerlink" title="Write-Through Cache Example"></a>Write-Through Cache Example</h4><p>We can also bi-directionally sync atom values with remote storage so changes on the server update the atom value and changes in the local atom are written back to the server. The effect will not call the <code>onSet()</code> handler when changed via that effect’s <code>setSelf()</code> to help avoid feedback loops.<br>我们也可以通过在服务器上的远程存储来更新atom的值也可以重写本地atom的值到服务端的方式来实现双向同步atom的值。当通过副作用的<code>setSelf()</code>来循环调用的时候，副作用不会调用<code>onSet()</code> </p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> syncStorageEffect = <span class="keyword">user</span>ID =&gt; (&#123;<span class="built_in">set</span>Self, <span class="keyword">on</span>Set, trigger&#125;) =&gt; &#123;</span><br><span class="line">    // Initialize atom value <span class="keyword">to</span> the remote storage <span class="keyword">state</span></span><br><span class="line">    if (trigger === &#x27;get&#x27;) &#123; // Avoid expensive initialization</span><br><span class="line">        <span class="built_in">set</span>Self(myRemoteStorage.get(<span class="keyword">user</span>ID)); // C<span class="literal">all</span> synchronously <span class="keyword">to</span> initialize</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Subscribe <span class="keyword">to</span> remote storage changes and update the atom value</span><br><span class="line">    myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, <span class="keyword">user</span>Info =&gt; &#123;</span><br><span class="line">        <span class="built_in">set</span>Self(<span class="keyword">user</span>Info); // C<span class="literal">all</span> asynchronously <span class="keyword">to</span> change value</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Subscribe <span class="keyword">to</span> local changes and update the server value</span><br><span class="line">    <span class="keyword">on</span>Set(<span class="keyword">user</span>Info =&gt; &#123;</span><br><span class="line">        myRemoteStorage.<span class="built_in">set</span>(<span class="keyword">user</span>ID, <span class="keyword">user</span>Info);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Cleanup remote storage subscription</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        myRemoteStorage.<span class="keyword">on</span>Change(<span class="keyword">user</span>ID, null);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Local-Storage-Persistence-本地存储持久化"><a href="#Local-Storage-Persistence-本地存储持久化" class="headerlink" title="Local Storage Persistence 本地存储持久化"></a>Local Storage Persistence 本地存储持久化</h4><p>Atom effects can be used to persist atom state with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">browser local storage</a>. Note that the following examples are simplified for illustrative purposes and do not cover all cases.<br>Atom副作用可以通过浏览器本地存储做atom状态的持久化。注意下面的例子，非常简明的说明了这点，但并不能涵盖所有。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> localStorageEffect = <span class="function"><span class="params">key</span> =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> savedValue = <span class="built_in">localStorage</span>.getItem(key)</span><br><span class="line">    <span class="keyword">if</span> (savedValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        setSelf(<span class="built_in">JSON</span>.parse(savedValue));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onSet(<span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> DefaultValue) &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserIDState = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        localStorageEffect(<span class="string">&#x27;current_user&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Backward-Compatibility"><a href="#Backward-Compatibility" class="headerlink" title="Backward Compatibility"></a>Backward Compatibility</h4><p>What if you change the format for an atom? Loading a page with the new format with a localStorage based on the old format could case a problem. You could build effects to handle restoring and validating the value in a type safe way:<br>要是你改变了atom的格式怎么办？用新的格式加在基于旧的格式的页面将会有问题。你可以创建新的副作用来重新存储并且验证值是安全的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PersistenceOptions&lt;T&gt;: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">restorer</span>: <span class="function">(<span class="params">mixed, DefaultValue</span>) =&gt;</span> T | DefaultValue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localStorageEffect = &lt;T&gt;<span class="function">(<span class="params">options: PersistenceOptions&lt;T&gt;</span>) =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> savedValue = <span class="built_in">localStorage</span>.getItem(options.key)</span><br><span class="line">    <span class="keyword">if</span> (savedValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        setSelf(options.restorer(<span class="built_in">JSON</span>.parse(savedValue), <span class="keyword">new</span> DefaultValue()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onSet(<span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> DefaultValue) &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(options.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(options.key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserIDState = atom&lt;<span class="built_in">number</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        localStorageEffect(&#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;current_user&#x27;</span>,</span><br><span class="line">        <span class="attr">restorer</span>: <span class="function">(<span class="params">value, defaultValue</span>) =&gt;</span></span><br><span class="line">            <span class="comment">// values are currently persisted as numbers</span></span><br><span class="line">            <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">            ? value</span><br><span class="line">            <span class="comment">// if value was previously persisted as a string, parse it to a number</span></span><br><span class="line">            : <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">            ? <span class="built_in">parseInt</span>(value, <span class="number">10</span>)</span><br><span class="line">            <span class="comment">// if type of value is not recognized, then use the atom&#x27;s default value.</span></span><br><span class="line">            : defaultValue</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>What if the key used to persist the value changes? Or what used to be persisted using one key now uses several? Or vice versa? That can also be handled in a type-safe way:<br>要是持久化数据的key变化了怎么办？或者是之前用一个，现在用了多个key怎么办？反之亦然。这也依然可以通过安全的方式来处理：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PersistenceOptions&lt;T&gt;: &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">restorer</span>: <span class="function">(<span class="params">mixed, DefaultValue, <span class="built_in">Map</span>&lt;<span class="built_in">string</span>, mixed&gt;</span>) =&gt;</span> T | DefaultValue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localStorageEffect = &lt;T&gt;<span class="function">(<span class="params">options: PersistenceOptions&lt;T&gt;</span>) =&gt;</span> <span class="function">(<span class="params">&#123;setSelf, onSet&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> savedValues = parseValuesFromStorage(<span class="built_in">localStorage</span>);</span><br><span class="line">    <span class="keyword">const</span> savedValue = savedValues.get(options.key);</span><br><span class="line">    setSelf(</span><br><span class="line">        options.restorer(savedValue ?? <span class="keyword">new</span> DefaultValue(), <span class="keyword">new</span> DefaultValue(), savedValues),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    onSet(<span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue <span class="keyword">instanceof</span> DefaultValue) &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(options.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(options.key, <span class="built_in">JSON</span>.stringify(newValue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> currentUserIDState = atom&lt;<span class="built_in">number</span>&gt;(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;CurrentUserID&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">effects_UNSTABLE</span>: [</span><br><span class="line">        localStorageEffect(&#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&#x27;current_user&#x27;</span>,</span><br><span class="line">        <span class="attr">restorer</span>: <span class="function">(<span class="params">value, defaultValue, values</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> oldValue = values.get(<span class="string">&#x27;old_key&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> oldValue === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defaultValue;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Browser-URL-History-Persistence-浏览器URL历史数据持久化"><a href="#Browser-URL-History-Persistence-浏览器URL历史数据持久化" class="headerlink" title="Browser URL History Persistence 浏览器URL历史数据持久化"></a>Browser URL History Persistence 浏览器URL历史数据持久化</h4><p>Atom state can also be persisted and synced with the browser URL history. This can be useful to have state changes update the current URL so it can be saved or shared with others to restore that state. It can also be integrated with the browser history to leverage the browser forward/back buttons. Examples or a library to provide this type of persistence are coming soon…<br>浏览器同样可以用来做浏览器URL历史的数据持久化和数据的同步。这在处理更新当前URL状态是非常有用的，这对于保存或者和与别的Atom共享重新存储状态是非常有用的。它还可以与浏览器历史记录集成，以利用浏览器前进/后退按钮。提供这个功能的案例或者是库正在开发中…</p>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil API手册--Selector(options)</title>
    <url>/recoil/api/recoil-state/selector/</url>
    <content><![CDATA[<p>Selectors represent a function, or <strong>derived state</strong> in Recoil. You can think of them as similar to an “idempotent” or “pure function” without side-effects that always returns the same value for a given set of dependency values. If only a get function is provided, the selector is read-only and returns a <code>RecoilValueReadOnly</code> object. If a <code>set</code> is also provided, it returns a writeable <code>RecoilState</code> object.</p>
<p>Recoil manages atom and selector state changes to know when to notify components subscribing to that selector to re-render. If an object value of a selector is mutated directly it may bypass this and avoid properly notifying subscribing components. To help detect bugs, Recoil will freeze selector value objects in development mode.</p>
<hr>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">function selector<span class="params">&lt;T&gt;</span>(&#123;</span><br><span class="line"><span class="symbol">    key:</span> string,</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    get:</span> (&#123;</span><br><span class="line"><span class="symbol">        get:</span> GetRecoilValue</span><br><span class="line">    &#125;) =&gt; T | Promise<span class="params">&lt;T&gt;</span> | RecoilValue<span class="params">&lt;T&gt;</span>,</span><br><span class="line"></span><br><span class="line">    set?: (</span><br><span class="line">        &#123;</span><br><span class="line"><span class="symbol">            get:</span> GetRecoilValue,</span><br><span class="line"><span class="symbol">            set:</span> SetRecoilState,</span><br><span class="line"><span class="symbol">            reset:</span> ResetRecoilState,</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="symbol">        newValue:</span> T | DefaultValue,</span><br><span class="line">    ) =&gt; void,</span><br><span class="line"></span><br><span class="line">    dangerouslyAllowMutability?: boolean,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">ValueOrUpdater</span>&lt;<span class="type">T</span>&gt; = <span class="type">T</span> | <span class="type">DefaultValue</span> | ((prevValue: <span class="type">T</span>) =&gt; <span class="type">T</span> | <span class="type">DefaultValue</span>);</span><br><span class="line"><span class="keyword">type</span> <span class="type">GetRecoilValue</span> = &lt;<span class="type">T</span>&gt;(<span class="type">RecoilValue</span>&lt;<span class="type">T</span>&gt;) =&gt; <span class="type">T</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="type">SetRecoilState</span> = &lt;<span class="type">T</span>&gt;(<span class="type">RecoilState</span>&lt;<span class="type">T</span>&gt;, <span class="type">ValueOrUpdater</span>&lt;<span class="type">T</span>&gt;) =&gt; void;</span><br><span class="line"><span class="keyword">type</span> <span class="type">ResetRecoilState</span> = &lt;<span class="type">T</span>&gt;(<span class="type">RecoilState</span>&lt;<span class="type">T</span>&gt;) =&gt; void;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>key</code> - A unique string used to identify the atom internally. This string should be unique with respect to other atoms and selectors in the entire application. It needs to be stable across executions if used for persistence.</p>
</li>
<li><p><code>get</code> - A function that evaluates the value for the derived state. It may return either a value directly or an asynchronous Promise or another atom or selector representing the same type. It is passed an object as the first parameter containing the following properties:</p>
<ul>
<li>get - a function used to retrieve values from other atoms/selectors. All atoms/selectors passed to this function will be implicitly added to a list of <strong>dependencies</strong> for the selector. If any of the selector’s dependencies change, the selector will re-evaluate.</li>
</ul>
</li>
<li><p><code>set?</code> - If this property is set, the selector will return <strong>writeable</strong> state. A function that is passed an object of callbacks as the first parameter and the new incoming value. The incoming value may be a value of type T or maybe an object of type <code>DefaultValue</code> if the user reset the selector. The callbacks include:</p>
<ul>
<li><code>get</code> - a function used to retrieve values from other atoms/selectors. This function will not subscribe the selector to the given atoms/selectors.</li>
<li><code>set</code> - a function used to set the values of upstream Recoil state. The first parameter is the Recoil state and the second parameter is the new value. The new value may be an updater function or a DefaultValue object to propagate reset actions.</li>
</ul>
</li>
<li><p><code>dangerouslyAllowMutability</code> - In some cases it may be desireable allow mutating of objects stored in selectors that don’t represent state changes. Use this option to override freezing objects in development mode.</p>
</li>
</ul>
<hr>
<p>A selector with a simple static dependency:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySelector = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MySelector&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; <span class="keyword">get</span>(myAtom) * <span class="number">100</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Dynamic-Dependencies"><a href="#Dynamic-Dependencies" class="headerlink" title="Dynamic Dependencies"></a>Dynamic Dependencies</h3><p>A read-only selector has a <code>get</code> method which evaluates the value of the selector based on dependencies. If any of those dependencies are updated, then the selector will re-evaluate. The dependencies are dynamically determined based on the atoms or selectors you actually use when evaluating the selector. Depending on the values of the previous dependencies, you may dynamically use different additional dependencies. Recoil will automatically update the current data-flow graph so that the selector is only subscribed to updates from the current set of dependencies.</p>
<p>In this example <code>mySelector</code> will depend on the <code>toggleState</code> atom as well as either <code>selectorA</code> or <code>selectorB</code> depending on the state of <code>toggleState</code>.</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> toggleState = atom(&#123;<span class="built_in">key</span>: <span class="string">&#x27;Toggle&#x27;</span>, <span class="keyword">default</span>: <span class="keyword">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mySelector = selector(&#123;</span><br><span class="line">    <span class="built_in">key</span>: <span class="string">&#x27;MySelector&#x27;</span>,</span><br><span class="line">    <span class="built_in">get</span>: (&#123;<span class="built_in">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> toggle = <span class="built_in">get</span>(toggleState);</span><br><span class="line">        <span class="keyword">if</span> (toggle) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">get</span>(selectorA);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">get</span>(selectorB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Writeable-Selectors"><a href="#Writeable-Selectors" class="headerlink" title="Writeable Selectors"></a>Writeable Selectors</h3><p>A bi-directional selector receives the incoming value as a parameter and can use that to propagate the changes back upstream along the data-flow graph. Because the user may either set the selector with a new value or reset the selector, the incoming value is either of the same type that the selector represents or a <code>DefaultValue</code> object which represents a reset action.</p>
<p>This simple selector essentially wraps an atom to add an additional field. It just passes through set and reset operations to the upstream atom.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxySelector = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;ProxySelector&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; (&#123;...<span class="keyword">get</span>(myAtom), extraField: <span class="string">&#x27;hi&#x27;</span>&#125;),</span><br><span class="line">    <span class="keyword">set</span>: (&#123;<span class="keyword">set</span>&#125;, newValue) =&gt; <span class="keyword">set</span>(myAtom, newValue),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This selector transforms the data, so needs to check if the incoming value is a <code>DefaultValue</code>.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transformSelector = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;TransformSelector&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: (&#123;<span class="keyword">get</span>&#125;) =&gt; <span class="keyword">get</span>(myAtom) * <span class="number">100</span>,</span><br><span class="line">    <span class="keyword">set</span>: (&#123;<span class="keyword">set</span>&#125;, newValue) =&gt;</span><br><span class="line">        <span class="keyword">set</span>(myAtom, newValue instanceof DefaultValue ? newValue : newValue / <span class="number">100</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Asynchronous-Selectors"><a href="#Asynchronous-Selectors" class="headerlink" title="Asynchronous Selectors"></a>Asynchronous Selectors</h3><p>Selectors may also have asynchronous evaluation functions and return a <code>Promise</code> to the output value. Please see <a href="https://www.recoiljs.cn/docs/guides/asynchronous-data-queries">this guide</a> for more information.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myQuery = selector(&#123;</span><br><span class="line">    key: <span class="string">&#x27;MyQuery&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span>: <span class="keyword">async</span> (&#123;<span class="keyword">get</span>&#125;) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> myAsyncQuery(<span class="keyword">get</span>(queryParamState));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Example-Synchronous"><a href="#Example-Synchronous" class="headerlink" title="Example (Synchronous)"></a>Example (Synchronous)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom, selector, useRecoilState, DefaultValue&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tempFahrenheit = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;tempFahrenheit&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">32</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tempCelsius = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;tempCelsius&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">&#123;get&#125;</span>) =&gt;</span> ((get(tempFahrenheit) - <span class="number">32</span>) * <span class="number">5</span>) / <span class="number">9</span>,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">&#123;set&#125;, newValue</span>) =&gt;</span></span><br><span class="line">        set(</span><br><span class="line">            tempFahrenheit,</span><br><span class="line">            newValue <span class="keyword">instanceof</span> DefaultValue ? newValue : (newValue * <span class="number">9</span>) / <span class="number">5</span> + <span class="number">32</span></span><br><span class="line">        ),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TempCelsius</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [tempF, setTempF] = useRecoilState(tempFahrenheit);</span><br><span class="line">    <span class="keyword">const</span> [tempC, setTempC] = useRecoilState(tempCelsius);</span><br><span class="line">    <span class="keyword">const</span> resetTemp = useResetRecoilState(tempCelsius);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> addTenCelsius = <span class="function">() =&gt;</span> setTempC(tempC + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> addTenFahrenheit = <span class="function">() =&gt;</span> setTempF(tempF + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> reset = <span class="function">() =&gt;</span> resetTemp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            Temp (Celsius): &#123;tempC&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            Temp (Fahrenheit): &#123;tempF&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addTenCelsius&#125;</span>&gt;</span>Add 10 Celsius<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addTenFahrenheit&#125;</span>&gt;</span>Add 10 Fahrenheit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;reset&#125;</span>&gt;</span>&gt;Reset<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example-Asynchronous"><a href="#Example-Asynchronous" class="headerlink" title="Example (Asynchronous)"></a>Example (Asynchronous)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;selector, useRecoilValue&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myQuery = selector(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;MyDBQuery&#x27;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(getMyRequestUrl());</span><br><span class="line">        <span class="keyword">return</span> response.json();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QueryResults</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> queryResults = useRecoilValue(myQuery);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;queryResults.foo&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ResultsSection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">QueryResults</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Please see <a href="https://www.recoiljs.cn/docs/guides/asynchronous-data-queries">this guide</a> for more complex examples.</p>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
  <entry>
    <title>Recoil API手册--atom(options)</title>
    <url>/recoil/api/recoil-state/atom/</url>
    <content><![CDATA[<p>An atom represents state in Recoil. The <code>atom()</code> function returns a writeable <code>RecoilState</code> object.<br>atom代表了Recoil中的状态，<code>atom()</code>返回了一个可读写的Recoil状态对象。</p>
<hr>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> atom<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(</span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">   <span class="built_in"> key</span>:<span class="built_in"> string</span>,</span></span><br><span class="line"><span class="xquery">    default: T | Promise<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span> | RecoilValue</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>,</span></span></span><br><span class="line"><span class="xml"><span class="xquery">    effects_UNSTABLE?: $ReadOnlyArray&lt;AtomEffect</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>&gt;,</span></span></span><br><span class="line"><span class="xml"><span class="xquery">    dangerouslyAllowMutability?: boolean,</span></span></span><br><span class="line"><span class="xml"><span class="xquery">&#125;</span></span><span class="xml">): RecoilState</span><span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>key</code> - A unique string used to identify the atom internally. This string should be unique with respect to other atoms and selectors in the entire application.<br><code>key</code>字段是一个用来定义内部atom的唯一的字符串，这个是字符串必须是唯一的，用来区分应用程序中所有的atoms和selector.</li>
<li><code>default</code> - The initial value of the atom or a Promise or another atom or selector representing a value of the same type.<br><code>default</code>字段用来初始化一个atom或者Promise或者另一个atom或者是selector具有相同类型的初始值。</li>
<li><code>effects_UNSTABLE</code> - An optional array of Atom Effects for the atom.<br><code>effects_UNSTABLE</code>字段一个可选的atom副作用数组。</li>
<li><code>dangerouslyAllowMutability</code> - In some cases it may be desireable allow mutating of objects stored in atoms that don’t represent state changes. Use this option to override freezing objects in development mode.<br><code>dangerouslyAllowMutability</code>在某些情况下，他是用来描述允许atoms存储的对象发生转化，但是并不代表状态会发生变化。可以用这个选项在开发环境来冻结对象。</li>
</ul>
<hr>
<p>Recoil manages atom state changes to know when to notify components subscribing to that atom to re-render, so you should use the hooks listed below to change atom state. If an object stored in an atom was mutated directly it may bypass this and cause state changes without properly notifying subscribing components. To help detect bugs Recoil will freeze objects stored in atoms in development mode.</p>
<p>Recoil管理atom状态是通过通知组建订阅atom状态实现重新渲染，所以，应该使用下面的hooks函数来使得atom状态发生变化。如果一个存储在atom中的对象被直接改变，那就会引起组建没有被通知订阅而atom状态发生变化。为了解决这个bug，Recoil会在开发环境冻结存储在atom中的对象。</p>
<p>Most often, you’ll use the following hooks to interact with atoms:<br>通常情况下，需要使用下列的hooks函数来使得atoms发生变化。</p>
<ul>
<li><a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilState">useRecoilState()</a>: Use this hook when you intend on both reading and writing to the atom. This hook subscribes the component to the atom.<br><a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilState">useRecoilState()</a>:当你要读写atom的时候使用这个钩子函数，这个钩子函数会订阅组建的atom.</li>
<li><a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilValue">useRecoilValue()</a>: Use this hook when you intend on only reading the atom. This hook subscribes the component to the atom.<br><a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilValue">useRecoilValue()</a>:当只是读取atom的时候。使用这个钩子函数，这个钩子函数会订阅组建的atom.</li>
<li><a href="https://www.recoiljs.cn/docs/api-reference/core/useSetRecoilState">useSetRecoilState()</a>: Use this hook when you intend on only writing to the atom.<br><a href="https://www.recoiljs.cn/docs/api-reference/core/useSetRecoilState">useSetRecoilState()</a>:当只是操作atom的时候。使用这个钩子函数。</li>
<li><a href="https://www.recoiljs.cn/docs/api-reference/core/useResetRecoilState">useResetRecoilState()</a>: Use this hook to reset an atom to its default value.<br><a href="https://www.recoiljs.cn/docs/api-reference/core/useResetRecoilState">useResetRecoilState()</a>:当重置atom的默认值的时候，使用这个钩子函数。<br>For rare cases where you need to read an atom’s value without subscribing to the component, see <a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a>.</li>
</ul>
<p>对于极少数需要读取atom的值，而不需要订阅组建，可以参考<a href="https://www.recoiljs.cn/docs/api-reference/core/useRecoilCallback">useRecoilCallback()</a>。</p>
<p>You can initialize an atom either with a static value or with a <code>Promise</code> or a <code>RecoilValue</code> representing a value of the same type. Because the Promise may be pending or the default selector may be asynchronous it means that the atom value may also be pending or throw an error when reading. Note that you cannot currently assign a <code>Promise</code> when setting an atom. Please use <a href="https://www.recoiljs.cn/docs/api-reference/core/selector">selectors</a> for async functions.</p>
<p>可以用通过一个具有共同类型的静态值或者是一个<code>Promise</code>或者是一个<code>RecoilValue</code>来初始化atom.因为Promise也许是进行中，或者默认的selector会是异步的，这就会使得atom的状态也是处于进行中或者是抛出一个错误。所以，当是这atom的时候，并不能将当前标注为<code>Promise</code>,请使用selector异步函数。</p>
<p>Atoms cannot be used to store <code>Promise&#39;s</code> or <code>RecoilValue&#39;s</code> directly, but they may be wrapped in an object. Note that <code>Promise&#39;s</code> may be mutable. Atoms can be set to a <code>function</code>, as long as it is pure, but to do so you may need to use the updater form of setters. (e.g. <code>set(myAtom, () =&gt; myFunc);</code>).</p>
<p>Atoms不能被直接才存储为<code>Promise</code>或者是<code>RecoilValue&#39;s</code>, 但是他们可以被包裹为一个对象。注意<code>Promise</code>可能被改变。Atoms可以被设置为是个函数，只要纯净，就可以使用setters的更新方式。(e.g. <code>set(myAtom, () =&gt; myFunc);</code>).</p>
<p>案例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;atom, useRecoilState&#125; <span class="keyword">from</span> <span class="string">&#x27;recoil&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = atom(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;myCounter&#x27;</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useRecoilState(counter);</span><br><span class="line">    <span class="keyword">const</span> incrementByOne = <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            Count: &#123;count&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;incrementByOne&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>recoil</category>
      </categories>
      <tags>
        <tag>recoil</tag>
      </tags>
  </entry>
</search>
